<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>VinhLin</title>
    <description>Technology Blog</description>
    <link>https://vinhlin.github.io/</link>
    
    <language>en</language>
    <copyright>Copyright 2024, Calvin Tran</copyright>
    <lastBuildDate>Sat, 06 Jul 2024 15:21:33 +0700</lastBuildDate>
    <generator>Hugo - gohugo.io</generator>
    <docs>http://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link href="https://vinhlin.github.io//atom.xml" rel="self" type="application/atom+xml"/>
    
    
    <item>
      <title>Rust_for_ARM</title>
      <link>https://vinhlin.github.io/posts/iot/software/rust_for_arm/</link>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hiện tại đã dùng &lt;strong&gt;Rust&lt;/strong&gt; để code &lt;strong&gt;Bất đồng bộ&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Với MCU thì dùng framework &lt;a href=&#34;https://github.com/embassy-rs/embassy&#34;&gt;embassy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Với Linux (hoặc Windows) thì dùng &lt;a href=&#34;https://github.com/tokio-rs/tokio&#34;&gt;tokio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Với framework tokio thì mình đã có một project nhỏ &lt;em&gt;(tên là Tracking_Report)&lt;/em&gt;, mục tiêu là build app để lấy thông tin trên &lt;strong&gt;NATS Server&lt;/strong&gt; và gửi data lên &lt;strong&gt;ThingsBoard&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Theo suy nghĩ đơn giản thì mình chỉ cần build code để chạy trên kiến trúc &lt;strong&gt;ARM&lt;/strong&gt; là được. Nhưng khi dùng &lt;strong&gt;Cross Compilation&lt;/strong&gt; để build thì lại &lt;strong&gt;lỗi tè le&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chưa rõ lý do. Tạm thời sẽ documents lại những gì làm đc và những tài liệu liên quan.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;document-lại-rust-cross-compilation-cho-arm&#34;&gt;Document lại Rust Cross Compilation cho ARM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mình có tìm được một project về &lt;em&gt;Cross Compilation&lt;/em&gt;, tên là &lt;a href=&#34;https://github.com/locnnil/rust_cross_compilation&#34;&gt;rust cross compilation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mình đã làm theo và test thử cho raspberry thì chạy được, &lt;strong&gt;nhưng khi áp dụng vào Tracking_Report thì build vẫn lỗi&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kiểm-tra-thông-tin-của-raspberry-cm4&#34;&gt;Kiểm tra thông tin của Raspberry CM4&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kiểm tra phần cứng:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cat /sys/firmware/devicetree/base/model
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Kiểm tra kiến trúc:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lscpu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Rust_for_ARM/Hinh_1.png&#34;
  alt=&#34;Hình 1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vậy phần cứng &lt;strong&gt;Raspberry CM4&lt;/strong&gt;, thông tin:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Model name: Cortex-A72
Architecture: armv7l
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Theo tài liệu trên github &lt;a href=&#34;https://github.com/locnnil/rust_cross_compilation&#34;&gt;rust_cross_compilation&lt;/a&gt; thì:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# For my armv7l embedded computer
$ rustup target add armv7-unknown-linux-gnueabi 

# For my Raspberry Pi Zero W
$ rustup target add arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Dựa trên &lt;a href=&#34;https://doc.rust-lang.org/beta/rustc/platform-support.html&#34;&gt;platform support&lt;/a&gt; có thông tin:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;target&lt;/th&gt;
&lt;th&gt;std&lt;/th&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;armv7-unknown-linux-gnueabi&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;Armv7-A Linux (kernel 4.15, glibc 2.27)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;setup-trên-máy-ubuntu&#34;&gt;Setup trên máy Ubuntu&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đầu tiên là cài rust cho linux &lt;em&gt;(ở đây là máy Ubuntu)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Sau đó mình cần cài đặt một số công cụ:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rustup target add armv7-unknown-linux-gnueabi
sudo apt install gcc-arm-linux-gnueabi
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Download project:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/LOCNNIL/rust_cross_compilation.git
cd rust_cross_compilation/
cargo build --target armv7-unknown-linux-gnueabi
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Lưu ý về file &lt;code&gt;.cargo/config.toml&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# target config for Embedded Computer with armv7l arch
[target.armv7-unknown-linux-gnueabi]
linker = &amp;#34;arm-linux-gnueabi-gcc&amp;#34;
rustflags = [&amp;#34;-C&amp;#34;, &amp;#34;target-feature=+crt-static&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Sau đó copy file sang Pi:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo scp target/armv7-unknown-linux-gnueabi/debug/cross-arm pi@192.168.10.100:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;run-on-pi&#34;&gt;Run on Pi&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Quay lại Pi, và chạy lệnh:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./cross-arm
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Đã chạy đc thành công.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Rust_for_ARM/Hinh_2.png&#34;
  alt=&#34;Hình 2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h2 id=&#34;tổng-hợp-một-số-tài-liệu-khác&#34;&gt;Tổng hợp một số tài liệu khác:&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://www.acmesystems.it/arm9_toolchain
https://harmonicss.co.uk/rust/rust-on-a-raspberry-pi-part-1/
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Đây là một tutorial làm quen với việc &lt;strong&gt;viết OS cho Raspberry&lt;/strong&gt;, tên project: &lt;a href=&#34;https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials&#34;&gt;rust-raspberrypi-OS-tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ghi-chú-khác-về-armv7-unknown-linux-uclibceabihttpsdocrust-langorgrustcplatform-supportarmv7-unknown-linux-uclibceabihtml&#34;&gt;Ghi chú khác về &lt;a href=&#34;https://doc.rust-lang.org/rustc/platform-support/armv7-unknown-linux-uclibceabi.html&#34;&gt;armv7-unknown-linux-uclibceabi&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U). &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Tức là khi code rust và build file với target là &lt;code&gt;armv7-unknown-linux-uclibceabi&lt;/code&gt; thì có thể sẽ chạy được trên &lt;strong&gt;OpneWRT&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/rust_for_arm/</guid>
      <pubDate>Thu, 10 Oct 2024 17:30:29 +0700</pubDate>
    </item>
    
    <item>
      <title>Android_Automotive</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/android_automotive/</link>
      <description>&lt;p&gt;Trong lúc lướt lát trên facebook, mình vô tình bắt gặp một bài viết &lt;strong&gt;Android Automotive Boot Process A-Z&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Từ đó vô tình biết thêm được một trang chia sẻ kiến thức về mảng Automotive.&lt;/p&gt;
&lt;p&gt;👉Website: &lt;a href=&#34;https://devlinux.vn/newest&#34;&gt;https://devlinux.vn/newest&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;trang-tổng-hợp-các-bài-viết-về-android-automotivehttpsdevlinuxvnseriesbasic-android-automotive&#34;&gt;Trang tổng hợp các bài viết về &lt;a href=&#34;https://devlinux.vn/series/basic-android-automotive&#34;&gt;Android Automotive&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;tổng-quát-về-bài-viết-android-automotive-boot-process-a-zhttpsdevlinuxvnpostandroid-boot-process-a-z&#34;&gt;Tổng quát về bài viết &lt;a href=&#34;https://devlinux.vn/post/android-boot-process-a-z&#34;&gt;Android Automotive Boot Process A-Z&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Tóm tắt các bước chính trong quá trình khởi động Android: &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Boot ROM&lt;/strong&gt;: Khi hệ thống bật nguồn, bộ nhớ ROM được kích hoạt đầu tiên. Đây là nơi chứa mã khởi động ban đầu giúp xác định thiết bị lưu trữ chứa phần mềm hệ điều hành.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bootloader&lt;/strong&gt;: Sau khi Boot ROM hoàn thành, Bootloader được tải lên để bắt đầu nạp kernel của hệ điều hành vào bộ nhớ.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read Boot Config&lt;/strong&gt;: Bootloader đọc cấu hình khởi động từ các thiết bị lưu trữ (như thẻ SD, eMMC, USB).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Chọn thiết bị khởi động (Boot Device)&lt;/strong&gt;: Dựa trên cấu hình boot, hệ thống chọn thiết bị chứa kernel của hệ điều hành.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Kernel Linux&lt;/strong&gt;: Kernel của Linux được tải và bắt đầu thực hiện các chức năng cốt lõi của hệ điều hành.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Android Init Process&lt;/strong&gt;: Quá trình khởi tạo của Android được thực hiện, bao gồm khởi chạy các dịch vụ cơ bản và phân quyền bằng SELinux.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Zygote Process&lt;/strong&gt;: Zygote là một tiến trình quan trọng trong Android, khởi tạo các hệ thống máy ảo Dalvik/ART, giúp tạo ra các tiến trình ứng dụng.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;System Server&lt;/strong&gt;: Khởi động các dịch vụ hệ thống Android như quản lý pin, cảm biến, dịch vụ mạng, dịch vụ quản lý ứng dụng và các dịch vụ liên quan đến phương tiện di chuyển.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Launcher&lt;/strong&gt;: Cuối cùng, Android khởi động giao diện người dùng chính (Launcher), nơi người dùng có thể tương tác với hệ thống.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Android_Automotive_Boot_Process.jpg&#34;
  alt=&#34;Boot_Process&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/android_automotive/</guid>
      <pubDate>Mon, 07 Oct 2024 11:06:24 +0700</pubDate>
    </item>
    
    <item>
      <title>Fault_Injection</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/fault_injection/</link>
      <description>&lt;p&gt;&lt;strong&gt;Fault Injection&lt;/strong&gt; là một kỹ thuật được sử dụng trong việc kiểm tra và đảm bảo độ tin cậy của các hệ thống phần mềm và phần cứng.&lt;/p&gt;
&lt;p&gt;Mục đích của kỹ thuật này là cố tình tạo ra các lỗi hoặc điều kiện bất thường trong hệ thống để xem hệ thống sẽ phản ứng như thế nào, từ đó đánh giá được tính ổn định và khả năng xử lý lỗi của hệ thống.&lt;/p&gt;
&lt;p&gt;Có thể hiểu đơn giản rằng khi bạn phát triển một hệ thống, bạn luôn mong muốn nó hoạt động một cách hoàn hảo.&lt;/p&gt;
&lt;p&gt;Nhưng trong thực tế, có nhiều yếu tố như lỗi phần cứng, lỗi phần mềm, hoặc những sự cố bất ngờ từ môi trường ngoài có thể ảnh hưởng đến hệ thống.&lt;/p&gt;
&lt;p&gt;Fault injection giúp mô phỏng những tình huống này bằng cách cố tình đưa ra các lỗi, ví dụ như:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Lỗi phần cứng&lt;/strong&gt;: Giả lập các vấn đề như bộ nhớ bị lỗi, đường truyền bị gián đoạn. &lt;/br&gt;
&lt;strong&gt;Lỗi phần mềm&lt;/strong&gt;: Gây ra lỗi trong code như chia cho 0, tràn bộ đệm (buffer overflow), hoặc làm hỏng dữ liệu. &lt;/br&gt;
&lt;strong&gt;Điều kiện thời gian&lt;/strong&gt;: Gây trễ (delay) hoặc thay đổi thời gian xử lý để kiểm tra khả năng xử lý của hệ thống trong những điều kiện bất lợi. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mục tiêu của Fault Injection là đảm bảo hệ thống có thể hoạt động tốt, hoặc ít nhất là không bị phá hỏng hoàn toàn, khi xảy ra các lỗi này.&lt;/p&gt;
&lt;p&gt;Đây là một phương pháp rất hữu ích trong việc tăng cường độ tin cậy và an toàn của các hệ thống, đặc biệt là trong các ứng dụng quan trọng như hàng không, ô tô, y tế, hay các hệ thống nhúng.&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://www.techtarget.com/rms/onlineimages/whatis-fault_injection_testing.png&#34;
  alt=&#34;Fault Injection&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h2 id=&#34;bài-viết-how-to-voltage-fault-injectionhttpswwwsynacktivcompublicationshow-to-voltage-fault-injection&#34;&gt;Bài viết &lt;a href=&#34;https://www.synacktiv.com/publications/how-to-voltage-fault-injection&#34;&gt;How to voltage fault injection&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Trong quá trình đánh giá bảo mật vật lý của thiết bị IoT, một trong những mục tiêu là &lt;strong&gt;tận dụng giao diện gỡ lỗi&lt;/strong&gt; của chip để có thể truy cập và nghiên cứu cách hoạt động của thiết bị. &lt;/br&gt;
Một kịch bản lý tưởng là trích xuất toàn bộ hệ thống tệp để &lt;strong&gt;tìm cách giành quyền truy cập root vào thiết bị&lt;/strong&gt;. Sau đó là &lt;em&gt;kiểm tra những dịch vụ nào đang chạy&lt;/em&gt;, &lt;em&gt;debug&lt;/em&gt; để cuối cùng là kiểm soát mục tiêu (target). &lt;/br&gt;
Khi bắt đầu quá trình kiểm tra, chúng ta thường gặp phải các biện pháp bảo vệ trên giao diện gỡ lỗi cấm truy cập vào đầy đủ chức năng của nó hoặc trên chuỗi khởi động cấm bất kỳ sửa đổi nào trên đó. &lt;/br&gt;
&lt;code&gt;Glitching&lt;/code&gt; là một cách để cố gắng vượt qua loại bảo vệ này. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;glitching&#34;&gt;Glitching&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Glitching là một kỹ thuật tấn công trong bảo mật, trong đó kẻ tấn công cố tình gây ra sự cố hoặc nhiễu trong hệ thống để tạo ra các hành vi bất thường.&lt;/li&gt;
&lt;li&gt;Phương pháp này thường áp dụng cho các vi điều khiển hoặc thiết bị nhúng, nơi mà việc gây nhiễu tạm thời vào nguồn điện, xung nhịp, hoặc các tín hiệu khác có thể khiến hệ thống thực hiện các lệnh sai hoặc bỏ qua các bước kiểm tra an ninh.&lt;/li&gt;
&lt;li&gt;Điều này có thể dẫn đến việc tiết lộ thông tin nhạy cảm hoặc truy cập trái phép.&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/fault_injection/</guid>
      <pubDate>Sat, 05 Oct 2024 20:13:46 +0700</pubDate>
    </item>
    
    <item>
      <title>Car_Hacking</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/car_hacking/</link>
      <description>&lt;h1 id=&#34;book-the-car-hacker-handbookhttpsdocsalexomarcombibliotecathecarhackershandbookpdf&#34;&gt;Book: &lt;a href=&#34;https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf&#34;&gt;The Car Hacker Handbook&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Car_Hacking/Car_Hacking.jpg&#34;
  alt=&#34;Car Hacking&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Trong quá trình tìm hiểu về &lt;code&gt;CAN - OBDII&lt;/code&gt; vô tình &lt;strong&gt;lụm&lt;/strong&gt; được tài liệu về &lt;strong&gt;Car Hacking&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Có những thông tin, kiến thức mà thông thường tìm hiểu về CAN-Bus sẽ không thấy. Từ những &lt;strong&gt;key-work&lt;/strong&gt; này lại tiếp tục research thêm, và có thêm được những thông tin thú vị khác.&lt;/p&gt;
&lt;h2 id=&#34;can-bus-packet&#34;&gt;CAN Bus Packet&lt;/h2&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Car_Hacking/Hinh_1.png&#34;
  alt=&#34;Hinh_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Điểm đặc trưng của CAN bus là các gói tin được phát quảng bá &lt;strong&gt;(broadcast)&lt;/strong&gt; đến tất cả các thiết bị (controllers) trên cùng mạng, giống như cách UDP hoạt động trên mạng Ethernet.&lt;/p&gt;
&lt;p&gt;Một số vấn đề chính liên quan đến cơ chế này:&lt;/p&gt;
&lt;h3 id=&#34;phát-quảng-bá-trên-can-bus&#34;&gt;Phát quảng bá trên CAN bus&lt;/h3&gt;
&lt;p&gt;Trong mạng CAN bus, các gói tin (packets) được gửi ra sẽ không chỉ định đích cụ thể cho một thiết bị nào mà thay vào đó, tất cả các node (thiết bị) trên bus sẽ nhận được gói tin đó. Điều này có nghĩa là:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Mọi thiết bị trên cùng một mạng CAN đều nhìn thấy mọi gói tin&lt;/strong&gt;. &lt;/br&gt;
Các thiết bị sẽ tự quyết định liệu có xử lý gói tin hay bỏ qua nó, dựa trên ID của gói tin. Gói tin chứa một trường ID (identifier) để các thiết bị nhận diện loại dữ liệu và quyết định liệu nó có phải xử lý thông tin hay không. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;không-có-thông-tin-về-nguồn-gốc-của-gói-tin&#34;&gt;Không có thông tin về nguồn gốc của gói tin&lt;/h3&gt;
&lt;p&gt;Các gói tin trên CAN bus không chứa thông tin về nguồn gốc (tức là không có địa chỉ của thiết bị gửi), mà chỉ có ID của thông điệp. Điều này tạo ra một số vấn đề:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Không có cách để biết được thiết bị nào đã gửi gói tin&lt;/strong&gt;, điều này có thể gây ra khó khăn trong việc giám sát và bảo mật. &lt;/br&gt;
&lt;strong&gt;Giả lập thiết bị khác&lt;/strong&gt;: Bất kỳ thiết bị nào trên mạng CAN đều có thể gửi gói tin với ID bất kỳ. Điều này có nghĩa là nếu một thiết bị hoặc một kẻ tấn công muốn giả lập một thiết bị khác, họ có thể dễ dàng gửi các gói tin với ID của thiết bị cần giả lập, khiến các thiết bị khác nghĩ rằng dữ liệu đến từ thiết bị chính thức. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tấn-công-trên-can-bus&#34;&gt;Tấn công trên CAN bus&lt;/h3&gt;
&lt;p&gt;Do tính chất mở và phát quảng bá của CAN bus, nó dễ trở thành mục tiêu cho các cuộc tấn công:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tấn công giả lập (Spoofing)&lt;/strong&gt;: Như đã nêu, kẻ tấn công có thể gửi các gói tin giả mạo từ một thiết bị khác mà các node khác không thể phân biệt được, vì CAN không có cách để xác minh nguồn gốc của gói tin. &lt;/br&gt;
&lt;strong&gt;Tấn công phát ngập (Flooding)&lt;/strong&gt;: Kẻ tấn công có thể phát liên tục các gói tin với độ ưu tiên cao, làm tắc nghẽn mạng, ngăn các thiết bị khác truyền thông tin. &lt;/br&gt;
&lt;strong&gt;Tấn công từ chối dịch vụ (DoS)&lt;/strong&gt;: Bằng cách phát đi các gói tin không hợp lệ hoặc giả mạo, kẻ tấn công có thể làm gián đoạn hoạt động của hệ thống CAN. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;bảo-mật-hạn-chế-trên-can-bus&#34;&gt;Bảo mật hạn chế trên CAN bus&lt;/h3&gt;
&lt;p&gt;Do CAN bus ban đầu được thiết kế cho các hệ thống nhúng không kết nối với bên ngoài (như ô tô, máy móc công nghiệp), bảo mật không được ưu tiên trong thiết kế của giao thức:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Không có cơ chế xác thực&lt;/strong&gt;: CAN bus không có cơ chế tích hợp để xác thực nguồn gốc của các gói tin. &lt;/br&gt;
&lt;strong&gt;Không có mã hóa&lt;/strong&gt;: Dữ liệu truyền trên CAN bus không được mã hóa, vì vậy bất kỳ thiết bị nào trên mạng cũng có thể đọc được toàn bộ nội dung của các gói tin. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;giải-pháp-bảo-mật&#34;&gt;Giải pháp bảo mật&lt;/h3&gt;
&lt;p&gt;Vì các vấn đề bảo mật vốn có của CAN bus, các giải pháp bảo mật cần được thiết kế thêm ở cấp độ ứng dụng hoặc hệ thống, bao gồm:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Xác thực gói tin&lt;/strong&gt;: Sử dụng các giải pháp xác thực ở mức ứng dụng để kiểm tra xem gói tin có được gửi từ nguồn tin cậy không. &lt;/br&gt;
&lt;strong&gt;Mã hóa dữ liệu&lt;/strong&gt;: Mặc dù CAN bus không hỗ trợ mã hóa dữ liệu nội tại, các giải pháp mã hóa có thể được thêm vào ở lớp ứng dụng để bảo vệ dữ liệu nhạy cảm. &lt;/br&gt;
&lt;strong&gt;Giám sát mạng CAN&lt;/strong&gt;: Các hệ thống giám sát (IDS/IPS) có thể được sử dụng để phát hiện các hành vi bất thường trên mạng, như tấn công phát ngập hoặc giả lập thiết bị. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;
&lt;h3 id=&#34;socketcan&#34;&gt;SocketCAN&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SocketCAN là một framework trong Linux giúp quản lý và giao tiếp với CAN bus thông qua giao diện lập trình socket, giống như cách xử lý các giao tiếp mạng khác như Ethernet. Nó giúp lập trình viên dễ dàng sử dụng CAN bus mà không cần phải tìm hiểu các giao thức phức tạp hoặc các driver riêng biệt.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Car_Hacking/Hinh_2.png&#34;
  alt=&#34;Hinh_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Install &lt;a href=&#34;https://github.com/linux-can/can-utils&#34;&gt;can-utils&lt;/a&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get install can-utils
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Nhìn chung đây là một công cụ phần mềm dành cho CAN-Bus &lt;em&gt;(giống như công cụ minicom dành cho cổng Serial)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Do đó mình sẽ cần một &lt;a href=&#34;https://www.amazon.com/dp/B07P9JGXXB?ref=ppx_yo2ov_dt_b_product_details&amp;amp;th=1&#34;&gt;thiết bị phần cứng&lt;/a&gt; để giao tiếp CAN-Bus, giống như trong video &lt;a href=&#34;https://www.youtube.com/watch?v=GA-KNEuAR9w&#34;&gt;MCP2515 CAN Bus Module Tutorial with Arduino and Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;wireshark&#34;&gt;Wireshark&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đây là công cụ quá phổ biến cho việc bắt gói tin.&lt;/li&gt;
&lt;li&gt;Do đó mình có thể dùng &lt;em&gt;wireshark&lt;/em&gt; để bắt gói tin của CAN.&lt;/li&gt;
&lt;li&gt;Để bắt được gói tin CAN, thì mình cần dùng kết hợp giữa &lt;strong&gt;SocketCAN&lt;/strong&gt; với &lt;strong&gt;Wireshark&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Đôi khi wireshark không thể lắng nghe thiết bị &lt;code&gt;slcanX&lt;/code&gt;, do đó mình sẽ cần dùng các command có trong bộ công cụ &lt;strong&gt;can-utils&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;candump
cansniffer
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;kayakhttpsdschanoehgithubiokayak-is-an-application-for-can-bus-diagnosis-and-monitoring&#34;&gt;&lt;a href=&#34;https://dschanoeh.github.io/Kayak/&#34;&gt;Kayak&lt;/a&gt; is an application for CAN bus diagnosis and monitoring.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dschanoeh/Kayak&#34;&gt;Github Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dschanoeh.github.io/Kayak/tutorial.html&#34;&gt;Kayak- tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Features:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- view raw CAN data on a bus
- view CAN frames interpreted as signals and messages
- XML-based bus definitions
- connect to to multiple CAN busses on different machines at once
- multiple users can connect to the same CAN bus using a single CAN controller
- no platform dependend code
- core library without dependencies for use in other applications that need to handle CAN frames
- rich client application (Netbeans RCP)
- easily write your own plugins using the Netbeans plugin system
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;ecusim-obd-simulator&#34;&gt;ECUsim OBD simulator&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.obdsol.com/solutions/development-tools/obd-simulators/ecusim-2000/&#34;&gt;ECUsim 2000&lt;/a&gt;: Simulators can generate faults and MIL lights, and they include fault knobs for changing common vehicle parameters, such as speed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img
  src=&#34;https://www.scantool.net/static/images/products/ecusim_2000/ecusim_2000_diagram_web.png&#34;
  alt=&#34;ECUsim 2000&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Document: &lt;a href=&#34;https://www.scantool.net/scantool/downloads/101/ecusim_2000-ug.pdf&#34;&gt;ECUsim 2000 User Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Document: &lt;a href=&#34;https://www.scantool.net/static/documentation/ecusim/ecusim-pm.pdf&#34;&gt;ECUsim Programming Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;other-documents&#34;&gt;Other Documents&lt;/h2&gt;
&lt;h3 id=&#34;obd-can-bus-equipped-vehicleshttpwwwauterrawebcomaboutcanhtml&#34;&gt;&lt;a href=&#34;http://www.auterraweb.com/aboutcan.html&#34;&gt;OBD CAN Bus Equipped Vehicles&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;ecu-pin-out-diagramshttpswwwinnovatemotorsportscomecu-pin-out-diagrams&#34;&gt;&lt;a href=&#34;https://www.innovatemotorsports.com/ecu-pin-out-diagrams/&#34;&gt;ECU PIN-OUT DIAGRAMS&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;chipwhispererhttpswwwnewaecomchipwhisperer&#34;&gt;&lt;a href=&#34;https://www.newae.com/chipwhisperer&#34;&gt;ChipWhisperer&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chipwhisperer.readthedocs.io/en/latest/getting-started.html&#34;&gt;getting-started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rtfm.newae.com/&#34;&gt;Documentation Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.newae.com/education&#34;&gt;Education &amp;amp; Training&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/car_hacking/</guid>
      <pubDate>Sat, 05 Oct 2024 13:55:01 +0700</pubDate>
    </item>
    
    <item>
      <title>CAN_OBDII</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/can_obdii/</link>
      <description>&lt;h2 id=&#34;can-bus-serial-communication---how-it-workshttpswwwyoutubecomwatchvjzsczrt9tto&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=JZSCzRT9TTo&#34;&gt;CAN Bus: Serial Communication - How It Works?&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/CAN_1.png&#34;
  alt=&#34;CAN_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controller Area Network (CAN hoặc CAN Bus)&lt;/strong&gt; một giao thức truyền thông nối tiếp bất đồng bộ.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/CAN_2.png&#34;
  alt=&#34;CAN_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bus CAN chỉ có 2 dây giúp kết nối các module điều khiển với nhau dễ dàng hơn khi so sánh với cách làm truyền thống.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/CAN_3.png&#34;
  alt=&#34;CAN_3&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Do trên ô tô tín hiệu bị nhiễu rất nhiều (sử dụng nhiều mô-tơ), nên &lt;strong&gt;CAN Protocol&lt;/strong&gt; đã được phát triển để &lt;strong&gt;chống nhiễu&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Ban đầu CAN được thiết kế dành cho ngành công nghiệp ô tô, tuy nhiên hiện nay CAN cũng đã trở thành một tiêu chuẩn phổ biến trong tự động hóa công nghiệp và các ngành khác.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bit-rate-tốc-độ-truyền-dữ-liệu-và-transmission-distances-khoảng-cách-truyền-dữ-liệu&#34;&gt;Bit Rate (Tốc độ truyền dữ liệu) và Transmission Distances (Khoảng cách truyền dữ liệu)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CAN bus sử dụng các tốc độ truyền dữ liệu khác nhau, thường được tính bằng kilobit trên giây (kbps).&lt;/li&gt;
&lt;li&gt;Hình dưới là công thức:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/CAN_4.png&#34;
  alt=&#34;CAN_4&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tốc độ truyền dữ liệu càng cao thì lượng dữ liệu có thể truyền trong một khoảng thời gian càng lớn, nhưng lại có sự đánh đổi với &lt;strong&gt;khoảng cách truyền&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Dưới đây là bảng biểu thị mối quan hệ giữa tốc độ truyền dữ liệu và khoảng cách truyền tối đa cho CAN bus:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/CAN_5.png&#34;
  alt=&#34;CAN_5&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ngoài tốc độ truyền và khoảng cách, một số yếu tố khác cũng có thể ảnh hưởng đến hiệu suất truyền dẫn trên CAN bus:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chất lượng dây cáp&lt;/strong&gt;: Dây cáp có trở kháng phù hợp sẽ giúp tín hiệu truyền ổn định hơn.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nhiễu điện từ&lt;/strong&gt;: Môi trường có nhiều nhiễu điện từ (EMI) có thể làm giảm chất lượng tín hiệu.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Số lượng thiết bị trên bus&lt;/strong&gt;: Mỗi thiết bị trên CAN bus sẽ tạo ra tải (load) và có thể ảnh hưởng đến hiệu suất tổng thể.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;can-transceiver&#34;&gt;CAN Transceiver&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;CAN transceiver không thực hiện bất kỳ xử lý logic nào liên quan đến giao thức CAN mà chỉ làm nhiệm vụ chuyển đổi tín hiệu. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Một ví dụ phổ biến về CAN transceiver là &lt;a href=&#34;https://ww1.microchip.com/downloads/en/devicedoc/20001667g.pdf&#34;&gt;MCP2551&lt;/a&gt; của Microchip, được sử dụng rất nhiều trong các ứng dụng CAN bus.&lt;/li&gt;
&lt;li&gt;Ngoài ra cũng có một số loại &lt;strong&gt;CAN Transceiver&lt;/strong&gt; khác như:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nxp.com/docs/en/data-sheet/TJA1050.pdf&#34;&gt;TJA1050&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ti.com/lit/ds/symlink/sn65hvd230.pdf?ts=1727771231223&amp;amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FSN65HVD230%253Futm_source%253Dgoogle%2526utm_medium%253Dcpc%2526utm_campaign%253Dasc-null-null-GPN_EN-cpc-pf-google-soas%2526utm_content%253DSN65HVD230%2526ds_k%253DSN65HVD230+Datasheet%2526DCM%253Dyes%2526gad_source%253D1%2526gclid%253DCj0KCQjwu-63BhC9ARIsAMMTLXR7R_weCPL_OVEche7n0ns9PKmoIPJQEKCm7Smr_0-Ta597tHP5OdEaAt8jEALw_wcB%2526gclsrc%253Daw.ds&#34;&gt;SN65HVD230&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;can-bus-controllers&#34;&gt;CAN Bus Controllers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CAN bus Controller&lt;/strong&gt; là một vi mạch tích hợp (IC) chứa tất cả các logic và khả năng xử lý dữ liệu để gửi và nhận các thông điệp CAN bus.&lt;/li&gt;
&lt;li&gt;Tuy nhiên, nó không có các chân đầu ra trực tiếp &lt;code&gt;CAN_H&lt;/code&gt; và &lt;code&gt;CAN_L&lt;/code&gt; (là các đường tín hiệu vật lý của CAN bus), mà thay vào đó chỉ có các chân TX và RX ở mức logic.&lt;/li&gt;
&lt;li&gt;Điều này có nghĩa là nó cần phải được kết nối với một CAN transceiver (bộ chuyển đổi CAN) để chuyển đổi tín hiệu logic thành tín hiệu vật lý trên CAN bus.&lt;/li&gt;
&lt;li&gt;Bởi vì CAN Controller chỉ hoạt động ở mức logic (0 và 1), cần có một CAN transceiver để chuyển đổi tín hiệu logic đó thành tín hiệu differential &lt;em&gt;(tín hiệu vi sai)&lt;/em&gt; trên &lt;code&gt;CAN_H&lt;/code&gt; và &lt;code&gt;CAN_L&lt;/code&gt; (đây là hai dây tín hiệu của CAN bus).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/CAN_6.png&#34;
  alt=&#34;CAN_6&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CAN Bus Microcontroller Peripherals&lt;/strong&gt;: Nhiều vi điều khiển (MCU) hiện đại có tích hợp CAN controller như một phần peripheral bên trong.
Ví dụ, các dòng vi điều khiển như &lt;strong&gt;STM32&lt;/strong&gt; hoặc &lt;strong&gt;ESP32&lt;/strong&gt; có thể chứa sẵn CAN controller trên chip. Điều này giúp giảm thiểu sự phức tạp trong thiết kế phần cứng vì không cần thêm một IC CAN controller bên ngoài.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mối-quan-hệ-giữa-can-controller-và-transceiver&#34;&gt;Mối quan hệ giữa CAN Controller và Transceiver:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Như vậy, để giao tiếp hoàn chỉnh trên CAN bus, cả CAN controller và CAN transceiver đều cần thiết:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CAN controller&lt;/strong&gt;: Thực hiện các chức năng logic, quản lý giao thức CAN, và truyền/nhận dữ liệu qua các tín hiệu TX/RX ở mức logic.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CAN transceiver&lt;/strong&gt;: Chuyển đổi các tín hiệu logic từ CAN controller thành tín hiệu vi sai và ngược lại để tương tác với mạng CAN vật lý (&lt;code&gt;CAN_H&lt;/code&gt; và &lt;code&gt;CAN_L&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Một thiết kế CAN bus điển hình sẽ bao gồm:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Vi điều khiển (MCU)&lt;/strong&gt;: Gửi/nhận dữ liệu và điều khiển hệ thống. &lt;/br&gt;
&lt;strong&gt;CAN Controller&lt;/strong&gt;: Xử lý thông điệp CAN, giao tiếp với MCU qua các giao thức như SPI. &lt;/br&gt;
&lt;strong&gt;CAN Transceiver&lt;/strong&gt;: Chuyển đổi tín hiệu giữa CAN Controller và CAN bus. &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;tài-liệu-tham-khảo&#34;&gt;Tài liệu tham khảo:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf&#34;&gt;Tài liệu Car Hacking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tài liệu khác:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1727681723175&amp;amp;ref_url=https%253A%252F%252Fwww.google.com.sg%252F
https://mesidas.com/can-canbus/
https://community.nxp.com/t5/NXP-Tech-Blog/101-Controller-Area-Network-CAN-standard/ba-p/1217054
https://www.typhoon-hil.com/documentation/typhoon-hil-software-manual/References/can_bus_protocol.html
https://blog.mbedded.ninja/electronics/communication-protocols/can-protocol/
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;obd&#34;&gt;OBD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Các bài viết liên quan:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://www.otosaigon.com/threads/huong-dan-chan-doan-loi-bang-may-quet-obd2-cho-nguoi-nghiep-du.9075318/
https://autoitech.vn/obd-ii-ma-loi-tren-o-to-phan-1/
https://vinfastauto.com/vn_vi/he-thong-obd-tren-o-to-va-nhung-dieu-can-biet
https://www.thegioididong.com/hoi-dap/cong-obd-2-la-gi-cac-tien-ich-tu-cong-obd-2-tren-xe-o-to-1292647
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;OBD (On – Board Diagnostics)&lt;/strong&gt;, hay còn gọi là hệ thống chẩn đoán lỗi OBD, được trang bị trên ô tô để theo dõi và điều chỉnh một số hoạt động của phương tiện. Hệ thống này thu thập thông tin từ mạng lưới các cảm biến gắn cố định quanh xe, phát hiện lỗi hư hỏng và cảnh báo tới người lái nhằm kịp thời đưa ra phương án xử lý.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/H%e1%bb%87_th%e1%bb%91ng_OBD.jpg&#34;
  alt=&#34;OBD&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cổng kết nối OBDII:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/CAN_OBDII/OBDII_Pinout.jpg&#34;
  alt=&#34;OBD_pinout&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Theo mình hiểu thì OBD là một chuẩn (gồm cổng kết nối, protocol) để các hãng xe làm theo quy chuẩn này.&lt;/li&gt;
&lt;li&gt;Mình liên tưởng điều này với bộ thiết bị GSHT, ví dụ với mỗi nhà phát hành một thiết bị GSHT thì sẽ có một bộ protocol của họ.&lt;/li&gt;
&lt;li&gt;Tuy nhiên các thiết bị GSHT này đều phải tuân theo &lt;strong&gt;QCVN31&lt;/strong&gt; (bao gồm công kết nối, protocol của bản tin). Khi tuân theo chuẩn chung này thì nhà nước, chính quyền có thể đọc thông tin từ thiết bị GSHT khi có vấn đề xảy ra.&lt;/li&gt;
&lt;li&gt;Nếu hiểu như vậy thì sẽ phân biệt và dễ hiểu hơn giữa &lt;strong&gt;CAN vs OBD&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tài-liệu-về-mã-lỗi-trên-obdii&#34;&gt;Tài liệu về mã lỗi trên OBDII&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://www.obd-codes.com/
https://www.obd-codes.com/faq/obd2-codes-explained.php
https://en.wikipedia.org/wiki/OBD-II_PIDs
&lt;/code&gt;&lt;/pre&gt;</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/can_obdii/</guid>
      <pubDate>Tue, 01 Oct 2024 15:56:03 +0700</pubDate>
    </item>
    
    <item>
      <title>Rust Lang</title>
      <link>https://vinhlin.github.io/posts/iot/software/rust-lang/</link>
      <description>&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust_Embedded.png&#34;
  alt=&#34;Rust_Embedded&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Ngày&lt;/th&gt;
&lt;th&gt;Mô tả&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1/4/2024&lt;/td&gt;
&lt;td&gt;Khởi tạo bài viết&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17/8/2024&lt;/td&gt;
&lt;td&gt;Cập nhật bài viết, thêm thông tin về Rust-lang&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13/9/2024&lt;/td&gt;
&lt;td&gt;Update thêm documents về Rust&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;hạn-chế&#34;&gt;Hạn chế&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://users.rust-lang.org/t/why-is-there-so-much-mismanagement-in-the-rust-foundation-and-core-team/94822&#34;&gt;Năm 2023 xảy ra nhiều dramma của Rust Found&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust là ngôn ngữ &lt;strong&gt;khó học, code khó&lt;/strong&gt;.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=EYCBm0xAWow&amp;amp;list=LL&amp;amp;index=3&#34;&gt;5 things I wish I knew before learning Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=fknamfNtKk0&#34;&gt;Why do developers hate Rust?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cộng đồng &lt;strong&gt;DEV&lt;/strong&gt; chưa quá đông như Golang. &lt;a href=&#34;https://spectrum.ieee.org/the-top-programming-languages-2023&#34;&gt;Top Programming Languages 2023&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lợi-ích&#34;&gt;Lợi ích&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Rust là ngôn ngữ &lt;strong&gt;low level&lt;/strong&gt;, được sử dụng cho nhiều mục đích khác nhau:
&lt;ul&gt;
&lt;li&gt;Dùng để code nhúng.&lt;/li&gt;
&lt;li&gt;Dùng để code phía Server.&lt;/li&gt;
&lt;li&gt;Có thể dùng để code OS - như &lt;a href=&#34;https://rust-for-linux.com/&#34;&gt;Rust for Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rust chú trọng vào sự an toàn - &lt;strong&gt;memory safety&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cộng đồng Rust vẫn đang phát triển. &lt;a href=&#34;https://pypl.github.io/PYPL.html&#34;&gt;Dựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rust-roadmaphttpsroadmapshrust&#34;&gt;&lt;a href=&#34;https://roadmap.sh/rust&#34;&gt;Rust Roadmap&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;tài-liệu-về-rust&#34;&gt;Tài liệu về Rust&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/help/rust/getting-started.html&#34;&gt;Rust IDE - RustRover&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rust-embedded.org/book/&#34;&gt;The Embedded Rust Book&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://std-dev-guide.rust-lang.org/&#34;&gt;Standard library developers Guide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.rust-lang.org/&#34;&gt;Blog Rust&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://doc.rust-lang.org/rust-by-example/index.html&#34;&gt;Rust By Example&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://rust-tieng-viet.github.io/getting-started/first-project.html&#34;&gt;Rust Tiếng Việt&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=rAl-9HwD858&amp;amp;list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa&amp;amp;index=3&#34;&gt;Youtube - Crust of Rust&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/@letsgetrusty&#34;&gt;Youtube - Let&amp;rsquo;s Get Rusty&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1kQidzAlbqapu-WZTuw4Djik0uTqMZYyiMXTM9F21Dz4/edit?lid=75778#heading=h.gjdgxs&#34;&gt;Rust Cheatsheet&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://os.phil-opp.com/&#34;&gt;Writing an OS in Rust&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;cập-nhật-1782024&#34;&gt;Cập nhật 17/8/2024&lt;/h1&gt;
&lt;h3 id=&#34;youtube-where-is-rust-being-usedhttpswwwyoutubecomwatchv42fhqwq6sva&#34;&gt;Youtube: &lt;a href=&#34;https://www.youtube.com/watch?v=42FhQWQ6SVA&#34;&gt;Where is Rust being used?&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;tổng-hợp-rust-is-for-roboticshttpsroboticsrs&#34;&gt;Tổng hợp &lt;a href=&#34;https://robotics.rs/&#34;&gt;Rust is for Robotics&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Project &lt;a href=&#34;https://github.com/ros2-rust/ros2_rust&#34;&gt;ros2_rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Project &lt;a href=&#34;https://github.com/Sollimann/CleanIt&#34;&gt;CleanIt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;doc-offline-first-smart-energy-monitor-with-rust-esp32-and-thingsboardhttpsmoslehiancomposts20223-ofmon&#34;&gt;Doc: &lt;a href=&#34;https://moslehian.com/posts/2022/3-ofmon/&#34;&gt;Offline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Nereuxofficial/nostd-wifi-lamp&#34;&gt;nostd-wifi-lamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/JurajSadel/esp32c3-no-std-async-mqtt-demo&#34;&gt;esp32c3-no-std-async-mqtt-demo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;framework-cho-mqtt-cho-rust-rumqtthttpsgithubcombytebeamiorumqtt&#34;&gt;Framework cho MQTT cho Rust: &lt;a href=&#34;https://github.com/bytebeamio/rumqtt&#34;&gt;rumqtt&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/obabec/rust-mqtt&#34;&gt;rust-mqtt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;framework-nats-for-rust-natsrshttpsgithubcomnats-ionatsrs&#34;&gt;Framework NATS for Rust: &lt;a href=&#34;https://github.com/nats-io/nats.rs&#34;&gt;nats.rs&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Có thể sử dụng NATS cho ThingsBoard.&lt;/li&gt;
&lt;li&gt;Sample code từ ChatGPT:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use nats::asynk::Connection;
use serde::{Deserialize, Serialize};
use serde_json::json;
use tokio::time::{sleep, Duration};

#[derive(Debug, Serialize, Deserialize)]
struct TelemetryData {
    device_id: String,
    temperature: f64,
    humidity: f64,
    timestamp: u64,
}

#[tokio::main]
async fn main() -&amp;gt; std::io::Result&amp;lt;()&amp;gt; {
    // Connect to the NATS server
    let nc: Connection = nats::asynk::connect(&amp;#34;demo.nats.io&amp;#34;).await?;

    // Subscribe to a subject where ThingsBoard publishes telemetry data
    let subscription = nc.subscribe(&amp;#34;thingsboard.telemetry&amp;#34;).await?;

    // Process incoming messages
    while let Some(msg) = subscription.next().await {
        // Parse the telemetry data (assumed to be JSON)
        let telemetry: TelemetryData = serde_json::from_slice(&amp;amp;msg.data).expect(&amp;#34;Failed to parse telemetry data&amp;#34;);

        println!(&amp;#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}&amp;#34;,
                 telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp);

        // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject
        let response_subject = format!(&amp;#34;thingsboard.ack.{}&amp;#34;, telemetry.device_id);
        let ack_message = json!({
            &amp;#34;device_id&amp;#34;: telemetry.device_id,
            &amp;#34;status&amp;#34;: &amp;#34;acknowledged&amp;#34;,
            &amp;#34;timestamp&amp;#34;: telemetry.timestamp
        });

        nc.publish(&amp;amp;response_subject, ack_message.to_string().as_bytes()).await?;
    }

    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&#34;cập-nhật-1392024&#34;&gt;Cập nhật 13/9/2024&lt;/h1&gt;
&lt;h2 id=&#34;bài-viết-35-rust-learning-resources-every-beginner-should-know-in-2022httpsblogtheembeddedrustaceancom35-rust-learning-resources-every-beginner-should-know-in-2022&#34;&gt;Bài viết: &lt;a href=&#34;https://blog.theembeddedrustacean.com/35-rust-learning-resources-every-beginner-should-know-in-2022&#34;&gt;35 Rust Learning Resources Every Beginner Should Know in 2022&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Trong bài viết này tổng hợp rất nhiều documents cho beginner để bắt đầu với Rust.&lt;/li&gt;
&lt;li&gt;Ở đây mình thấy có những trang rất hay, ví dụ:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tour-of-rusthttpstourofrustcom&#34;&gt;&lt;a href=&#34;https://tourofrust.com/&#34;&gt;Tour of Rust&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Trang này có tiếng Việt và có thêm phần để run code.&lt;/p&gt;
&lt;h3 id=&#34;a-half-hour-to-learn-rusthttpsfasterthanlimearticlesa-half-hour-to-learn-rust&#34;&gt;&lt;a href=&#34;https://fasterthanli.me/articles/a-half-hour-to-learn-rust&#34;&gt;A half-hour to learn Rust&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;a-gentle-introduction-to-rusthttpsstevedonovangithubiorust-gentle-introreadmehtml&#34;&gt;&lt;a href=&#34;https://stevedonovan.github.io/rust-gentle-intro/readme.html&#34;&gt;A Gentle Introduction To Rust&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;easy-rusthttpsdhghomongithubioeasy_rustchapter_1html&#34;&gt;&lt;a href=&#34;https://dhghomon.github.io/easy_rust/Chapter_1.html&#34;&gt;Easy Rust&lt;/a&gt;&lt;/h3&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/rust-lang/</guid>
      <pubDate>Fri, 13 Sep 2024 15:14:13 +0700</pubDate>
    </item>
    
    <item>
      <title>Hoi_thao_2024</title>
      <link>https://vinhlin.github.io/posts/others/hoi_thao_2024/</link>
      <description>&lt;h2 id=&#34;link-video-hội-thảo-và-triển-lãm-an-toàn-thông-tin-phía-nam-2024httpswwwfacebookcomvnisahcmvideos1461942441187294&#34;&gt;Link Video: &lt;a href=&#34;https://www.facebook.com/VNISA.HCM/videos/1461942441187294&#34;&gt;Hội thảo và Triển lãm An toàn Thông tin phía Nam 2024&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sau khi xem và nghe xong thì mình có nhiều thông tin hữu ích như sau&lt;/p&gt;
&lt;h3 id=&#34;thiết-bị-phần-cứng---khóa-xác-thực&#34;&gt;Thiết bị phần cứng - Khóa xác thực&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Với loại sản phẩm này thì bên VinCSS cũng có.&lt;/li&gt;
&lt;li&gt;Và ngoài ra, hiện tại &lt;strong&gt;HPT&lt;/strong&gt; cũng đang bán sản phẩm chính hãng &lt;a href=&#34;https://hpttechstore.com/collections/khoa-bao-mat-yubikey&#34;&gt;Khóa bảo mật Yubikey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mình đã mua 1 cái, sau khi xem clip của anh Duy Luân, &lt;a href=&#34;https://www.youtube.com/watch?v=wmC7ZDJfHa0&#34;&gt;link.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;phishing&#34;&gt;Phishing&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/4_layer.png&#34;
  alt=&#34;4_layer&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trong video thì có nói về 1 trong các kiểu tấn công phổ biến hiện nay, để từ đó trình bày cách phòng thủ cho phù hợp.&lt;/li&gt;
&lt;li&gt;Và thường thì quá trình tấn công của hacker hiện tại là &lt;strong&gt;phishing&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gửi email&lt;/strong&gt; có mã độc &amp;mdash;&amp;gt; &lt;strong&gt;Cài malware&lt;/strong&gt; vào máy nạn nhân trong tổ chức.&lt;/li&gt;
&lt;li&gt;Âm thầm &lt;em&gt;mò mẫm&lt;/em&gt; trong &lt;strong&gt;hệ thống Network&lt;/strong&gt; của tổ chức, và tìm cơ hội để &lt;strong&gt;tấn công vào Server&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;backdoor&#34;&gt;Backdoor&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/3_cach_backdoor.png&#34;
  alt=&#34;backdoor&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hacker thường cài cắm backdoor thường bằng 1 trong 3 cách.&lt;/li&gt;
&lt;li&gt;Thứ 1: Tạo &lt;strong&gt;Webshell&lt;/strong&gt;, nguy cơ này đến từ việc sử dụng mã nguồn không hợp lệ.&lt;/li&gt;
&lt;li&gt;Thứ 2: &lt;strong&gt;Tạo account dễ nhầm lẫn&lt;/strong&gt;. Giả sử hacker đã xâm nhập vào máy nạn nhân, vậy tránh bị phát hiện thì hacker sẽ tạo ra các account với tên &lt;strong&gt;bình thường&lt;/strong&gt; để tránh bị phát hiện.&lt;/li&gt;
&lt;li&gt;Thứ 3: Dùng &lt;strong&gt;DLL&lt;/strong&gt; (&lt;em&gt;cái này thì mình cũng chưa rõ lắm&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;backup&#34;&gt;Backup&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Backup_zip_code.png&#34;
  alt=&#34;backup&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Giờ mình mới biết có thuật ngữ mới backup &lt;code&gt;32110&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Có &lt;strong&gt;ít nhất&lt;/strong&gt; là 3 bản dữ liệu &lt;em&gt;(kể cả bản đang vận hành)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Vị trí đặt các bản sao phải ở &lt;strong&gt;2 địa điểm&lt;/strong&gt; khác nhau.&lt;/li&gt;
&lt;li&gt;Có ít nhất &lt;strong&gt;1 bản copy đặt ở local&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Có ít nhất &lt;strong&gt;1 bản offline&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Tất cả các bản backup phải đều &lt;strong&gt;không bị lỗi&lt;/strong&gt; và có thể sử dụng được.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Một lưu ý quan trọng là tất cả data backup phải được mã hóa.&lt;/p&gt;
&lt;h3 id=&#34;các-hình-ảnh-được-capture-từ-bài-trình-bày-của-nhóm-chống-lừa-đảo&#34;&gt;Các hình ảnh được capture từ bài trình bày của nhóm &lt;strong&gt;Chống lừa đảo&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_1.png&#34;
  alt=&#34;Hình_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_2.png&#34;
  alt=&#34;Hình_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_3.png&#34;
  alt=&#34;Hình_3&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_4.png&#34;
  alt=&#34;Hình_4&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_5.png&#34;
  alt=&#34;Hình_5&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_6.png&#34;
  alt=&#34;Hình_6&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Hoi_thao_2024/Hinh_7.png&#34;
  alt=&#34;Hình_7&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/others/hoi_thao_2024/</guid>
      <pubDate>Mon, 02 Sep 2024 16:29:20 +0700</pubDate>
    </item>
    
    <item>
      <title>Box_RFID</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/box_rfid/</link>
      <description>&lt;p&gt;Sau quá trình &lt;a href=&#34;https://blog.vinhld-homelab.io.vn/posts/iot/hardware/research_cr95/&#34;&gt;Research_CR95&lt;/a&gt; và vất vả code FW cho bộ hộp đọc thẻ này.&lt;/p&gt;
&lt;p&gt;Cuối cùng cũng đã hoàn thành.&lt;/p&gt;
&lt;h1 id=&#34;thông-tin-về-bộ-đọc-thẻ-rfid&#34;&gt;Thông tin về bộ đọc thẻ RFID.&lt;/h1&gt;
&lt;h2 id=&#34;yêu-cầu-thông-tin-về-thẻ-tài-xế&#34;&gt;Yêu cầu thông tin về thẻ tài xế&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GPLX&lt;/strong&gt;: 12 ký tự số.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tên tài xế&lt;/strong&gt;: Sử dụng ký tự chữ (Viết hoa).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ID&lt;/strong&gt;: 10 ký tự số&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hộp-đọc-thẻ-rfid&#34;&gt;Hộp đọc thẻ RFID&lt;/h2&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Research_CR95/RFID_Box.jpg&#34;
  alt=&#34;RFID&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Nếu đọc thẻ thành công, thì đèn led &lt;strong&gt;DN&lt;/strong&gt; sẽ chớp sáng &lt;strong&gt;1 lần&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lần tag thẻ tiếp theo&lt;/strong&gt; cần phải cách &lt;strong&gt;lần tag thẻ trước đó&lt;/strong&gt;, ít nhất là &lt;strong&gt;3s&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;feature-tính-năng&#34;&gt;Feature (Tính năng)&lt;/h2&gt;
&lt;h3 id=&#34;debug&#34;&gt;Debug:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Show debug, send command: &lt;code&gt;IT_TRACE1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Turn off debug, send command: &lt;code&gt;IT_TRACE0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;request-version&#34;&gt;Request Version:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Send&lt;/th&gt;
&lt;th&gt;Response&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$DVSRFID,VER&lt;/td&gt;
&lt;td&gt;$DVSRFID,VER,1.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;đọc-thẻ&#34;&gt;Đọc thẻ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Khi đặt thẻ vào bộ đọc, nếu đọc thành công, thiết bị sẽ gửi ra thông tin:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$DVSRFID,READ,123456789012,NGUYENVANA,1234567890
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Trong đó:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;123456789012&lt;/strong&gt;: là thông tin về GPLX &lt;br&gt;
&lt;strong&gt;NGUYENVANA&lt;/strong&gt;: là tên tài xế (NGUYEN VAN A) &lt;br&gt;
&lt;strong&gt;1234567890&lt;/strong&gt;: là thông tin ID Card &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Nếu thẻ bị lỗi thông tin, thì thiết bị sẽ trả ra:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$DVSRFID,READ,,,
&lt;/code&gt;&lt;/pre&gt;</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/box_rfid/</guid>
      <pubDate>Thu, 29 Aug 2024 18:38:50 +0700</pubDate>
    </item>
    
    <item>
      <title>NFC_PWA</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/nfc_pwa/</link>
      <description>&lt;h3 id=&#34;một-số-bài-viết-về-việc-sử-dụng-web-pwa-để-đánh-cắp-thông-tin&#34;&gt;Một số bài viết về việc sử dụng Web PWA để đánh cắp thông tin:&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa
https://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/
https://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;github-project-nfcgatehttpsgithubcomnfcgatenfcgate&#34;&gt;Github project: &lt;a href=&#34;https://github.com/nfcgate/nfcgate&#34;&gt;nfcgate&lt;/a&gt;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/nfcgate/nfcgate/tree/v2/doc
https://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md
https://github.com/nfcgate/nfcgate/tree/v2/doc/mode
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;ghi-chú-theo-cách-hiểu-của-bản-thân&#34;&gt;Ghi chú theo cách hiểu của bản thân&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lúc trước mình có tìm hiểu qua về &lt;strong&gt;Web PWA&lt;/strong&gt; (lúc đó có nghiên cứu về &lt;em&gt;bluetooth&lt;/em&gt; trên di động).&lt;/li&gt;
&lt;li&gt;Với các ứng dụng web &lt;code&gt;PWA&lt;/code&gt; thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/NFC_PWA/entire-process.webp&#34;
  alt=&#34;entire-process&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Đầu tiên đầu tiên là dẫn dụ &lt;em&gt;(có thể qua phishing)&lt;/em&gt; cài đặt một ứng dụng (có chứa malware) bằng đường link &lt;strong&gt;Web PWA&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Dùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native.&lt;/li&gt;
&lt;li&gt;Lúc này hacker dùng &lt;strong&gt;nfcgate&lt;/strong&gt; để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/NFC_PWA/nfc-replay.webp&#34;
  alt=&#34;nfc-replay&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Khi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân.&lt;/li&gt;
&lt;li&gt;Như trong &lt;a href=&#34;https://youtu.be/q69--5rdlmI&#34;&gt;Video Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/nfc_pwa/</guid>
      <pubDate>Tue, 27 Aug 2024 14:47:38 +0700</pubDate>
    </item>
    
    <item>
      <title>Kien_truc_may_tinh</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/kien_truc_may_tinh/</link>
      <description>&lt;h2 id=&#34;kiển-trúc-máy-tính&#34;&gt;Kiển trúc Máy tính&lt;/h2&gt;
&lt;h3 id=&#34;kiến-trúc-máy-tính---von-neumannhttpswwwdigikeycomenmakerblogs2024von-neumann-architecture&#34;&gt;&lt;a href=&#34;https://www.digikey.com/en/maker/blogs/2024/von-neumann-architecture&#34;&gt;Kiến trúc máy tính - Von-Neumann&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Được chia làm 3 phần chính:
&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;IO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cả 3 thành phần này đều giao tiếp với nhau thông qua &lt;strong&gt;bus&lt;/strong&gt; (gọi là &lt;code&gt;data bus&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kiến-trúc-harvard-sử-dụng-rộng-rãi-trong-các-bộ-vi-điều-khiển-và-dsp-digital-signal-processing&#34;&gt;kiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing)&lt;/h3&gt;
&lt;p&gt;Sự khác biệt giữa kiến trúc &lt;strong&gt;Harvard&lt;/strong&gt; vs &lt;strong&gt;Von-Neumann&lt;/strong&gt; đó chính là sự bố trí giữa &lt;strong&gt;CPU - Memory&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;kiến-trúc-chiphttpsinc42comglossarychip-architecture&#34;&gt;&lt;a href=&#34;https://inc42.com/glossary/chip-architecture/&#34;&gt;Kiến trúc chip&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;x86-architecture&#34;&gt;x86 Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Thường thấy trong các sản phẩm máy tính desktop hoặc laptop.&lt;/li&gt;
&lt;li&gt;Phổ biến là dòng chip của &lt;strong&gt;Intel&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;risc-architectures&#34;&gt;RISC Architectures&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MIPS Architecture: &lt;a href=&#34;https://www.cit.ctu.edu.vn/~dtnghi/cod/ch3.pdf&#34;&gt;KIẾN TRÚC BỘ LỆNH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ARM Architecture:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.csie.ntu.edu.tw/~cyy/courses/assembly/12fall/lectures/handouts/lec08_ARMarch.pdf&#34;&gt;Tài liệu ARMarch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.candtsolution.com/news_events-detail/what-is-the-difference-between-arm-and-x86/&#34;&gt;Một bài viết so sánh giữa ARM vs x86&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;data-bushttpswwwdigikeycomenmakertutorials2023what-is-serial-communication-and-how-does-it-compare-to-paralleltextwhats20the20difference20between20serialdata20that20can20be20transferred&#34;&gt;&lt;a href=&#34;https://www.digikey.com/en/maker/tutorials/2023/what-is-serial-communication-and-how-does-it-compare-to-parallel#:~:text=What&#39;s%20the%20Difference%20Between%20Serial,data%20that%20can%20be%20transferred&#34;&gt;Data Bus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Có 2 kiểu truyền dữ liệu là:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Nối tiếp (Serial)
Song song (Parallel)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Communicate.jpg&#34;
  alt=&#34;Communicate&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;song-song&#34;&gt;Song song&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dùng cho display (truyền hình ảnh), PCI, printer,&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nối-tiếp&#34;&gt;Nối tiếp:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,&amp;hellip;&lt;/li&gt;
&lt;li&gt;Giao tiếp nối tiếp thì chia làm 2 loại là:
&lt;ul&gt;
&lt;li&gt;Giao tiếp bất đồng bộ: UART, RS232, RS485&lt;/li&gt;
&lt;li&gt;Giao tiếp đồng bộ: SPI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/kien_truc_may_tinh/</guid>
      <pubDate>Tue, 27 Aug 2024 14:11:44 +0700</pubDate>
    </item>
    
    <item>
      <title>Radxa_X4</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/radxa_x4/</link>
      <description>&lt;h3 id=&#34;thông-tin&#34;&gt;Thông tin:&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://www.youtube.com/watch?v=F2atAHDOaIA
https://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040
https://github.com/geerlingguy/sbc-reviews/issues/48
https://radxa.com/products/x/x4/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img
  src=&#34;https://radxa.com/x/x4/banner_radxa_x4.webp&#34;
  alt=&#34;radxa_x4&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h1 id=&#34;giải-thích-theo-cách-hiểu-cá-nhân&#34;&gt;Giải thích theo cách hiểu cá nhân:&lt;/h1&gt;
&lt;p&gt;Cụm từ &lt;strong&gt;x86 with a side of Arm&lt;/strong&gt; trong trường hợp của &lt;code&gt;Radxa X4 SBC (Single Board Computer)&lt;/code&gt; mô tả việc &lt;strong&gt;tích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch&lt;/strong&gt;, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.&lt;/p&gt;
&lt;p&gt;Điều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.&lt;/p&gt;
&lt;p&gt;Giải thích cụ thể:&lt;/p&gt;
&lt;h3 id=&#34;intel-n100-và-kiến-trúc-x86&#34;&gt;Intel N100 và Kiến trúc x86:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Intel N100&lt;/strong&gt; đây là một bộ &lt;strong&gt;vi xử lý x86&lt;/strong&gt; của Intel, thuộc dòng Alder Lake-N, sử dụng &lt;code&gt;kiến trúc x86-64&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;X86&lt;/strong&gt; được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó.&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;Ứng dụng&lt;/mark&gt;: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;raspberry-pi-rp2040-và-kiến-trúc-arm&#34;&gt;Raspberry Pi RP2040 và Kiến trúc ARM:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RP2040&lt;/strong&gt;: Đây là một bộ &lt;strong&gt;vi điều khiển&lt;/strong&gt; dựa trên &lt;code&gt;kiến trúc ARM Cortex-M0+&lt;/code&gt; do Raspberry Pi Foundation phát triển.&lt;/li&gt;
&lt;li&gt;Đây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực.&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;Ứng dụng&lt;/mark&gt;: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tại-sao-sử-dụng-cả-x86-và-arm-trên-cùng-một-bo-mạch&#34;&gt;Tại sao sử dụng cả x86 và ARM trên cùng một bo mạch?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sử dụng tối ưu tài nguyên:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;x86&lt;/strong&gt;: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. &lt;br&gt;
&lt;strong&gt;ARM&lt;/strong&gt;: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Tăng tính linh hoạt và hiệu suất:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính&lt;/li&gt;
&lt;li&gt;Đồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn.&lt;/li&gt;
&lt;li&gt;Điều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Radxa X4 SBC mô tả việc &lt;strong&gt;kết hợp cả hai kiến trúc trong một thiết bị&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Sử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực.&lt;/li&gt;
&lt;li&gt;Đây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống.&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/radxa_x4/</guid>
      <pubDate>Tue, 27 Aug 2024 13:39:47 +0700</pubDate>
    </item>
    
    <item>
      <title>News</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/news/</link>
      <description>&lt;h3 id=&#34;changelog&#34;&gt;Changelog&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Ngày&lt;/th&gt;
&lt;th&gt;Mô tả&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10/4/2024&lt;/td&gt;
&lt;td&gt;Khởi tạo bài viết&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;26/8/2024&lt;/td&gt;
&lt;td&gt;Cập nhật một số trang blog và youtube về chủ đề Hardware Hacking&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Đây là danh sách các kênh mà mình cập nhật tin tức.&lt;/li&gt;
&lt;li&gt;Cũng như bổ sung kiến thức.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;danh-sách-các-kênh-tài-liệu-và-youtube-để-cập-nhật-kiến-thức&#34;&gt;Danh sách các kênh tài liệu và Youtube để cập nhật kiến thức.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Các trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ncsc-vnhttpstinnhiemmangvnnoi-bat&#34;&gt;&lt;a href=&#34;https://tinnhiemmang.vn/noi-bat&#34;&gt;NCSC VN&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;whitehathttpswhitehatvn&#34;&gt;&lt;a href=&#34;https://whitehat.vn/&#34;&gt;Whitehat&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Còn trang của nước ngoài thì gồm (trong đó có telegram):&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cyber-security-newshttpscybersecuritynewscom&#34;&gt;&lt;a href=&#34;https://cybersecuritynews.com/&#34;&gt;Cyber Security News&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;telegram-cyber-threat-intelligencehttpstmectinow&#34;&gt;&lt;a href=&#34;https://t.me/ctinow&#34;&gt;Telegram: Cyber Threat Intelligence&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;kênh-youtube&#34;&gt;Kênh youtube:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới.&lt;/li&gt;
&lt;li&gt;Các kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Top_Youtube_Channel_Hacking.jpg&#34;
  alt=&#34;Youtube&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ngày-2682024&#34;&gt;Ngày 26/8/2024&lt;/h2&gt;
&lt;p&gt;Một số trang blog và kênh Youtube về Hardware Hacking&lt;/p&gt;
&lt;h3 id=&#34;ncc-grouphttpsresearchnccgroupcomcategoryhardware-embedded-systems&#34;&gt;&lt;a href=&#34;https://research.nccgroup.com/category/hardware-embedded-systems/&#34;&gt;NCC Group&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;matt-brown-iot-pentester--hardware-security-researcher&#34;&gt;Matt Brown: IoT Pentester &amp;amp; Hardware Security Researcher&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://brownfinesecurity.com/blog/&#34;&gt;Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Youtube Channel: &lt;a href=&#34;https://www.youtube.com/@mattbrwn&#34;&gt;Matt Brown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hextreeiohttpsapphextreeio-một-nền-tảng-học-tập-về-hacking&#34;&gt;&lt;a href=&#34;https://app.hextree.io/&#34;&gt;hextree.io&lt;/a&gt;: Một nền tảng học tập về hacking.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Youtube Channel: &lt;a href=&#34;https://www.youtube.com/@LiveOverflow&#34;&gt;LiveOverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;iot-pentesting-guidehttpswwwiotpentestingguidecom&#34;&gt;&lt;a href=&#34;https://www.iotpentestingguide.com/&#34;&gt;IoT Pentesting Guide&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;iotsecurity101httpsv33rugithubioiotsecurity101&#34;&gt;&lt;a href=&#34;https://v33ru.github.io/IoTSecurity101/&#34;&gt;IoTSecurity101&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;gamehackinggghttpsgamehackinggg&#34;&gt;&lt;a href=&#34;https://gamehacking.gg/&#34;&gt;GameHacking.GG&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Trò chơi để luyện tập về &lt;strong&gt;reverse&lt;/strong&gt; và hacking game.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jhllc/Unity-Game&#34;&gt;Github Hướng dẫn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;synacktivhttpswwwsynacktivcomenour-publications&#34;&gt;&lt;a href=&#34;https://www.synacktiv.com/en/our-publications&#34;&gt;synacktiv&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.synacktiv.com/en/publications&#34;&gt;Publications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.synacktiv.com/en/advisories&#34;&gt;Advisories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.synacktiv.com/en/ressources&#34;&gt;Resources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/news/</guid>
      <pubDate>Mon, 26 Aug 2024 19:27:53 +0700</pubDate>
    </item>
    
    <item>
      <title>Protect_Camera</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/protect_camera/</link>
      <description>&lt;p&gt;Lướt lát trên Internet, vô tình &lt;strong&gt;lụm&lt;/strong&gt; được các bức ảnh &lt;em&gt;(được cắt ra trên một seminar nào đó)&lt;/em&gt; nói về các cách bảo vệ Camera.&lt;/p&gt;
&lt;p&gt;Sau khi đọc xong thì mình thấy các nội dung trong đây &lt;strong&gt;không chỉ dành riêng cho camera&lt;/strong&gt;, mà có thể áp dụng &lt;strong&gt;tư duy và kỹ thuật&lt;/strong&gt; này cả vào red-team và blue-team.&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/1.jpg&#34;
  alt=&#34;Hinh_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h2 id=&#34;kỹ-thuật-cho-red-team&#34;&gt;Kỹ thuật cho Red-Team&lt;/h2&gt;
&lt;h3 id=&#34;phishing-attacks&#34;&gt;Phishing Attacks&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/2.jpg&#34;
  alt=&#34;Hinh_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Đây là kỹ thuật rất phổ biến và hay được dùng.&lt;/li&gt;
&lt;li&gt;Đính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web &lt;strong&gt;fake&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Để rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sử-dụng-phần-mềm-độc-hại&#34;&gt;Sử dụng phần mềm độc hại&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/3.jpg&#34;
  alt=&#34;Hinh_3&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hacker tạo ra các con &lt;strong&gt;malware&lt;/strong&gt;, sau đó &lt;strong&gt;nhúng&lt;/strong&gt; nó vào các file như file ảnh, pdf,&amp;hellip;&lt;/li&gt;
&lt;li&gt;Khi nạn nhân nhấp vào thì sẽ có các &lt;strong&gt;tiến trình chạy ẩn&lt;/strong&gt; bên trong máy.&lt;/li&gt;
&lt;li&gt;Ví dụ như tạo ra &lt;strong&gt;backdoor&lt;/strong&gt; kết nối về &lt;strong&gt;máy chủ C2&lt;/strong&gt; của hacker.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/4.jpg&#34;
  alt=&#34;Hinh_4&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Câu hỏi là làm sao &lt;strong&gt;dẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm&lt;/strong&gt; &lt;br&gt;
Để làm được điều này thì một trong những kỹ thuật cần dùng là &lt;mark&gt;Phishing Attacks&lt;/mark&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;khai-thác-lỗ-hổng-phần-mềm&#34;&gt;Khai thác lỗ hổng phần mềm&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/5.jpg&#34;
  alt=&#34;Hinh_5&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Phần mềm&lt;/strong&gt; ở đây mang nghĩa cũng hơi rộng. Có thể là &lt;code&gt;web&lt;/code&gt;, &lt;code&gt;moblie&lt;/code&gt; hoặc một ứng dụng &lt;code&gt;desktop&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Chỉ cần phần mềm đó có &lt;strong&gt;lỗ hổng&lt;/strong&gt; và mình khai thác (ví dụ như &lt;mark&gt;Reverse Shell&lt;/mark&gt; hoặc &lt;strong&gt;RAT&lt;/strong&gt;) được thì cũng làm được khá nhiều trò.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fake-wifi&#34;&gt;Fake WIFI&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/6.jpg&#34;
  alt=&#34;Hinh_6&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker.&lt;/li&gt;
&lt;li&gt;Hacker sẽ fake một &lt;strong&gt;free wifi&lt;/strong&gt;, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet.&lt;/li&gt;
&lt;li&gt;Hoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tư-duy-blue-team&#34;&gt;Tư duy Blue-Team&lt;/h2&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/7.jpg&#34;
  alt=&#34;Hinh_7&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;sử-dụng-password-mạnh-mẽ&#34;&gt;Sử dụng Password mạnh mẽ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ít nhất &lt;strong&gt;8 ký tự&lt;/strong&gt;, có cả số lẫn chữ.&lt;/li&gt;
&lt;li&gt;Trong có phải bao gồm ít nhất phải có một &lt;strong&gt;ký tự đặc biệt&lt;/strong&gt;, và một ký tự &lt;strong&gt;chữ in hoa&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sử-dụng-2fa&#34;&gt;Sử dụng 2FA&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Xác thực &lt;strong&gt;OTP&lt;/strong&gt; (One Time Password).&lt;/li&gt;
&lt;li&gt;Có thể dùng app &lt;strong&gt;GG Authen&lt;/strong&gt; để xác thực 2 bước.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;phân-quyền&#34;&gt;Phân quyền&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cận thận với những app cài đặt với quyền Admin&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Phân quyền lại cho &lt;strong&gt;user&lt;/strong&gt;, được phép và không được phép làm điều gì.&lt;/li&gt;
&lt;li&gt;Kiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng &lt;strong&gt;không thể leo thang đặc quyền&lt;/strong&gt; được.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bảo-vệ-vật-lý&#34;&gt;Bảo vệ vật lý&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hiểu nôm na là sử dụng &lt;strong&gt;công cụ vật lý để xác thực&lt;/strong&gt;. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng.&lt;/li&gt;
&lt;li&gt;Ví dụ như sản phẩm &lt;a href=&#34;https://vincss.net/vi/product/khoa-xac-thuc-manh-vincss-fido2-touch-1-ket-noi-usb-type-a-ho-tro-xac-thuc-an-toan-khong-mat-khau-chuan-uaf-u2f-fido2-hang-chinh-hang/&#34;&gt;FIDO2® Touch 1&lt;/a&gt; của công ty &lt;strong&gt;VinCSS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;công-cụ-khác&#34;&gt;Công cụ khác&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/10.jpg&#34;
  alt=&#34;Hinh_10&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng.&lt;/li&gt;
&lt;li&gt;Sử dụng &lt;strong&gt;Firewall&lt;/strong&gt; &lt;em&gt;(cả phần cứng và phần mềm)&lt;/em&gt; để bảo vệ hạ tầng và ứng dụng của bạn.&lt;/li&gt;
&lt;li&gt;Sử dụng &lt;strong&gt;VPN&lt;/strong&gt; để bảo vệ thông tin của bạn.&lt;/li&gt;
&lt;li&gt;Sử dụng các công cụ &lt;strong&gt;diệt virus&lt;/strong&gt; để bảo vệ máy tính của bạn.&lt;/li&gt;
&lt;li&gt;Và đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack &lt;em&gt;(vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu)&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;human---con-người&#34;&gt;Human - Con người&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là &lt;strong&gt;con người&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Lỗ hổng này nằm trong &lt;strong&gt;tư duy&lt;/strong&gt;, &lt;strong&gt;nhận thức&lt;/strong&gt; về An toàn và Bảo mật thông tin.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Protect_Camera/8.jpg&#34;
  alt=&#34;Hinh_8&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/protect_camera/</guid>
      <pubDate>Sun, 18 Aug 2024 11:07:18 +0700</pubDate>
    </item>
    
    <item>
      <title>RE_Tool_BinaryNinjaFree</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/re_tool_binaryninjafree/</link>
      <description>&lt;p&gt;Một bài viết về &lt;a href=&#34;https://whitehat.vn/threads/re1-gioi-thieu-ve-reverse-engineering.875/&#34;&gt;RE (Reverse Engineering)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;công-cụ-ida---the-interactive-disassemblerhttpswhitehatvnthreadsre3-huong-dan-su-dung-ida913&#34;&gt;&lt;a href=&#34;https://whitehat.vn/threads/re3-huong-dan-su-dung-ida.913/&#34;&gt;Công cụ IDA - The Interactive Disassembler&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Công cụ này có &lt;a href=&#34;https://hex-rays.com/ida-free/#download&#34;&gt;bản free&lt;/a&gt; và hỗ trợ cài đặt trên nhiều nền tảng.&lt;/li&gt;
&lt;li&gt;Mình tải và cài đặt bản free cho Windows. Tuy nhiên thì:
&lt;ul&gt;
&lt;li&gt;Với bản free thì mình chỉ có thể dùng cho các file &lt;strong&gt;PE format&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Là dạng các file &lt;code&gt;.exe&lt;/code&gt; trên windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Với bản &lt;em&gt;free&lt;/em&gt; thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;công-cụ-online---decompiler-explorerhttpsdogboltorg&#34;&gt;Công cụ Online - &lt;a href=&#34;https://dogbolt.org/&#34;&gt;Decompiler Explorer&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;phần-mềm-binary-ninjahttpsbinaryninja&#34;&gt;Phần mềm &lt;a href=&#34;https://binary.ninja/&#34;&gt;Binary Ninja&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;video-youtube-tham-khảo&#34;&gt;Video youtube tham khảo:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=FBwRTWEzGN0&amp;amp;list=WL&amp;amp;index=11&#34;&gt;How to Crack Software (Reverse Engineering)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=tCcLhsTdFEw&#34;&gt;Learning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=-RaOeooSmug&#34;&gt;An Intro to Binary Ninja (Free) for Malware Analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=IdNFMIQ9roQ&#34;&gt;Binary Ninja: 4.1 Feature Stream!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;community-provided-binary-ninja-plugins-community-pluginshttpsgithubcomvector35community-plugins&#34;&gt;Community provided Binary Ninja plugins: &lt;a href=&#34;https://github.com/Vector35/community-plugins&#34;&gt;community-plugins&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;download-freehttpsbinaryninjafree&#34;&gt;&lt;a href=&#34;https://binary.ninja/free/&#34;&gt;Download Free&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đây là một công cụ mạnh mẽ, nhưng được sử dụng &lt;strong&gt;free&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Nếu so sánh thì phần mềm này &lt;strong&gt;ăn đứt IDA&lt;/strong&gt; về tính năng của bản free:
&lt;ul&gt;
&lt;li&gt;Supports x86, x86_64, and ARMv7 architectures.&lt;/li&gt;
&lt;li&gt;Hỗ trợ &lt;strong&gt;Disassemble&lt;/strong&gt; (phân tích), &lt;strong&gt;Pseudo C&lt;/strong&gt; (dịch ngược), &lt;strong&gt;HLIL&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mình đã tải và cài thử trên Windows, sau đó thử mở một &lt;strong&gt;file ELF&lt;/strong&gt; (file code rust-tracking)&lt;/li&gt;
&lt;li&gt;Mình có thể dùng với &lt;strong&gt;Strings&lt;/strong&gt;, &lt;strong&gt;Hex Editor&lt;/strong&gt;,&amp;hellip;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Công cụ quá mạnh mẽ&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Binary_Ninja_Free.png&#34;
  alt=&#34;Binary_Ninja_Free&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/re_tool_binaryninjafree/</guid>
      <pubDate>Fri, 16 Aug 2024 14:07:42 +0700</pubDate>
    </item>
    
    <item>
      <title>Read_Write_UART_STM32Fx</title>
      <link>https://vinhlin.github.io/posts/iot/software/read_write_uart_stm32fx/</link>
      <description>&lt;h2 id=&#34;code-test-read-write-data-trên-uart-của-chip-stm32f103&#34;&gt;Code Test Read Write Data trên UART của chip STM32F103&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]
#![feature(alloc_error_handler)]
//------------------------- Define Macro Alloc ------------------------------------
extern crate alloc;
use alloc_cortex_m::CortexMHeap;

// this is the allocator the application will use
#[global_allocator]
static ALLOCATOR: CortexMHeap = CortexMHeap::empty();

const HEAP_SIZE: usize = 1024; // in bytes

//-----------------------------------------------------------------------------------
use defmt::*;
use defmt_rtt as _;
use embassy_executor::Spawner;
use embassy_stm32::usart::{Config, Uart};
use embassy_stm32::{bind_interrupts, peripherals, usart};
use embassy_time::{with_timeout, Duration};
use panic_halt as _;

bind_interrupts!(struct Irqs {
    USART1 =&amp;gt; usart::InterruptHandler&amp;lt;peripherals::USART1&amp;gt;;
});

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    // Initialize the allocator BEFORE you use it
    unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) }

    info!(&amp;#34;Test UART&amp;#34;);
    let p = embassy_stm32::init(Default::default());

    let mut uart = Uart::new(
        p.USART1,
        p.PA10,
        p.PA9,
        Irqs,
        p.DMA1_CH4,
        p.DMA1_CH5,
        Config::default(),
    )
    .unwrap();

    uart.write(b&amp;#34;Start Test UART\r\n&amp;#34;).await.unwrap();
    let mut response_data = [0u8; 25]; // Buffer for one byte at a time.

    loop {
        match with_timeout(Duration::from_millis(100), uart.read_until_idle(&amp;amp;mut response_data)).await {
            Ok(_) =&amp;gt; {
                println!(&amp;#34;Data Test: {}&amp;#34;, response_data);

                if let Ok(message) = core::str::from_utf8(&amp;amp;response_data) {
                    println!(&amp;#34;DATA OK: {}&amp;#34;, message);
                }

                // clean buffer
                response_data.fill(0);
            }
            Err(_e) =&amp;gt; {
                // debug!(&amp;#34;Read UART Error&amp;#34;);
            }
        }
    }
}

// define what happens in an Out Of Memory (OOM) condition
#[alloc_error_handler]
fn alloc_error(_layout: core::alloc::Layout) -&amp;gt; ! {
    loop {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đoạn code này dùng &lt;code&gt;timeout&lt;/code&gt; với &lt;code&gt;read_until_idle&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Với &lt;code&gt;read_until_idle&lt;/code&gt; là để tự detect các ký tự xuống dòng như &lt;code&gt;\r\n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Kết quả test thành công:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Embassy/UART_Read_Write_Result.png&#34;
  alt=&#34;Read_Write&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/read_write_uart_stm32fx/</guid>
      <pubDate>Wed, 14 Aug 2024 19:17:29 +0700</pubDate>
    </item>
    
    <item>
      <title>Dump_Firmware_NOR_Flash</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/dump_firmware_nor_flash/</link>
      <description>&lt;p&gt;Đây là video Youtube nói về việc &lt;strong&gt;Dump Firmware&lt;/strong&gt; thiết bị: &lt;a href=&#34;https://www.youtube.com/watch?v=nruUuDalNR0&amp;amp;list=WL&amp;amp;index=7&#34;&gt;Extracting Firmware from Embedded Devices (SPI NOR Flash) ⚡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Một video hay, thú vị, giải thích và hướng dẫn cơ bản về &lt;strong&gt;Flash Memory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_1.png&#34;
  alt=&#34;Hinh_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loại &lt;strong&gt;NOR Flash&lt;/strong&gt; này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như &lt;strong&gt;tracking&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Còn &lt;strong&gt;NAND Flash&lt;/strong&gt; thì mình thấy trong các thiết bị như &lt;strong&gt;Camera hành trình&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Loại &lt;strong&gt;eMMC Flash&lt;/strong&gt; thì mình thấy trong &lt;strong&gt;máy tính nhúng&lt;/strong&gt; (như Pi).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nor-flash&#34;&gt;NOR Flash&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_2.png&#34;
  alt=&#34;Hinh_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trong video thì hướng dẫn và giải thích cơ bản về &lt;strong&gt;NOR Flash&lt;/strong&gt;, cũng như cách &lt;strong&gt;dump firmware&lt;/strong&gt; từ nó.&lt;/li&gt;
&lt;li&gt;Loại flash này dùng giao thức &lt;strong&gt;SPI&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_3.png&#34;
  alt=&#34;Hinh_3&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Làm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC.&lt;/li&gt;
&lt;li&gt;Nếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_4.png&#34;
  alt=&#34;Hinh_4&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;dump-firmware&#34;&gt;Dump Firmware&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Trong video tác giả sử dụng phần cứng &lt;a href=&#34;https://hydrabus.com/hydrabus-1-0-specifications/?v=e14da64a5617&#34;&gt;HydraBus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/HydraFW_Default_PinAssignment.jpg&#34;
  alt=&#34;HydraBus&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Đây là &lt;strong&gt;một dự án mã nguồn mở về phần cứng&lt;/strong&gt; (hardware open-source): &lt;a href=&#34;https://github.com/hydrabus/hydrabus&#34;&gt;hydrabus project&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Tài liệu về Cách sử dụng Hydrabus: &lt;a href=&#34;https://github.com/hydrabus/hydrafw/wiki/Getting-Started-with-HydraBus&#34;&gt;Getting Started with HydraBus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;flashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c &amp;#34;MX25L6406E/MX25L6408E
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;note&#34;&gt;Note&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Để hiểu rõ hơn thì cần xem lại video nhiều lần.&lt;/li&gt;
&lt;li&gt;Ngoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash &lt;a href=&#34;https://github.com/hydrabus/hydrafw/tree/master/contrib/hydra_spiflash_nor_dump&#34;&gt;&lt;code&gt;hydra_spiflash_nor_dump&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;một-số-hình-ảnh-khác-về-cách-dùng-cũng-như-công-cụ-bổ-trợ&#34;&gt;Một số hình ảnh khác về cách dùng cũng như công cụ bổ trợ:&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_5.png&#34;
  alt=&#34;Hinh_5&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_6.png&#34;
  alt=&#34;Hinh_6&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_7.png&#34;
  alt=&#34;Hinh_7&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Dump_Firmware_NOR_Flash/Hinh_8.png&#34;
  alt=&#34;Hinh_8&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/dump_firmware_nor_flash/</guid>
      <pubDate>Mon, 12 Aug 2024 16:44:23 +0700</pubDate>
    </item>
    
    <item>
      <title>Shared_Access_Embassy</title>
      <link>https://vinhlin.github.io/posts/iot/software/shared_access_embassy/</link>
      <description>&lt;p&gt;Như bài viết về &lt;a href=&#34;https://blog.vinhld-homelab.io.vn/posts/iot/software/lifetime_embassy/&#34;&gt;Lifetime_Embassy&lt;/a&gt; mình bị vướng chỗ ownership UART.&lt;/p&gt;
&lt;p&gt;Sau khi thăm hỏi &lt;strong&gt;ChatGPT&lt;/strong&gt; và đọc lại các tài liệu cũng như xem sample code thì biết rằng:
&lt;strong&gt;Rust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời &amp;ndash;&amp;gt; Gây lỗi cho chương trình&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Để giải quyết vấn đề này thì cần share quyền truy cập (&lt;strong&gt;Managing Shared Access&lt;/strong&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột &lt;strong&gt;quyền sở hữu&lt;/strong&gt; (&lt;em&gt;ownership&lt;/em&gt;) hoặc &lt;strong&gt;mượn&lt;/strong&gt; (&lt;em&gt;borrow&lt;/em&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Và để làm được điều này mình sẽ cần dùng đến &lt;strong&gt;Mutex&lt;/strong&gt;, &lt;strong&gt;RefCell&lt;/strong&gt; hoặc &lt;strong&gt;Arc&lt;/strong&gt;. &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;Uart&amp;gt;&amp;gt;&lt;/code&gt;
Tham khảo sample code về việc sử dụng Arc. &lt;a href=&#34;https://rust-classes.com/chapter_6_3&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;vấn-đề-tiếp-theo&#34;&gt;vấn đề tiếp theo&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Xui một cái nữa là &lt;strong&gt;Arc&lt;/strong&gt; không được khuyến nghị sử dụng trong &lt;strong&gt;embedded&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;và trong các example code có trong &lt;strong&gt;framwork embassy&lt;/strong&gt;, mình cũng không thấy ví dụ nào về dùng &lt;strong&gt;Arc&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Tiếp tục hỏi chatGPT về cách &lt;strong&gt;Shared Access trong framwork embassy&lt;/strong&gt;, cuối cùng cũng đã có kết quả.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;code-sample&#34;&gt;Code sample&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được.&lt;/li&gt;
&lt;li&gt;Đoạn code này dùng: &lt;strong&gt;Mutex&lt;/strong&gt;, &lt;strong&gt;NoopRawMutex&lt;/strong&gt; và &lt;strong&gt;RefCell&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use embassy_executor::Spawner;
use embassy_stm32::usart::Uart;
use embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1};
use embassy_stm32::gpio::{Output, Level, Speed};
use embassy_time::{Timer, Duration};
use embassy_sync::blocking_mutex::raw::NoopRawMutex;
use embassy_sync::mutex::Mutex;
use core::cell::RefCell;
use core::future::Future;
use core::sync::atomic::{AtomicBool, Ordering};

#[embassy_executor::task]
pub async fn test_command(
    uart: &amp;amp;&amp;#39;static Mutex&amp;lt;NoopRawMutex, RefCell&amp;lt;Uart&amp;lt;&amp;#39;static, USART1, DMA1_CH4, DMA1_CH5&amp;gt;&amp;gt;&amp;gt;,
    message: &amp;amp;&amp;#39;static str,
) {
    let mut count = 0;
    loop {
        count += 1;

        {
            let uart = uart.lock().await;
            let mut uart = uart.borrow_mut();
            uart.write(message.as_bytes()).await.unwrap();
            uart.write(b&amp;#34;\r\n&amp;#34;).await.unwrap();
        }

        if count == 10 {
            break;
        }

        Timer::after(Duration::from_millis(1000)).await;
    }
}

#[embassy_executor::task]
pub async fn main_task_rfid(
    rfid_uart: &amp;amp;&amp;#39;static mut Uart&amp;lt;&amp;#39;static, USART2, DMA1_CH7, DMA1_CH6&amp;gt;,
    debug_uart: &amp;amp;&amp;#39;static Mutex&amp;lt;NoopRawMutex, RefCell&amp;lt;Uart&amp;lt;&amp;#39;static, USART1, DMA1_CH4, DMA1_CH5&amp;gt;&amp;gt;&amp;gt;,
    mut power_pin_cr95hf: Output&amp;lt;&amp;#39;static, PA1&amp;gt;,
) {
    dbg_print(debug_uart, &amp;#34;Inside RFID Task&amp;#34;).await;
}

async fn dbg_print(
    uart: &amp;amp;&amp;#39;static Mutex&amp;lt;NoopRawMutex, RefCell&amp;lt;Uart&amp;lt;&amp;#39;static, USART1, DMA1_CH4, DMA1_CH5&amp;gt;&amp;gt;&amp;gt;,
    message: &amp;amp;str,
) {
    let uart = uart.lock().await;
    let mut uart = uart.borrow_mut();
    uart.write(message.as_bytes()).await.unwrap();
    uart.write(b&amp;#34;\r\n&amp;#34;).await.unwrap();
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_stm32::Peripherals::take().unwrap();

    let usart_rfid = Uart::new(
        p.USART2,
        p.PA3,
        p.PA2,
        IrqsUART2,
        p.DMA1_CH7,
        p.DMA1_CH6,
        config_rfid,
    )
    .unwrap();

    let usart_debug = Uart::new(
        p.USART1,
        p.PA10,
        p.PA9,
        IrqsUART1,
        p.DMA1_CH4,
        p.DMA1_CH5,
        config_debug,
    )
    .unwrap();

    // Convert usart_rfid and usart_debug to &amp;#39;static lifetimes
    let usart_rfid_static = Box::leak(Box::new(usart_rfid));
    let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug))));


    // Create the ctr_rfid object
    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);
    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));

    // Async task for test command
    spawner
        .spawn(test_command(usart_debug_static, &amp;#34;Test&amp;#34;))
        .unwrap();

    // Async task for RFID
    spawner
        .spawn(main_task_rfid(
            usart_rfid_static,
            usart_debug_static,
            ctr_rfid_static,
        ))
        .unwrap();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;đã-khắc-phục-và-chạy-code-được-thành-công&#34;&gt;&lt;strong&gt;Đã khắc phục và chạy code được thành công&lt;/strong&gt;.&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Embassy/Result_Shared_Access_UART.png&#34;
  alt=&#34;Result_Shared_Access_UART&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/shared_access_embassy/</guid>
      <pubDate>Sat, 10 Aug 2024 11:18:41 +0700</pubDate>
    </item>
    
    <item>
      <title>Lifetime_Embassy</title>
      <link>https://vinhlin.github.io/posts/iot/software/lifetime_embassy/</link>
      <description>&lt;p&gt;Trong quá trình code Rust cho RFID, khi sử dụng đến phần &lt;strong&gt;UART&lt;/strong&gt; và dùng đến &lt;code&gt;#[embassy_executor::task]&lt;/code&gt; thì bị báo lỗi về &lt;strong&gt;Lifetime&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lỗi lifetime về uart. Hiều nôm na thì rust đang báo là &lt;strong&gt;thời gian sống&lt;/strong&gt; (thời gian tồn tại, hay &lt;strong&gt;vòng đời&lt;/strong&gt;) của &lt;strong&gt;UART&lt;/strong&gt; quá ngắn để thực hiện các tiến trình trong task.&lt;/p&gt;
&lt;p&gt;Xem thêm video &lt;a href=&#34;https://www.youtube.com/watch?v=juIINGuZyBc&#34;&gt;Rust Lifetimes Finally Explained!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Để khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: &lt;code&gt;&#39;static&lt;/code&gt;, &lt;code&gt;&#39;a&lt;/code&gt;, &lt;code&gt;&#39;b&lt;/code&gt;,&amp;hellip;&lt;/p&gt;
&lt;p&gt;Và để khắc phục triệt để mình phải sử dụng thêm &lt;a href=&#34;https://doc.rust-lang.org/rust-by-example/std/box.html&#34;&gt;Box&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;giới-thiệu-sơ-về-box&#34;&gt;Giới thiệu sơ về Box&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;All values in Rust are stack allocated by default. Values can be &lt;em&gt;boxed&lt;/em&gt; (allocated on the heap) by creating a Box&lt;T&gt;.
A &lt;strong&gt;box is a smart pointer&lt;/strong&gt; to a &lt;strong&gt;heap allocated value of type T&lt;/strong&gt;.
When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Embassy/Box_Rust.png&#34;
  alt=&#34;Box&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Để chuyển giá trị của Box thành một con trỏ với lifetime là &lt;code&gt;&#39;static&lt;/code&gt;. Mình sẽ dùng đến cấu trúc &lt;code&gt;Box::leak&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;code-mô-tả&#34;&gt;Code mô tả:&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#[embassy_executor::task]
pub async fn main_task_rfid(
    rfid_uart: &amp;amp;&amp;#39;static mut Uart&amp;lt;&amp;#39;static, USART2, DMA1_CH7, DMA1_CH6&amp;gt;,
    debug_uart: &amp;amp;&amp;#39;static mut Uart&amp;lt;&amp;#39;static, USART1, DMA1_CH4, DMA1_CH5&amp;gt;,
    power_pin_cr95hf: &amp;amp;&amp;#39;static mut Output&amp;lt;&amp;#39;_, PA1&amp;gt;,
) {
    // Use debug_uart here
    dbg_print(debug_uart, &amp;#34;Inside RFID Task&amp;#34;).await;
}


#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_stm32::Peripherals::take().unwrap();

    let mut usart_debug = Uart::new(
        p.USART1,
        p.PA10,
        p.PA9,
        IrqsUART1,
        p.DMA1_CH4,
        p.DMA1_CH5,
        config_debug,
    ).unwrap();

    dbg_print(&amp;amp;mut usart_debug, &amp;#34;RFID CR95&amp;#34;).await;

    //------------------ RFID Task ---------------------
    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);

    // Convert references to &amp;#39;static by leaking the values
    let usart_rfid_static = Box::leak(Box::new(usart_rfid));
    let usart_debug_static = Box::leak(Box::new(usart_debug));
    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));

    // Async task RFID
    spawner
        .spawn(task_rfid::main_task_rfid(
            usart_rfid_static,
            usart_debug_static,
            ctr_rfid_static,
        ))
        .unwrap();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Khi đã sử dụng &lt;code&gt;usart_debug&lt;/code&gt; cho &lt;strong&gt;Box::leak&lt;/strong&gt; (và được dùng cho &lt;strong&gt;task RFID&lt;/strong&gt;) thì mình không còn dùng được &lt;code&gt;usart_debug&lt;/code&gt; sau nữa.&lt;/p&gt;
&lt;p&gt;Vì lúc này bị dính đến &lt;strong&gt;ownership&lt;/strong&gt;.&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/lifetime_embassy/</guid>
      <pubDate>Fri, 09 Aug 2024 18:08:32 +0700</pubDate>
    </item>
    
    <item>
      <title>Results_Rust</title>
      <link>https://vinhlin.github.io/posts/iot/software/rust-lang/results_rust/</link>
      <description>&lt;p&gt;Một trong các ưu điểm của ngôn ngữ bậc cao là việc &lt;strong&gt;Handle Error&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Và trong Rust thì chính là cách sử dụng &lt;strong&gt;Result&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Result/Hinh_1.png&#34;
  alt=&#34;Hinh_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Mình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.&lt;/p&gt;
&lt;h3 id=&#34;video-youtube-a-simpler-way-to-see-resultshttpswwwyoutubecomwatchvs5s2ed5t-dc&#34;&gt;Video Youtube: &lt;a href=&#34;https://www.youtube.com/watch?v=s5S2Ed5T-dc&#34;&gt;A Simpler Way to See Results&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;result-vs-optionhttpsdhghomongithubioeasy_rustchapter_31html&#34;&gt;&lt;a href=&#34;https://dhghomon.github.io/easy_rust/Chapter_31.html&#34;&gt;Result vs Option&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Result/Hinh_2.png&#34;
  alt=&#34;Hinh_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Nói cách dễ hiểu thì:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Option&lt;/strong&gt; dùng khi mình chỉ muốn biểu đạt &lt;strong&gt;có giá trị&lt;/strong&gt; hoặc &lt;strong&gt;không có giá trị&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result&lt;/strong&gt; dùng khi mình muốn biểu đạt là có &lt;strong&gt;giá trị đúng&lt;/strong&gt; và biết được &lt;strong&gt;thông tin lỗi&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Result/Hinh_3.png&#34;
  alt=&#34;Hinh_3&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;ví-dụ-về-việc-trả-về-một-giá-trị-và-handle-error&#34;&gt;Ví dụ về việc trả về &lt;strong&gt;một giá trị&lt;/strong&gt; và handle-error&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Result/Hinh_4.png&#34;
  alt=&#34;Hinh_4&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;ví-dụ-về-việc-trả-về-hai-giá-trị-và-handle-error&#34;&gt;Ví dụ về việc trả về &lt;strong&gt;hai giá trị&lt;/strong&gt; và handle-error&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Nếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code.&lt;/li&gt;
&lt;li&gt;Tuy nhiên nếu dùng thêm &lt;a href=&#34;https://dhghomon.github.io/easy_rust/Chapter_33.html&#34;&gt;operator&lt;/a&gt; thì cách biểu đạt sẽ đơn giản hơn.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Result/Hinh_5.png&#34;
  alt=&#34;Hinh_5&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Rust-lang/Result/Hinh_6.png&#34;
  alt=&#34;Hinh_6&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/rust-lang/results_rust/</guid>
      <pubDate>Thu, 08 Aug 2024 18:07:12 +0700</pubDate>
    </item>
    
    <item>
      <title>UART_Embassy</title>
      <link>https://vinhlin.github.io/posts/iot/software/uart_embassy/</link>
      <description>&lt;h2 id=&#34;giới-thiệu-về-embassyhttpsembassydev&#34;&gt;Giới thiệu về &lt;a href=&#34;https://embassy.dev/&#34;&gt;Embassy&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Trong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embassy&lt;/strong&gt; một framework lập trình theo kiểu &lt;strong&gt;bất đồng bộ (async)&lt;/strong&gt;, dễ tiếp cận hơn việc setup một &lt;strong&gt;RTOS&lt;/strong&gt; cho MCU.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Embassy/Concurrency_Parallelism.jpg&#34;
  alt=&#34;Concurrency_Parallelism&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;h3 id=&#34;async-embassy&#34;&gt;Async Embassy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dựa trên một file tài liệu mà mình tình cờ có được &lt;a href=&#34;https://vinhlin.github.io/docs/embassy/B4-async-embedded.pdf&#34;&gt;async-embedded&lt;/a&gt; thì &lt;strong&gt;Async&lt;/strong&gt; là một cách tiếp cận về việc &lt;strong&gt;Xử lý đồng thời (Concurrency)&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hơn nữa dựa trên &lt;a href=&#34;https://github.com/embassy-rs/embassy&#34;&gt;Github Embassy&lt;/a&gt; thì framework này hỗ trợ kha khá dòng chip:
&lt;ul&gt;
&lt;li&gt;Dòng nRF: &lt;a href=&#34;https://docs.embassy.dev/embassy-nrf/git/nrf51/index.html&#34;&gt;embassy_nrf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dòng STM32: &lt;a href=&#34;https://docs.embassy.dev/embassy-stm32/git/stm32f730i8/index.html&#34;&gt;embassy-stm32&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dòng RP2040: &lt;a href=&#34;https://docs.embassy.dev/embassy-rp/git/rp2040/index.html&#34;&gt;embassy_rp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dòng ESP32: &lt;a href=&#34;https://github.com/esp-rs&#34;&gt;esp-rs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Nhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;uart&#34;&gt;UART&lt;/h1&gt;
&lt;p&gt;Trong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.&lt;/p&gt;
&lt;h2 id=&#34;read&#34;&gt;Read&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Trong STM32 phần &lt;strong&gt;Read UART&lt;/strong&gt; có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng.
&lt;ul&gt;
&lt;li&gt;blocking_read&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;read_until_idle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;func-blocking_read&#34;&gt;Func &lt;code&gt;blocking_read&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Function này sẽ mình đọc đầy đủ dữ liệu.&lt;/li&gt;
&lt;li&gt;Ban đầu mình có test thử giữa &lt;code&gt;blocking_read&lt;/code&gt; với &lt;code&gt;read&lt;/code&gt;, thì mình &lt;strong&gt;đọc&lt;/strong&gt; được dữ liệu với &lt;code&gt;blocking_read&lt;/code&gt;, còn với &lt;code&gt;read&lt;/code&gt; thì không.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;func-read&#34;&gt;Func &lt;code&gt;read&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mình sẽ thường dùng function &lt;strong&gt;read&lt;/strong&gt; này kết hợp với &lt;strong&gt;timeout&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Tức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra.&lt;/li&gt;
&lt;li&gt;Nhờ cách này mà mình tránh được việc bị &lt;strong&gt;treo&lt;/strong&gt; chương trình.&lt;/li&gt;
&lt;li&gt;Đây là một đoạn code mẫu:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// health_check_cr95hf
// True: CR95HF OK
// Flase: CR95HF not reponse -&amp;gt; Maybe lost connect with CR95HF
async fn health_check_cr95hf(
    rfid_uart: &amp;amp;mut Uart&amp;lt;&amp;#39;static, USART2, DMA1_CH7, DMA1_CH6&amp;gt;,
    debug_uart: &amp;amp;mut Uart&amp;lt;&amp;#39;static, USART1, DMA1_CH4, DMA1_CH5&amp;gt;,
) -&amp;gt; bool {
    let echo_command_code: &amp;amp;[u8];
    echo_command_code = cr95hf::cr95hf_echo_command();
    dbg_print(debug_uart, &amp;#34;Health Check CR95HF&amp;#34;).await;

    // Buffer data reponse from CR95HF
    let mut response_code = [0u8; 1];
    let _size_data: usize = 1;

    for _i in 1..3 {
        // Send command
        rfid_uart.blocking_write(&amp;amp;echo_command_code).unwrap();

        // Read reponse from CR95HF
        match with_timeout(
            Duration::from_millis(30),
            rfid_uart.read(&amp;amp;mut response_code),
        )
        .await
        {
            // match rfid_uart.blocking_read(&amp;amp;mut response_code) {
            Ok(_size_data) =&amp;gt; {
                // let _ = debug_uart.blocking_write(&amp;amp;response_code);
                // Data reponse from CR95 OK
                if response_code == echo_command_code {
                    return true;
                } else {
                    return false;
                }
            }
            Err(_e) =&amp;gt; {
                dbg_print(debug_uart, &amp;#34;Read UART Error - Func health_check_cr95hf&amp;#34;).await;
                // delay 10ms
                Timer::after(Duration::from_millis(10)).await;
                continue;
            }
        }
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;func-read_until_idle&#34;&gt;Func &lt;code&gt;read_until_idle&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Để hiểu hơn về &lt;strong&gt;IDLE UART&lt;/strong&gt;, mình đã tham khảo tài liệu:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette
https://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Tức là với func này, nó sẽ chia ra thành từng &lt;strong&gt;block&lt;/strong&gt; để đọc dữ liệu.&lt;/li&gt;
&lt;li&gt;Dưới đây là đoạn code với chức năng là: gửi command sau đó đọc &lt;strong&gt;4 bytes&lt;/strong&gt; dữ liệu, tuy nhiên chỉ lấy &lt;strong&gt;2 bytes&lt;/strong&gt; đầu để xử lý dữ liệu&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// no_tag_cr95hf: Check no_tag
// Return true: if not detectd tag card
async fn no_tag_cr95hf(
    rfid_uart: &amp;amp;mut Uart&amp;lt;&amp;#39;static, USART2, DMA1_CH7, DMA1_CH6&amp;gt;,
    debug_uart: &amp;amp;mut Uart&amp;lt;&amp;#39;static, USART1, DMA1_CH4, DMA1_CH5&amp;gt;,
) -&amp;gt; bool {
    // First: Setup Protocol ISO15693
    setup_protocol_iso15693(rfid_uart).await;

    // Second: Read data and check errors code
    // Define the initial byte array
    let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00];

    for _i in 1..3 {
        // Send command
        rfid_uart.blocking_write(&amp;amp;sendrecv_command).unwrap();

        // Buffer data reponse from CR95HF
        let mut response_data = [0u8; 4];
        let _size_data: usize = 2;

        // Read reponse from CR95HF
        match rfid_uart.read_until_idle(&amp;amp;mut response_data).await {
            Ok(_size_data) =&amp;gt; {
                // let is_no_tag = cr95hf::errors_tag_code(&amp;amp;response_data.clone());
                let is_no_tag = cr95hf::errors_tag_code(&amp;amp;response_data);
                // let _ = debug_uart.blocking_write(&amp;amp;response_data);
                // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes());
                if is_no_tag == true {
                    dbg_print(debug_uart, &amp;#34;NO TAG CARD&amp;#34;).await;
                    return true;
                } else {
                    return false;
                }
            }
            Err(_e) =&amp;gt; {
                // delay 10ms
                Timer::after(Duration::from_millis(10)).await;
            }
        }
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/uart_embassy/</guid>
      <pubDate>Wed, 07 Aug 2024 13:23:30 +0700</pubDate>
    </item>
    
    <item>
      <title>IoT_Security_JD</title>
      <link>https://vinhlin.github.io/posts/others/iot_security_jd/</link>
      <description>&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/IoT_Security.jpg&#34;
  alt=&#34;IoT_Security&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Bữa lang thang trên diễn đàn &lt;strong&gt;CISSP trên facebook&lt;/strong&gt;, mình thấy một &lt;strong&gt;JD về Security cho IoT&lt;/strong&gt;. Mình thấy JD này đầy đủ và cụ thể:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị &lt;strong&gt;UAV, drone, IoT, satellite,&amp;hellip;&lt;/strong&gt; &lt;/br&gt;
Nếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn: &lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Có kỹ năng &lt;strong&gt;dịch ngược phần mềm (Reverse Engineering)&lt;/strong&gt; và tìm kiếm lỗ hổng từ file thực thi đó. &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Thông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware. &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Thông thạo kỹ năng &lt;strong&gt;khai thác lỗ hổng phần mềm&lt;/strong&gt;, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v&amp;hellip;. &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Có kỹ năng &lt;strong&gt;Source code review + Pentest blackbox&lt;/strong&gt; các các thiết bị IoT &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Đam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới &lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm: &lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v&amp;hellip; trước khi hòa mạng vào hệ thống mạng băng rộng VNPT &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Nghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …) &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Nghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, … &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Nghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile &lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT: &lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gia nhập VCI, bạn sẽ đóng vai chính cho các dự án &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Làm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh &lt;/br&gt;&lt;/li&gt;
&lt;li&gt;Chế độ đãi ngộ hấp dẫn và review lương theo năng lực &lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân &lt;/br&gt;
Nếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé! &lt;/br&gt;
Hồ sơ ứng viên xin gửi về địa chỉ email: &lt;a href=&#34;mailto:security@vnpt.vn&#34;&gt;security@vnpt.vn&lt;/a&gt; &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;reverse&#34;&gt;Reverse&lt;/h2&gt;
&lt;p&gt;Đây là kỹ năng mà mình cần rèn luyện và trau dồi.&lt;/p&gt;
&lt;h3 id=&#34;dịch-ngược-phần-cứng&#34;&gt;Dịch ngược Phần cứng&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Việc &lt;strong&gt;bóc tách chip nhớ&lt;/strong&gt; thì sẽ có 2 mục tiêu chính:
&lt;ul&gt;
&lt;li&gt;Thứ 1: Đọc các dữ liệu được lưu trữ không Flash&lt;/li&gt;
&lt;li&gt;Thứ 2: Dump Firmware&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại.&lt;/li&gt;
&lt;li&gt;Việc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;khai-thác-lỗ-hổng&#34;&gt;Khai thác lỗ hổng&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Khi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn.&lt;/li&gt;
&lt;li&gt;Trong JD có các thuật ngữ mà mình không hiểu, ngoại trừ &lt;strong&gt;command injection&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cái này phức tạp vãi chưởng luôn.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pentest-blackbox&#34;&gt;Pentest blackbox&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Các thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là &lt;strong&gt;Pentest Web&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Hoặc có thể là lấy thông tin từ &lt;strong&gt;Debug UART&lt;/strong&gt;, tìm kiếm IP Gateway Server, FTP Server,&amp;hellip; =&amp;gt; Pentest Web.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kiểm-định-đánh-giá-an-toàn-bảo-mật&#34;&gt;Kiểm định, đánh giá an toàn bảo mật&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Các giao thức truyền thông IoT thì mình biết, nhưng mà để &lt;strong&gt;đánh giá ATTT&lt;/strong&gt; thì mình chưa rõ.&lt;/li&gt;
&lt;li&gt;Không lẻ lấy theo tiêu chuẩn &lt;a href=&#34;https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/nis2/&#34;&gt;NIS2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Nhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.&lt;/p&gt;
&lt;p&gt;Biết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là &lt;strong&gt;điều kiện thực hành&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Mình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.&lt;/p&gt;
&lt;p&gt;Vì trong IoT còn có những mảng nhỏ khác như:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Design (vẽ Schematic, PCB)
Code nhúng Firmware cho MCU
Code nhúng cho Linux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/others/iot_security_jd/</guid>
      <pubDate>Sun, 04 Aug 2024 11:04:52 +0700</pubDate>
    </item>
    
    <item>
      <title>Docklight</title>
      <link>https://vinhlin.github.io/posts/iot/software/docklight/</link>
      <description>&lt;ul&gt;
&lt;li&gt;Bữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn.&lt;/li&gt;
&lt;li&gt;Gửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết.&lt;/li&gt;
&lt;li&gt;Sang tuần mới có board mạch hoàn chỉnh.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để &lt;strong&gt;giả lập data Serial&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Công cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án &lt;strong&gt;Công lạnh&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;tool-giả-lập-data-cho-serial&#34;&gt;Tool giả lập data cho Serial&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code.&lt;/li&gt;
&lt;li&gt;Những thông tin, data, command id,&amp;hellip; tất cả mình đã có hết.&lt;/li&gt;
&lt;li&gt;Lúc này mình sẽ dùng &lt;strong&gt;Docklight&lt;/strong&gt; để &lt;strong&gt;giả lập data&lt;/strong&gt; (tương tự như cách CR95 phản hồi command từ MCU).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;docklight&#34;&gt;Docklight&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đây là công cụ có bản quyền, phải trả phí.&lt;/li&gt;
&lt;li&gt;Tuy nhiên để dùng &lt;strong&gt;free&lt;/strong&gt; thì mình cần tải phiên bản &lt;strong&gt;Docklight 2.2&lt;/strong&gt; trở xuống.&lt;/li&gt;
&lt;li&gt;Download &lt;a href=&#34;https://docklight.de/downloads/&#34;&gt;Docklight 2.2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Download Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Và đây là &lt;strong&gt;Key number&lt;/strong&gt; để kích hoạt:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;KEY NUMBER
010111323344556
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img
  src=&#34;https://docklight.de/wp-content/uploads/2018/09/app3_docklight_screenshot_simulator_based_on_log_data.png&#34;
  alt=&#34;docklight&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/docklight/</guid>
      <pubDate>Sat, 03 Aug 2024 13:24:20 +0700</pubDate>
    </item>
    
    <item>
      <title>ParamSpider</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/paramspider/</link>
      <description>&lt;p&gt;Bữa có coi video trên Youtube có tựa đề: &lt;a href=&#34;https://www.youtube.com/watch?v=JHRzVEvpHSM&amp;amp;list=WL&amp;amp;index=2&#34;&gt;5 Hacking Tools I Can&amp;rsquo;t Live Without&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Trong đó có đề cập đến các công cụ dành cho việc Pentest Web:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. DevTools
2. BURP Suite
3. Containers
4. FFUF
5. ParamSpider
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.&lt;/p&gt;
&lt;h3 id=&#34;github-paramspiderhttpsgithubcomdevanshbathamparamspider&#34;&gt;&lt;a href=&#34;https://github.com/devanshbatham/ParamSpider&#34;&gt;Github ParamSpider&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dựa vào thông tin trên github công cụ giống như &lt;a href=&#34;https://web.archive.org/&#34;&gt;Wayback Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian.&lt;/li&gt;
&lt;li&gt;Công cụ này cũng ổn áp &amp;ldquo;phết&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://raw.githubusercontent.com/devanshbatham/ParamSpider/master/static/paramspider.png&#34;
  alt=&#34;paramspider&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/paramspider/</guid>
      <pubDate>Sat, 03 Aug 2024 12:24:25 +0700</pubDate>
    </item>
    
    <item>
      <title>Research_CR95</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/research_cr95/</link>
      <description>&lt;h3 id=&#34;giới-thiệu&#34;&gt;Giới thiệu:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CR95&lt;/strong&gt; là dòng chip dùng để đọc &lt;strong&gt;RFID&lt;/strong&gt; và &lt;strong&gt;NFC&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Các thiết bị Giám sát hành trình theo &lt;strong&gt;QCVN31&lt;/strong&gt; đều phải có bộ RFID, để đọc thẻ tài xế.&lt;/li&gt;
&lt;li&gt;Công ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại &lt;strong&gt;IC CR95&lt;/strong&gt; (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;yêu-cầu&#34;&gt;Yêu cầu:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Nghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART.&lt;/li&gt;
&lt;li&gt;Dùng ngôn ngữ lập trình Rust để viết Firmware.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;research&#34;&gt;Research&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là &lt;strong&gt;SPI&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Mình cần xem lại &lt;a href=&#34;https://www.st.com/resource/en/datasheet/cr95hf.pdf&#34;&gt;datasheet của CR95&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Về phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;may-mắn-thay&#34;&gt;May mắn thay&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Lúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source code&lt;/strong&gt; anh này được viết &lt;strong&gt;bằng C&lt;/strong&gt;, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một &lt;a href=&#34;http://www.tme.vn/product.aspx?id=2095#page=pro_info&#34;&gt;board phần cứng CR95 khác&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Research_CR95/CR95HF-BRD.jpg&#34;
  alt=&#34;CR95HF-BRD&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Echo: 0x55
Info: 0x0100
Set Protocol: 0x02020109
SendRecv: 0x0403022000
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Tới đây thì mình &lt;strong&gt;bó tay&lt;/strong&gt;, không hiều làm sao mà có thể đọc được &lt;strong&gt;thông tin ID, tên tài xế, giấy phép lái xe&lt;/strong&gt; của thẻ RFID&lt;/li&gt;
&lt;li&gt;Và mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,&amp;hellip;&lt;/li&gt;
&lt;li&gt;Nhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;đọc-tín-hiệu-xung&#34;&gt;Đọc tín hiệu xung&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Khi gần như bế tắc thì anh Sơn đã gợi ý là &lt;strong&gt;đọc tín hiệu xung&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Và mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng &lt;a href=&#34;https://hshop.vn/products/mach-usb-saleae-8ch-24mhz-logic-analyzer&#34;&gt;board logic analyzer&lt;/a&gt;
&lt;img
  src=&#34;https://product.hstatic.net/1000069225/product/c583f4e0-da4c-4abe-9e29-16844f44de69_1_201_a_9a3822254fa44d8e9e2fb043ec157eaf_1024x1024.jpg&#34;
  alt=&#34;logic analyzer&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/li&gt;
&lt;li&gt;Board này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại &lt;a href=&#34;https://www.saleae.com/pages/downloads&#34;&gt;phần mềm hỗ trợ&lt;/a&gt; cho board này lại cực xịn (đánh giá cá nhân).&lt;/li&gt;
&lt;li&gt;Từ &lt;strong&gt;hình 1&lt;/strong&gt; và &lt;strong&gt;hình 2&lt;/strong&gt; là mình biết rằng những lệnh command ban đầu của mình đã đúng.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Research_CR95/Hinh_1.png&#34;
  alt=&#34;CR95-Hinh_1&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Research_CR95/Hinh_2.png&#34;
  alt=&#34;CR95-Hinh_2&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Research_CR95/Hinh_3.png&#34;
  alt=&#34;CR95-Hinh_3&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi &lt;strong&gt;SendRecv&lt;/strong&gt; thì nó chỉ đọc được số lượng &lt;strong&gt;byte&lt;/strong&gt; nhất định, nên để đọc được hết thông tin thì mình cần gửi:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0x0403022000
0x0403022001
0x0403022002
0x0403022003
0x0403022004
.
.
.
.
.
.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Cứ thế gửi cho đến khi đọc hết thông tin.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nhiệm-vụ-tiếp-theo&#34;&gt;Nhiệm vụ tiếp theo&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Bây giờ đã rõ hết cấu trúc bản tin.&lt;/li&gt;
&lt;li&gt;Nhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết.&lt;/li&gt;
&lt;li&gt;Parse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;suy-nghĩ&#34;&gt;Suy nghĩ:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lúc trước mình có xem một video về các công cụ hardware hacking dành cho việc &lt;strong&gt;Firmware Reverse&lt;/strong&gt;, thì &lt;strong&gt;Logic Analyzer&lt;/strong&gt; là một trong các công cụ đó.&lt;/li&gt;
&lt;li&gt;Mình thấy một &lt;strong&gt;Hardware Engineer&lt;/strong&gt; công việc cũng giống như một &lt;strong&gt;IoT Hacker&lt;/strong&gt;, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế.&lt;/li&gt;
&lt;li&gt;Chỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,&amp;hellip;&lt;/li&gt;
&lt;li&gt;Mình có thể mường tưởng ra cách Trung Quốc họ copy:
&lt;ul&gt;
&lt;li&gt;Mua sản phẩm&lt;/li&gt;
&lt;li&gt;Kiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng)&lt;/li&gt;
&lt;li&gt;Dịch ngược bằng cách: bắt tín hiệu xung, dump firmware.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Đến bây giờ mình mới có thể hiểu. =]]&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/research_cr95/</guid>
      <pubDate>Sun, 28 Jul 2024 13:12:25 +0700</pubDate>
    </item>
    
    <item>
      <title>Tails_OS</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/tails_os/</link>
      <description>&lt;h3 id=&#34;ẩn-danh---anonymous&#34;&gt;Ẩn danh - Anonymous&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Mình có đọc hết cuốn &lt;a href=&#34;https://tiki.vn/nghe-thuat-an-minh-p8845822.html&#34;&gt;Nghệ Thuật Ẩn Mình&lt;/a&gt;, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay.
&lt;img
  src=&#34;https://salt.tikicdn.com/cache/750x750/ts/product/47/4b/45/6386ab1926fd23aad2b93d8f83429769.jpg.webp&#34;
  alt=&#34;Nghệ Thuật Ẩn Mình&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dùng sóng di động (nói chung là &lt;strong&gt;dùng sim4G&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Sử dụng VPN, Proxy.&lt;/li&gt;
&lt;li&gt;Sử dụng &lt;a href=&#34;https://www.torproject.org/download/&#34;&gt;Tor Browser&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hôm nay khi xem video trên Youtube, thì mình biết đến &lt;a href=&#34;https://tails.net/&#34;&gt;Tails&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=U2-JPqrALsA&amp;amp;list=WL&amp;amp;index=2&#34;&gt;How To Access the DARK WEB in 2024 (3 Levels)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gO9fTnMxwYw&#34;&gt;Tails Linux USB with Persistence (Be invisible online in 7 minutes)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tails-os&#34;&gt;Tails OS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tails&lt;/strong&gt; tương tự như việc mình chạy một &lt;strong&gt;hệ điều hành&lt;/strong&gt; song song vậy (và ở đây là trên USB).&lt;/li&gt;
&lt;li&gt;Bản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như &lt;strong&gt;Tor Browser&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Như mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,&amp;hellip;&lt;/li&gt;
&lt;li&gt;Ngay cả khi mình tắt máy, thì những thông tin đó vẫn được &lt;strong&gt;lưu trữ trên RAM&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Và đây là lúc &lt;strong&gt;Tails&lt;/strong&gt; phát huy ưu điểm nổi bật chính là &lt;strong&gt;không lưu trữ bất kỳ thứ gì sau khi tắt máy&lt;/strong&gt;. Tức là những thao tác trên máy, thông tin hoặc vô tình &lt;strong&gt;bị dính malware&lt;/strong&gt; đều sẽ biến mất hết khi mình rút USB.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HAY THẬT&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;suy-nghĩ-về-ẩn-danh&#34;&gt;Suy nghĩ về Ẩn danh&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Nói &lt;strong&gt;ẩn danh&lt;/strong&gt; cho vui vậy thôi, chứ nhà nước mà muốn &lt;strong&gt;mò&lt;/strong&gt; ra thì mò cái một. Đơn giản là vì &lt;strong&gt;nhà mạng&lt;/strong&gt; nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là &lt;strong&gt;vấn đề thời gian&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Do đó nếu muốn &lt;strong&gt;ẩn danh thật sự&lt;/strong&gt; thì tốt nhất đừng làm gì liên quan đến &lt;strong&gt;Chính phủ&lt;/strong&gt;. =]]&lt;/li&gt;
&lt;li&gt;Mình thì không có nhu cầu vào &lt;strong&gt;Dark Web&lt;/strong&gt;, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên &lt;strong&gt;Tails OS&lt;/strong&gt; vẫn là một biện pháp hay ho khi mình &lt;strong&gt;muốn làm gì đó mà không muốn người khác biết&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Google_vs_DuckDuckGo.jpg&#34;
  alt=&#34;Search&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/tails_os/</guid>
      <pubDate>Sun, 21 Jul 2024 17:34:15 +0700</pubDate>
    </item>
    
    <item>
      <title>Suy_nghi_ve_Hardware_Hacking</title>
      <link>https://vinhlin.github.io/posts/others/suy_nghi_ve_hardware_hacking/</link>
      <description>&lt;p&gt;Sau khi mình đã đọc hết cuốn &lt;a href=&#34;https://tiki.vn/khoa-hoc-kham-pha-vung-toi-lich-su-bi-an-cua-chien-tranh-mang-p251393388.html&#34;&gt;Vùng tối&lt;/a&gt;. Những &lt;strong&gt;hacker đời đầu&lt;/strong&gt; chính là các &lt;strong&gt;nhà vật lý&lt;/strong&gt;, những người &lt;strong&gt;kỹ sư, kỹ thuật điện tử&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://salt.tikicdn.com/cache/540x540/ts/product/46/60/43/e4ff35baeeaf8bb049e0c864e6132c6b.jpg&#34;
  alt=&#34;Vùng tối - Book&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;p&gt;Khi thế giới vẫn còn &lt;strong&gt;điện tử tương tự&lt;/strong&gt;, các điệp viên đã dùng các kỹ thuật để &lt;strong&gt;chặn, bắt tín hiệu&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Để rồi khi thế giới chuyển sang &lt;strong&gt;điện tử số&lt;/strong&gt;, sự ra đời của &lt;strong&gt;internet&lt;/strong&gt;. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,&amp;hellip;&lt;/p&gt;
&lt;p&gt;Dạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.&lt;/p&gt;
&lt;p&gt;Cũng như trong &lt;a href=&#34;https://www.youtube.com/watch?v=7MIoFxwawc0&amp;amp;list=WL&amp;amp;index=4&amp;amp;t=1s&#34;&gt;Show Ryan: What Does a Former Black Hat Hacker Carry Everyday?&lt;/a&gt; có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể &lt;strong&gt;thu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu&lt;/strong&gt;. Mình nhớ kỹ thuật này gọi là &lt;strong&gt;Relay Atack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Là một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự &lt;strong&gt;quá hay và ghê gớm&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Người làm ra những thiết bị này đúng là &lt;strong&gt;tay chơi về phần cứng&lt;/strong&gt;, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.&lt;/p&gt;
&lt;p&gt;Là hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.&lt;/p&gt;
&lt;p&gt;Mình cần rèn luyện kỹ năng, và ghi nhớ &lt;strong&gt;Hack to learn and not Learn to Hack&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;một-bài-viết-khác-về-hardware-hacking---tấn-công-hidhttpswhitehatvnthreadstan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao18012&#34;&gt;&lt;a href=&#34;https://whitehat.vn/threads/tan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao.18012/&#34;&gt;Một bài viết khác về Hardware hacking - Tấn công HID&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;tổng-hợp-các-tài-liệu-về-iot-hacking&#34;&gt;Tổng hợp các tài liệu về IoT Hacking:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/&#34;&gt;https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://v33ru.github.io/IoTSecurity101/&#34;&gt;https://v33ru.github.io/IoTSecurity101/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nebgnahz/awesome-iot-hacks&#34;&gt;https://github.com/nebgnahz/awesome-iot-hacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme&#34;&gt;https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.iotpentestingguide.com/&#34;&gt;https://www.iotpentestingguide.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://p.ost2.fyi/courses&#34;&gt;https://p.ost2.fyi/courses&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.&lt;/p&gt;
&lt;p&gt;Có lẻ vậy.&lt;/p&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/Hardware_Hacking.jpg&#34;
  alt=&#34;Hardware Hacking Tools&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;tổng-hợp-các-ý-hay-trong-cuốn-vùng-tối&#34;&gt;Tổng hợp các ý hay trong cuốn &lt;strong&gt;Vùng tối&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Nền tảng của Tác chiến Thông tin:&lt;/strong&gt; Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CNE (Computer Network Exploitation) - Khai thác Mạng máy tính:&lt;/strong&gt; Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/others/suy_nghi_ve_hardware_hacking/</guid>
      <pubDate>Wed, 10 Jul 2024 20:34:27 +0700</pubDate>
    </item>
    
    <item>
      <title>Goc_nhin_ve_Ngoai_ngu</title>
      <link>https://vinhlin.github.io/posts/others/goc_nhin_ve_ngoai_ngu/</link>
      <description>&lt;h2 id=&#34;một-góc-nhìn-cá-nhân-về-ngoại-ngữ&#34;&gt;Một &lt;strong&gt;góc nhìn cá nhân&lt;/strong&gt; về Ngoại ngữ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Là một người thiên về Khoa học Kỹ thuật thì với mình, &lt;strong&gt;Ngoại ngữ là một công cụ&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Mình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là &lt;strong&gt;một cái gì đó&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tại-sao-mình-có-suy-nghĩ-ngoại-ngữ-là-một-công-cụ&#34;&gt;Tại sao mình có suy nghĩ &lt;strong&gt;Ngoại ngữ là một công cụ&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Thú thật thì mình là một đứa &lt;strong&gt;ngu ngốc&lt;/strong&gt; về ngoại ngữ (cụ thể là &lt;strong&gt;Anh văn&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;Chả biết là do mình &lt;strong&gt;yếu Anh văn &amp;ndash;&amp;gt; Không coi trọng&lt;/strong&gt;, hay là vì &lt;strong&gt;Không coi trọng &amp;ndash;&amp;gt; Yếu Anh văn&lt;/strong&gt; ???&lt;/li&gt;
&lt;li&gt;Nhưng có một điều chắc chắn là mình biết &lt;strong&gt;anh văn quan trọng&lt;/strong&gt;, nhưng chưa phải là &lt;strong&gt;yếu tố quyết định&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Mục tiêu của mình đối với Anh văn chỉ đơn giản, đó là &lt;strong&gt;cầu nối với kiến thức của nhân loại&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Anh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tại-sao-lại-thế&#34;&gt;Tại sao lại thế?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có &lt;strong&gt;sự yêu thích và đam mê nhất định&lt;/strong&gt; thì mới theo được.&lt;/li&gt;
&lt;li&gt;Mình cũng vậy, khi có sự yêu thích sẽ dẫn đến &lt;strong&gt;nhu cầu tìm hiểu, học hỏi cái mới&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Và đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào:
&lt;ul&gt;
&lt;li&gt;Search keyword bằng tiếng anh.&lt;/li&gt;
&lt;li&gt;Đọc hiểu tài liệu tiếng anh.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Đó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;một-tình-huống-hài-hước-khác&#34;&gt;Một tình huống hài hước khác.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Có những lúc đi &lt;strong&gt;hội thảo&lt;/strong&gt;, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh.&lt;/li&gt;
&lt;li&gt;Có những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày.&lt;/li&gt;
&lt;li&gt;Nhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Ông này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;suy-nghĩ-khác&#34;&gt;Suy nghĩ khác&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Nếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì &lt;strong&gt;Trời đất, họ sẽ thăng tiến kinh lắm&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Chưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là &lt;strong&gt;leader&lt;/strong&gt;, &lt;strong&gt;Manager&lt;/strong&gt;,&amp;hellip;&lt;/li&gt;
&lt;li&gt;Lương sẽ khủng lắm đây.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Mà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Người ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân&lt;/strong&gt;.&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/others/goc_nhin_ve_ngoai_ngu/</guid>
      <pubDate>Sun, 07 Jul 2024 15:03:26 +0700</pubDate>
    </item>
    
    <item>
      <title>Tools</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/tools/</link>
      <description>&lt;h3 id=&#34;tool-git-dumperhttpsgithubcomarthaudgit-dumper&#34;&gt;&lt;a href=&#34;https://github.com/arthaud/git-dumper&#34;&gt;Tool: Git-Dumper&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Trong quá trình &lt;strong&gt;recon&lt;/strong&gt; một trang web, mà mình thấy có đường dẫn &lt;code&gt;.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Thì có thể dùng tool &lt;strong&gt;git-dumper&lt;/strong&gt; này để lấy thông tin.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tool-web-checkhttpsweb-checkxyz&#34;&gt;&lt;a href=&#34;https://web-check.xyz/&#34;&gt;Tool Web Check&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đây là một công cụ có thể sử dụng online, hoặc build ở local.&lt;/li&gt;
&lt;li&gt;Công cụ này giúp mình recon những thông số cơ bản của một trang web.&lt;/li&gt;
&lt;li&gt;Tài liệu:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. https://github.com/lissy93/web-check
2. https://web-check.xyz/about#api-documentation
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;caidohttpscaidoio&#34;&gt;&lt;a href=&#34;https://caido.io/&#34;&gt;Caido&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Công cụ này có chức năng tương tự như &lt;strong&gt;Burp-Suite&lt;/strong&gt;, nhưng mà là ở &lt;strong&gt;giao diện Web&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=5Di0VVK9JiQ&amp;amp;list=WL&amp;amp;index=2&#34;&gt;Tham khảo Youtube: How to Hack Web Apps with Caido&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tài liệu:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.caido.io/&#34;&gt;Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/caido&#34;&gt;Github Project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cuckoo-sandbox&#34;&gt;Cuckoo Sandbox&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://cuckoosandbox.org/download
https://cuckoo.sh/docs/
https://cuckoo.sh/docs/installation/host/requirements.html
https://cuckoosandbox.org/blog/207-interim-release
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;bunkerweb---waf&#34;&gt;Bunkerweb - WAF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bunkerity/bunkerweb&#34;&gt;https://github.com/bunkerity/bunkerweb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bunkerweb.io/&#34;&gt;https://www.bunkerweb.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.bunkerweb.io/latest/?utm_campaign=self&amp;amp;utm_source=bunkerwebio#overview&#34;&gt;https://docs.bunkerweb.io/latest/?utm_campaign=self&amp;amp;utm_source=bunkerwebio#overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://demo.bunkerweb.io/&#34;&gt;https://demo.bunkerweb.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/@bunkerity4183/videos&#34;&gt;https://www.youtube.com/@bunkerity4183/videos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;duplicati&#34;&gt;Duplicati&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=JoA6Bezgk1c&amp;amp;list=WL&amp;amp;index=107&#34;&gt;Youtube: Backup in Linux Servers - Docker Volumes, and Databases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Theo như video, thì ở đây sử dụng một open-source tên là &lt;a href=&#34;https://www.duplicati.com/download&#34;&gt;duplicati&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://duplicati.readthedocs.io/en/latest/01-introduction/&#34;&gt;Documents của Duplicati&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cài-đặt-duplicati-bằng-docker&#34;&gt;Cài đặt Duplicati bằng Docker&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.linuxserver.io/images/docker-duplicati&#34;&gt;linuxserver/duplicati&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/christianlempa/videos/tree/main/duplicati-tutorial&#34;&gt;duplicati-tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;script-thực-hiện-việc-auto-backuphttpsgithubcomchristianlempascriptstreemaindb-container-backup&#34;&gt;&lt;a href=&#34;https://github.com/ChristianLempa/scripts/tree/main/db-container-backup&#34;&gt;Script thực hiện việc auto-backup&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=wvsi3QilNQ8&#34;&gt;Tham khảo khác&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nettacker-automated-penetration-testing-framework---open-source-vulnerability-scanner---vulnerability-management&#34;&gt;Nettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Github Project: &lt;a href=&#34;https://github.com/OWASP/Nettacker&#34;&gt;Nettacker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Documents: &lt;a href=&#34;https://owasp.org/www-project-nettacker/&#34;&gt;https://owasp.org/www-project-nettacker/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Note&lt;/strong&gt;: Nhìn chung mình thấy tool này khá giống với tool &lt;strong&gt;reNgine&lt;/strong&gt;, hoặc một số công cụ auto-scan khác.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aescrypthttpswwwaescryptcom-công-cụ-mã-hóa-file&#34;&gt;&lt;a href=&#34;https://www.aescrypt.com/&#34;&gt;AESCrypt&lt;/a&gt;: Công cụ mã hóa file&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Đây là một phần mềm &lt;strong&gt;mã nguồn mở&lt;/strong&gt;, hỗ trợ mã hóa file.&lt;/li&gt;
&lt;li&gt;Video giới thiệu về công cụ này: &lt;a href=&#34;https://www.youtube.com/watch?v=zA4dDlslDXo&#34;&gt;AESCrypt - Mã hoá file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://services.udel.edu/TDClient/32/Portal/KB/ArticleDet?ID=366&#34;&gt;Một bài viết khác&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/tools/</guid>
      <pubDate>Sat, 06 Jul 2024 15:36:05 +0700</pubDate>
    </item>
    
    <item>
      <title>RedTeam</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/redteam/</link>
      <description>&lt;h3 id=&#34;5-free-red-teaming-resources-to-get-you-startedhttpswwwhelpnetsecuritycom20240416free-red-teaming-resources&#34;&gt;&lt;a href=&#34;https://www.helpnetsecurity.com/2024/04/16/free-red-teaming-resources/&#34;&gt;5 free red teaming resources to get you started&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dmcxblue.gitbook.io/red-team-notes-2-0&#34;&gt;Red Team Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://assets.publishing.service.gov.uk/media/61702155e90e07197867eb93/20210625-Red_Teaming_Handbook.pdf&#34;&gt;Red Teaming Handbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/A-poc/RedTeam-Tools&#34;&gt;Red Team Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/infosecn1nja/Red-Teaming-Toolkit&#34;&gt;Red Teaming Toolkit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/redteam/</guid>
      <pubDate>Sat, 15 Jun 2024 11:05:38 +0700</pubDate>
    </item>
    
    <item>
      <title>TheHive</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/thehive/</link>
      <description>&lt;ul&gt;
&lt;li&gt;Theo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình:
&lt;ul&gt;
&lt;li&gt;Phát hiện&lt;/li&gt;
&lt;li&gt;Báo cáo&lt;/li&gt;
&lt;li&gt;Xử lý&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Công cụ &lt;strong&gt;TheHive&lt;/strong&gt; là nằm trong giai đoạn 2.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ví-dụ-dễ-hiểu-như-sau&#34;&gt;Ví dụ dễ hiểu như sau:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Khi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này.&lt;/li&gt;
&lt;li&gt;Nếu không xử lý được, hoặc mức độ phức tạp cao thì tạo &lt;strong&gt;Ticket&lt;/strong&gt; mô tả và cung cấp đầy đủ thông tin.
(Giai đoạn này là bước sử dụng &lt;strong&gt;TheHive&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;Người có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;thehive&#34;&gt;TheHive&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TheHive cũng có chức năng như &lt;strong&gt;JIRA&lt;/strong&gt;, tuy nhiên TheHive là &lt;strong&gt;open-source&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Documents:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- https://thehive-project.org/
- http://docs.thehive-project.org/cortex/
- https://github.com/thehive-project/Cortex/
- https://blog.thehive-project.org/
- https://docs.thehive-project.org/
- https://github.com/TheHive-Project/Cortex
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;tham-khảo-thehive-với-graylog&#34;&gt;Tham khảo TheHive với Graylog&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- https://blog.reconinfosec.com/integrating-graylog-with-thehive
- https://github.com/ReconInfoSec/graylog2thehive
&lt;/code&gt;&lt;/pre&gt;</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/thehive/</guid>
      <pubDate>Sat, 15 Jun 2024 11:04:17 +0700</pubDate>
    </item>
    
    <item>
      <title>OSINT</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/osint/</link>
      <description>&lt;h3 id=&#34;osint---open-source-intelligencehttpsanonyvietcomosint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet&#34;&gt;&lt;a href=&#34;https://anonyviet.com/osint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet/&#34;&gt;OSINT - Open Source Intelligence&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bước đầu tiên&lt;/strong&gt; trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là &lt;strong&gt;thu thập các thông tin&lt;/strong&gt; giá trị về mục tiêu.&lt;/li&gt;
&lt;li&gt;Thu thập thông tin thì có 2 dạng là:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Passive Reconnaissance - Thu thập thông tin thụ động
Active Reconnaissance - Thu thập thông tin chủ động
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Trong đó việc &lt;strong&gt;thu thập thông tin thụ động&lt;/strong&gt; thường được gọi là &lt;strong&gt;OSINT&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Bất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;others-documents&#34;&gt;Others Documents&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hackers-arise.com/osint&#34;&gt;https://www.hackers-arise.com/osint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://anonyviet.com/cac-tool-osint-truy-vet-toi-pham-tren-internet/&#34;&gt;Top 10 công cụ OSINT tốt nhất 2020&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;một-số-công-cụ-theo-osint-frameworkhttpsosintframeworkcom-mà-mình-biết&#34;&gt;Một số công cụ theo &lt;a href=&#34;https://osintframework.com/&#34;&gt;OSINT Framework&lt;/a&gt; mà mình biết:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.virustotal.com/gui/home/upload&#34;&gt;VirusTotal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.shodan.io/&#34;&gt;Shodan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://archive.org/web/&#34;&gt;Wayback Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://any.run/&#34;&gt;ANY.RUN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/osint/</guid>
      <pubDate>Sat, 15 Jun 2024 11:02:08 +0700</pubDate>
    </item>
    
    <item>
      <title>ESD</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/esd/</link>
      <description>&lt;h2 id=&#34;esd-electrostatic-sensitive-devices---sự-phóng-tĩnh-điện&#34;&gt;ESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Là dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Đây là một &lt;a href=&#34;https://www.youtube.com/watch?v=MzxBBXpgwrE&#34;&gt;video&lt;/a&gt; nói về cách &lt;strong&gt;chống tĩnh điện&lt;/strong&gt;, dựa trên các linh kiện:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TVS - Transient Voltage Suppressor
MOV - Metal Oxide Varistor
GDT - Gas Discharge Tube
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;tvs-diode&#34;&gt;TVS Diode&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=oKACLpBYhxU&#34;&gt;Một video giải thích cách hoạt động của TVS Diode&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Một ví dụ về linh kiện TVS, &lt;a href=&#34;https://www.mouser.vn/ProductDetail/Semtech/SMF05C.TCT?qs=rBWM4%252BvDhIcdGOAFdL4XAA%3D%3D&amp;amp;_gl=1*109bc2w*_ga*ODE4NDU2NjY3LjE3MTM3NzI5OTI.*_ga_15W4STQT4T*MTcxMzc3Mjk5Mi4xLjAuMTcxMzc3Mjk5My41OS4wLjA.&#34;&gt;Semtech SMF05C.TCT&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mov&#34;&gt;MOV&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linh kiện &lt;a href=&#34;https://www.mouser.vn/ProductDetail/Bourns/MOV-10D470KKTR?qs=ST9lo4GX8V0v1uLdRAW6Kg%3D%3D&amp;amp;_gl=1*17bo42l*_ga*MTY3MzQ3NTE2Ni4xNzEzNzcyOTg0*_ga_15W4STQT4T*MTcxMzc3Mjk4My4xLjEuMTcxMzc3Mjk5MC41My4wLjA.&#34;&gt;Bourns MOV-10D470KKTR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gdt&#34;&gt;GDT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linh kiện &lt;a href=&#34;https://www.mouser.vn/ProductDetail/Bourns/GDT25-47-S1-RP?qs=2MMvu9PpTS3BszAgeO7ppQ%3D%3D&#34;&gt;Bourns GDT25-47-S1-RP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/ESD_Electronics.png&#34;
  alt=&#34;ESD&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/esd/</guid>
      <pubDate>Sat, 25 May 2024 15:59:27 +0700</pubDate>
    </item>
    
    <item>
      <title>DFLab_VNCERT</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/dflab_vncert/</link>
      <description>&lt;h2 id=&#34;bài-viết---công-cụ-điều-tra-nhật-ký-sự-kiện-của-digital-forensics-lab---cục-an-toàn-thông-tin-vncertcchttpsdfirlabvndocstoolslog&#34;&gt;&lt;a href=&#34;https://df.irlab.vn/docs/tools/log/&#34;&gt;Bài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC))&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Bài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích &lt;strong&gt;log&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Trong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hayabusahttpsgithubcomyamato-securityhayabusa&#34;&gt;&lt;a href=&#34;https://github.com/Yamato-Security/hayabusa&#34;&gt;Hayabusa&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Hayabusa là một công cụ xử lý nhanh &lt;strong&gt;Windows Event Log&lt;/strong&gt;, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;goaccesshttpsgithubcomallinurlgoaccess&#34;&gt;&lt;a href=&#34;https://github.com/allinurl/goaccess&#34;&gt;GoAccess&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;GoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://goaccess.io/get-started&#34;&gt;Get Started GoAccess&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=PbKpdHeuG2A&#34;&gt;How to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/dflab_vncert/</guid>
      <pubDate>Sat, 25 May 2024 15:56:30 +0700</pubDate>
    </item>
    
    <item>
      <title>Firewall_CheckList</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/firewall_checklist/</link>
      <description>&lt;h3 id=&#34;có-thể-coi-firewall-checklist-là-phương-pháp-để-mình-pentest-network&#34;&gt;Có thể coi &lt;code&gt;Firewall Checklist&lt;/code&gt; là phương pháp để mình Pentest Network&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dùng các công cụ để test hạ tầng Network:
&lt;ul&gt;
&lt;li&gt;Nmap&lt;/li&gt;
&lt;li&gt;Ettercap&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kali.org/tools/firewalk/&#34;&gt;Firewalk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wireshark&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Check version của Firewall + CVE, tìm các cách khắc phục.&lt;/li&gt;
&lt;li&gt;Dựa vào file &lt;strong&gt;Firewall_Checklist&lt;/strong&gt; để áp dụng cách đặt rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;documents-firewall_checklistdocsfirewallchecklistpdf&#34;&gt;&lt;a href=&#34;https://vinhlin.github.io/docs/FirewallChecklist.pdf&#34;&gt;Documents Firewall_Checklist&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/CyberSecurity/Firewall_Cheatsheet.jpg&#34;
  alt=&#34;Firewall Checklist&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/firewall_checklist/</guid>
      <pubDate>Sat, 25 May 2024 15:48:35 +0700</pubDate>
    </item>
    
    <item>
      <title>NIS2</title>
      <link>https://vinhlin.github.io/posts/cybersecurity/technical/nis2/</link>
      <description>&lt;h2 id=&#34;bài-viết-tuân-thủ-nis2-cho-các-mạng-công-nghiệphttpswhitehatvnthreadstuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua17872&#34;&gt;&lt;a href=&#34;https://whitehat.vn/threads/tuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua.17872/&#34;&gt;Bài viết: Tuân thủ NIS2 cho các mạng công nghiệp&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;nis2-compliance-for-industries-white-paperhttpswwwciscocomcenusproductscollateralsecurityindustrial-securitynetwork-info-security-wppdf&#34;&gt;&lt;a href=&#34;https://www.cisco.com/c/en/us/products/collateral/security/industrial-security/network-info-security-wp.pdf&#34;&gt;NIS2 Compliance for Industries White Paper&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&#34;tổng-hợp-các-thông-tin-cần-biết-trong-bài-viết&#34;&gt;Tổng hợp các thông tin cần biết trong bài viết:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Các phần tử kết nối mạng OT cần được chứng nhận an toàn&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Các tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì.&lt;/li&gt;
&lt;li&gt;Vì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Đánh giá và xếp loại ưu tiên các rủi ro mạng OT&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ.&lt;/li&gt;
&lt;li&gt;NIS2 yêu cầu bạn có khả năng &amp;ldquo;nhìn xuyên thấu&amp;rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Triển khai Zero-trust&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2.&lt;/li&gt;
&lt;li&gt;Lưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn.&lt;/li&gt;
&lt;li&gt;ISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có.&lt;/li&gt;
&lt;li&gt;Đây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Triển khai Zero-trust remote access&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Thay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Hãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Phát hiện và báo cáo sự cố&lt;/strong&gt;: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://vinhlin.github.io/image/IoT/OT.jfif&#34;
  alt=&#34;OT&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/cybersecurity/technical/nis2/</guid>
      <pubDate>Sat, 25 May 2024 15:43:13 +0700</pubDate>
    </item>
    
    <item>
      <title>Raspberry OpenAuto</title>
      <link>https://vinhlin.github.io/posts/iot/software/raspberry-openauto/</link>
      <description>&lt;h3 id=&#34;openauto&#34;&gt;OpenAuto&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://bluewavestudio.io/#features&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;9https://bluewavestudio.io/community/showthread.php?tid=2774&#34;&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Theo như mình hiểu thì &lt;strong&gt;OpenAuto&lt;/strong&gt;, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hình như &lt;strong&gt;CrankShaft&lt;/strong&gt; cũng từ open source của &lt;strong&gt;OpenAuto&lt;/strong&gt; mà ra.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/f1xpl/openauto/wiki&#34;&gt;Tham khảo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;video-tham-khao&#34;&gt;Video tham khảo&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=RgbHXTHUnQw&#34;&gt;https://www.youtube.com/watch?v=RgbHXTHUnQw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ko-udLtaPk8&#34;&gt;https://www.youtube.com/watch?v=ko-udLtaPk8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/raspberry-openauto/</guid>
      <pubDate>Mon, 01 Apr 2024 17:57:07 +0700</pubDate>
    </item>
    
    <item>
      <title>Pi400 Keyboard</title>
      <link>https://vinhlin.github.io/posts/iot/software/pi400-keyboard/</link>
      <description>&lt;h3 id=&#34;sử-dụng-raspberry-pi400-như-một-bàn-phím-thông-thường&#34;&gt;Sử dụng Raspberry Pi400 như một bàn phím thông thường.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/&#34;&gt;https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard&#34;&gt;https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Gadgetoid/pi400kb/tree/main&#34;&gt;https://github.com/Gadgetoid/pi400kb/tree/main&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img
  src=&#34;https://www.cytron.io/image/landing/RPI%20400/photo_2020-10-31_11-28-37.jpg&#34;
  alt=&#34;Pi400&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/pi400-keyboard/</guid>
      <pubDate>Mon, 01 Apr 2024 17:53:24 +0700</pubDate>
    </item>
    
    <item>
      <title>PiKVM</title>
      <link>https://vinhlin.github.io/posts/iot/software/pikvm/</link>
      <description>&lt;h3 id=&#34;pikvmhttpsgithubcompikvmpikvm&#34;&gt;&lt;a href=&#34;https://github.com/pikvm/pikvm&#34;&gt;PiKVM&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Theo tài liệu thì &lt;strong&gt;KVM (Keyboard-Video-Mouse)&lt;/strong&gt;, tức là &lt;strong&gt;PiKVM&lt;/strong&gt; là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP.&lt;/li&gt;
&lt;li&gt;Tức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần:
&lt;ul&gt;
&lt;li&gt;Màn hình để xuất hình ảnh.&lt;/li&gt;
&lt;li&gt;Chuột và bàn phím để điều khiển.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Với &lt;strong&gt;PiKVM&lt;/strong&gt; nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua &lt;strong&gt;WebUI&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PiKVM&lt;/strong&gt; lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa.&lt;/li&gt;
&lt;li&gt;Thông thường nếu chỉ dùng Anydesk, TeamViewer,&amp;hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất.&lt;/li&gt;
&lt;li&gt;Vậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của &lt;strong&gt;PiKVM&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tham-khảo-video&#34;&gt;Tham khảo video&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=2HqbQdZUEmY&#34;&gt;https://www.youtube.com/watch?v=2HqbQdZUEmY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=PppcpSVYh0E&#34;&gt;https://www.youtube.com/watch?v=PppcpSVYh0E&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=KrpHCsK7veA&#34;&gt;https://www.youtube.com/watch?v=KrpHCsK7veA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;documents&#34;&gt;Documents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.pikvm.org/&#34;&gt;https://docs.pikvm.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pikvm.org/&#34;&gt;https://pikvm.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.geekworm.com/PiKVM&#34;&gt;https://wiki.geekworm.com/PiKVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PiKVM&lt;/strong&gt; có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.waveshare.com/wiki/HDMI_to_CSI_Adapter&#34;&gt;Cần thêm module covert từ HDMI - CSI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/software/pikvm/</guid>
      <pubDate>Mon, 01 Apr 2024 17:49:12 +0700</pubDate>
    </item>
    
    <item>
      <title>UNIHIKER</title>
      <link>https://vinhlin.github.io/posts/iot/hardware/unihiker/</link>
      <description>&lt;h3 id=&#34;documents&#34;&gt;Documents&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.unihiker.com/wiki/get-started&#34;&gt;Getting Started with UNIHIKER&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dfrobot.com/product-2691.html&#34;&gt;Dfrobot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sản-phẩmhttpswwwproevnunihiker-iot-python-programming-single-board-computer-with-touchscreen&#34;&gt;&lt;a href=&#34;https://www.proe.vn/unihiker-iot-python-programming-single-board-computer-with-touchscreen&#34;&gt;Sản phẩm&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img
  src=&#34;https://cdn.mos.cms.futurecdn.net/KRLwXFfy86ybfwUdzxmaFm-1200-80.jpg&#34;
  alt=&#34;SP&#34;
  loading=&#34;lazy&#34;
  decoding=&#34;async&#34;
  class=&#34;full-width&#34;
/&gt;

&lt;/p&gt;
</description>
      <author>VinhLD</author>
      <guid>https://vinhlin.github.io/posts/iot/hardware/unihiker/</guid>
      <pubDate>Mon, 01 Apr 2024 17:34:03 +0700</pubDate>
    </item>
    
  </channel>
</rss>
