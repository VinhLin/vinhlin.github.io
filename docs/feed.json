{
  "version": "https://jsonfeed.org/version/1",
  "title": "VinhLin",
  "home_page_url": "https://vinhlin.github.io/",
  "feed_url": "https://vinhlin.github.io/feed.json",
  "description": "Technology Blog",
  "favicon": "https://vinhlin.github.io//assets/favicon.ico",
  "expired": false,
  "author": {
    "name": "VinhLD",
    "url": "https://vinhlin.github.io/"
  },
  "items": [
    
    

    
    {
      "id": "74e24425c046bfd64fae29d02c93e5336606fd9c",
      "title": "Automation_Tools",
      "summary": "",
      "content_text": "Video: I automated EVERYTHING in my HomeLab // Kestra #2\nMình không có nhiều kiến thức về DevOps, nên mình sẽ dùng Grok 3 để phân tích và hỏi thêm về các công cụ Automation.\nĐây là câu trả lời:\nKestra Giới thiệu: Kestra là một công cụ điều phối workflow mã nguồn mở, được thiết kế để quản lý và tự động hóa các quy trình phức tạp. Trong video \u0026ldquo;I automated EVERYTHING in my HomeLab // Kestra #2\u0026rdquo;, tác giả sử dụng Kestra để điều phối các tác vụ như chạy script, quản lý container, và tích hợp hệ thống trong HomeLab. Điểm mạnh: Dễ định nghĩa workflow: Sử dụng YAML để mô tả luồng công việc, đơn giản và dễ đọc. Giao diện web: Có dashboard trực quan để theo dõi tiến trình, rất hữu ích cho việc giám sát trong HomeLab. Tích hợp linh hoạt: Hỗ trợ Docker, Kubernetes, và các công cụ khác, phù hợp với môi trường thử nghiệm. Nhẹ và mới mẻ: Không yêu cầu tài nguyên lớn, lý tưởng cho HomeLab cá nhân. Điểm yếu: Cộng đồng nhỏ: Vì là công cụ mới, tài liệu và hỗ trợ cộng đồng chưa phong phú như Ansible hay Terraform. Không chuyên sâu về cấu hình: Không mạnh trong việc quản lý trạng thái hệ thống như Ansible hay Terraform. Tại sao tác giả chọn Kestra?: Video cho thấy tác giả muốn một giải pháp nhẹ, dễ tùy chỉnh workflows phức tạp (như chạy các tác vụ theo thứ tự), và có giao diện để theo dõi trực tiếp. Kestra tỏ ra phù hợp với phong cách \u0026ldquo;tự động hóa mọi thứ\u0026rdquo; trong một môi trường thử nghiệm sáng tạo. Ansible Giới thiệu: Ansible là công cụ tự động hóa quản lý cấu hình, được sử dụng rộng rãi để triển khai ứng dụng, cấu hình server, và quản lý hệ thống mà không cần cài agent trên máy đích (dùng SSH). Điểm mạnh: Đơn giản và phổ biến: Cú pháp YAML (playbooks) dễ học, cộng đồng lớn với nhiều tài liệu và module sẵn có. Không cần agent: Chỉ cần SSH, phù hợp cho mọi hệ thống từ server lớn đến HomeLab nhỏ. Tự động hóa cơ bản mạnh mẽ: Quản lý cấu hình, cài đặt phần mềm, hoặc chạy script đều rất hiệu quả. Điểm yếu: Hiệu suất: Chậm hơn khi quản lý số lượng máy lớn vì không có cơ chế xử lý song song tối ưu (trừ khi dùng thêm công cụ như Ansible Tower). Không quản lý trạng thái hạ tầng: Không thiết kế để xây dựng hoặc duy trì cơ sở hạ tầng như Terraform. So với Kestra: Ansible tập trung vào tự động hóa tác vụ cụ thể (ví dụ: cài đặt Nginx trên 10 máy), trong khi Kestra thiên về điều phối luồng công việc phức tạp (ví dụ: chạy script A, sau đó kiểm tra kết quả, rồi mới chạy B). Terraform Giới thiệu: Terraform là công cụ \u0026ldquo;Infrastructure as Code\u0026rdquo; (IaC), dùng để xây dựng, quản lý, và duy trì hạ tầng (VM, network, cloud resources) thông qua các file cấu hình (HCL hoặc JSON). Điểm mạnh: Quản lý hạ tầng: Tạo và duy trì trạng thái cơ sở hạ tầng (ví dụ: tạo 5 VM trên AWS rồi gắn IP cố định). Hỗ trợ đa nền tảng: Tích hợp với hầu hết các nhà cung cấp cloud (AWS, GCP, Azure) và cả môi trường on-premise. Tính nhất quán: Đảm bảo hạ tầng luôn đúng với cấu hình đã định nghĩa (idempotency). Điểm yếu: Không phải công cụ điều phối: Không phù hợp cho việc chạy script hoặc quản lý tác vụ hàng ngày như Kestra hay Ansible. Độ phức tạp: Cần hiểu rõ hạ tầng và cú pháp HCL, không thân thiện với người mới bằng Ansible. So với Kestra: Terraform xây dựng \u0026ldquo;nền móng\u0026rdquo; ( hạ tầng), trong khi Kestra quản lý \u0026ldquo;công việc\u0026rdquo; chạy trên nền móng đó. ",
      "content_html": "\u003cp\u003eVideo: \u003ca href=\"https://www.youtube.com/watch?v=PJG1-7hMHsE\u0026amp;list=WL\u0026amp;index=68\u0026amp;t=14s\"\u003eI automated EVERYTHING in my HomeLab // Kestra #2\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMình không có nhiều kiến thức về DevOps, nên mình sẽ dùng \u003cstrong\u003eGrok 3\u003c/strong\u003e để phân tích và hỏi thêm về các công cụ Automation.\u003c/p\u003e\n\u003cp\u003eĐây là câu trả lời:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eKestra\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGiới thiệu: Kestra là một công cụ điều phối workflow mã nguồn mở, được thiết kế để quản lý và tự động hóa các quy trình phức tạp. Trong video \u0026ldquo;I automated EVERYTHING in my HomeLab // Kestra #2\u0026rdquo;, tác giả sử dụng Kestra để điều phối các tác vụ như chạy script, quản lý container, và tích hợp hệ thống trong HomeLab.\u003c/li\u003e\n\u003cli\u003eĐiểm mạnh:\n\u003cul\u003e\n\u003cli\u003eDễ định nghĩa workflow: Sử dụng YAML để mô tả luồng công việc, đơn giản và dễ đọc.\u003c/li\u003e\n\u003cli\u003eGiao diện web: Có dashboard trực quan để theo dõi tiến trình, rất hữu ích cho việc giám sát trong HomeLab.\u003c/li\u003e\n\u003cli\u003eTích hợp linh hoạt: Hỗ trợ Docker, Kubernetes, và các công cụ khác, phù hợp với môi trường thử nghiệm.\u003c/li\u003e\n\u003cli\u003eNhẹ và mới mẻ: Không yêu cầu tài nguyên lớn, lý tưởng cho HomeLab cá nhân.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐiểm yếu:\n\u003cul\u003e\n\u003cli\u003eCộng đồng nhỏ: Vì là công cụ mới, tài liệu và hỗ trợ cộng đồng chưa phong phú như Ansible hay Terraform.\u003c/li\u003e\n\u003cli\u003eKhông chuyên sâu về cấu hình: Không mạnh trong việc quản lý trạng thái hệ thống như Ansible hay Terraform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTại sao tác giả chọn Kestra?: Video cho thấy tác giả muốn một giải pháp nhẹ, dễ tùy chỉnh workflows phức tạp (như chạy các tác vụ theo thứ tự), và có giao diện để theo dõi trực tiếp. Kestra tỏ ra phù hợp với phong cách \u0026ldquo;tự động hóa mọi thứ\u0026rdquo; trong một môi trường thử nghiệm sáng tạo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eAnsible\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGiới thiệu: Ansible là công cụ tự động hóa quản lý cấu hình, được sử dụng rộng rãi để triển khai ứng dụng, cấu hình server, và quản lý hệ thống mà không cần cài agent trên máy đích (dùng SSH).\u003c/li\u003e\n\u003cli\u003eĐiểm mạnh:\n\u003cul\u003e\n\u003cli\u003eĐơn giản và phổ biến: Cú pháp YAML (playbooks) dễ học, cộng đồng lớn với nhiều tài liệu và module sẵn có.\u003c/li\u003e\n\u003cli\u003eKhông cần agent: Chỉ cần SSH, phù hợp cho mọi hệ thống từ server lớn đến HomeLab nhỏ.\u003c/li\u003e\n\u003cli\u003eTự động hóa cơ bản mạnh mẽ: Quản lý cấu hình, cài đặt phần mềm, hoặc chạy script đều rất hiệu quả.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐiểm yếu:\n\u003cul\u003e\n\u003cli\u003eHiệu suất: Chậm hơn khi quản lý số lượng máy lớn vì không có cơ chế xử lý song song tối ưu (trừ khi dùng thêm công cụ như Ansible Tower).\u003c/li\u003e\n\u003cli\u003eKhông quản lý trạng thái hạ tầng: Không thiết kế để xây dựng hoặc duy trì cơ sở hạ tầng như Terraform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSo với Kestra: Ansible tập trung vào tự động hóa tác vụ cụ thể (ví dụ: cài đặt Nginx trên 10 máy), trong khi Kestra thiên về điều phối luồng công việc phức tạp (ví dụ: chạy script A, sau đó kiểm tra kết quả, rồi mới chạy B).\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eTerraform\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGiới thiệu: Terraform là công cụ \u0026ldquo;Infrastructure as Code\u0026rdquo; (IaC), dùng để xây dựng, quản lý, và duy trì hạ tầng (VM, network, cloud resources) thông qua các file cấu hình (HCL hoặc JSON).\u003c/li\u003e\n\u003cli\u003eĐiểm mạnh:\n\u003cul\u003e\n\u003cli\u003eQuản lý hạ tầng: Tạo và duy trì trạng thái cơ sở hạ tầng (ví dụ: tạo 5 VM trên AWS rồi gắn IP cố định).\u003c/li\u003e\n\u003cli\u003eHỗ trợ đa nền tảng: Tích hợp với hầu hết các nhà cung cấp cloud (AWS, GCP, Azure) và cả môi trường on-premise.\u003c/li\u003e\n\u003cli\u003eTính nhất quán: Đảm bảo hạ tầng luôn đúng với cấu hình đã định nghĩa (idempotency).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐiểm yếu:\n\u003cul\u003e\n\u003cli\u003eKhông phải công cụ điều phối: Không phù hợp cho việc chạy script hoặc quản lý tác vụ hàng ngày như Kestra hay Ansible.\u003c/li\u003e\n\u003cli\u003eĐộ phức tạp: Cần hiểu rõ hạ tầng và cú pháp HCL, không thân thiện với người mới bằng Ansible.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSo với Kestra: Terraform xây dựng \u0026ldquo;nền móng\u0026rdquo; ( hạ tầng), trong khi Kestra quản lý \u0026ldquo;công việc\u0026rdquo; chạy trên nền móng đó.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/automation_tools/",
      "date_published": "26026-26-09T249:2626:00+07:00",
      "date_modified": "26026-26-09T249:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e934dd983c5c08756dbdea21ad014292968fc72a",
      "title": "Grok_AI",
      "summary": "",
      "content_text": "Dạo gần đây rộ lên thông tin về một AI của tỷ phú Elon Musk, tên là Grok 3.\nMình có dùng thử Grok 3 trên X, và thấy AI này trả lời rất hay và tuyệt vời.\nVí dụ: Đây là một đoạn chat, Grok trả lời hay thật.\nMột bài toán khác: Đây là một bài toán mà mình đặt và hỏi Grok. Chủ đề xoay quanh đại loại là: Tôi có một server dùng chip Xeon ở nhà, hiện chỉ sử dụng 5% sức mạnh CPU và đang dư khoảng 20GB RAM. Tôi nên chạy ứng dụng gì để tối ưu hóa CPU và tiết kiệm điện năng tiêu thụ. Rồi hỏi một hồi thì mình có thông tin về Boinc và Monero. Đây là câu trả lời của grok. Mình đã copy lại thành file để tham khảo sau này. Link file PDF Sau đó thấy phản hồi từ grok, mình quyết định có thể sẽ dùng boinc đóng góp cho cộng đồng, thay vì dùng Monero để đào coin. Đây là một số tài liệu search được từ dự án boinc: https://github.com/BOINC/boinc https://boinc.berkeley.edu/download.php https://boinc.berkeley.edu/wiki/User_manual https://delta1512.github.io/BOINCOS/ Sau đó phát hiện ra có OS tên là BOINCOS, gửi link và hỏi lại grok về cái OS. Và đây là câu trả lời khi so sánh Boinc với loại hình MMO (như mining (đào coin) và render farm). Link pdf Đánh giá: Chỉ có thể nói là Grok 3 quá hay.\n",
      "content_html": "\u003cp\u003eDạo gần đây rộ lên thông tin về một AI của \u003cstrong\u003etỷ phú Elon Musk\u003c/strong\u003e, tên là \u003cstrong\u003eGrok 3\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình có dùng thử \u003cstrong\u003eGrok 3\u003c/strong\u003e trên \u003cstrong\u003eX\u003c/strong\u003e, và thấy AI này trả lời rất hay và tuyệt vời.\u003c/p\u003e\n\u003ch3 id=\"ví-dụ\"\u003eVí dụ:\u003c/h3\u003e\n\u003cp\u003eĐây là một đoạn chat, Grok trả lời hay thật.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"một-bài-toán-khác\"\u003eMột bài toán khác:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một bài toán mà mình đặt và hỏi Grok.\u003c/li\u003e\n\u003cli\u003eChủ đề xoay quanh đại loại là: Tôi có một server dùng chip Xeon ở nhà, hiện chỉ sử dụng 5% sức mạnh CPU và đang dư khoảng 20GB RAM. Tôi nên chạy ứng dụng gì để tối ưu hóa CPU và tiết kiệm điện năng tiêu thụ.\u003c/li\u003e\n\u003cli\u003eRồi hỏi một hồi thì mình có thông tin về \u003cstrong\u003eBoinc\u003c/strong\u003e và \u003cstrong\u003eMonero\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐây là câu trả lời của grok. Mình đã copy lại thành file để tham khảo sau này. \u003ca href=\"https://blog.vinhld-homelab.io.vn/docs/grok_ai_chat/Grok-Boinc_Monero.pdf\"\u003eLink file PDF\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eSau đó thấy phản hồi từ grok, mình quyết định có thể sẽ dùng \u003cstrong\u003eboinc\u003c/strong\u003e đóng góp cho cộng đồng, thay vì dùng \u003cstrong\u003eMonero\u003c/strong\u003e để đào coin.\u003c/li\u003e\n\u003cli\u003eĐây là một số tài liệu search được từ dự án boinc:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/BOINC/boinc\nhttps://boinc.berkeley.edu/download.php\nhttps://boinc.berkeley.edu/wiki/User_manual\nhttps://delta1512.github.io/BOINCOS/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eSau đó phát hiện ra có OS tên là \u003cstrong\u003eBOINCOS\u003c/strong\u003e, gửi link và hỏi lại grok về cái OS.\u003c/li\u003e\n\u003cli\u003eVà đây là câu trả lời khi so sánh Boinc với loại hình \u003cstrong\u003eMMO (như mining (đào coin) và render farm)\u003c/strong\u003e. \u003ca href=\"/docs/grok_ai_chat/Grok_BoincOS.pdf\"\u003eLink pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"đánh-giá\"\u003eĐánh giá:\u003c/h3\u003e\n\u003cp\u003eChỉ có thể nói là \u003cstrong\u003eGrok 3\u003c/strong\u003e quá hay.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/grok_ai/",
      "date_published": "26026-26-09T242:2626:00+07:00",
      "date_modified": "26026-26-09T242:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "88771a027c6f045dda8d2e83d986085a46145ef3",
      "title": "Y_tuong_project",
      "summary": "",
      "content_text": "Hiện tại thì bản thân vẫn đang tiếp tục cải thiện project HOMELAB.\nTuy nhiên mình sẽ làm một số project nhỏ hơn, và sẽ xoay quanh Homelab.\n🌱 Ý tưởng bổ sung cho HomeLAB: 👉 Rust Tracking Mình vẫn đang tìm hiểu và học ngôn ngữ lập trình Rust. Để trau dồi thêm khả năng code bằng Rust, mình sẽ setup một dự án cho bản thân, tên dự án hiện tại là Rust_Tracking. Dùng Rust để viết Firmware cho thiết bị GPS, sau đó gửi dữ liệu lên IoT Platform - ThingsBoard. IoT Platform này mình cũng tự build dựa trên hạ tầng hiện tại. Tự làm một thiết bị Tracking cho bản thân. 👉 Quản lý bán hàng Mình sẽ setup một SQL Server, sau đó viết một desktop app đơn giản chạy trên Windows (dùng công cụ C++ Builder). App này sẽ có chức năng là cập nhật dữ liệu cho database, kiểm tra hàng hóa (số lượng, mã QR). 👉 Raspberry Camera Mục đích là ôn luyện lại về C++ cũng như đào sâu hơn về Nhúng Linux. Có thể mình sẽ chia dự án này thành các phần: Hardwar OS Firmware/Software Platform Hardware: Raspberry Zero 2W + Camera for Pi. OS: Yocto Linux Firmware/Sofware: Web Application: DHCP Server: Xem video ở local DHCP Client: Kết nối mạng, send location data, Notifi Telegram. Desktop Application: Config device Platform: Lấy thông tin location, Update OTA, Image của camera. Ngoài ra mình sẽ code camera này theo ONVIF Protocol, và theo QCVN-135\n👉 Bad USB Mục đích là để trau dồi kỹ năng coding dùng ngôn ngữ Rust, và ứng dụng vào Red-Team. Ở đây mình dự định sẽ dùng: Raspberry Pico + Rust-lang + Embassy Framewok ",
      "content_html": "\u003cp\u003eHiện tại thì bản thân vẫn đang tiếp tục cải thiện project \u003cstrong\u003eHOMELAB\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTuy nhiên mình sẽ làm một số project nhỏ hơn, và sẽ xoay quanh Homelab.\u003c/p\u003e\n\u003ch2 id=\"-ý-tưởng-bổ-sung-cho-homelab\"\u003e🌱 Ý tưởng bổ sung cho HomeLAB:\u003c/h2\u003e\n\u003ch3 id=\"-rust-tracking\"\u003e👉 Rust Tracking\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình vẫn đang tìm hiểu và học \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/rust-lang/\"\u003engôn ngữ lập trình Rust\u003c/a\u003e. Để trau dồi thêm khả năng code bằng Rust, mình sẽ setup một dự án cho bản thân, tên dự án hiện tại là \u003ccode\u003eRust_Tracking\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eDùng Rust để viết Firmware cho thiết bị GPS, sau đó gửi dữ liệu lên \u003ca href=\"https://www.vinhld-homelab.io.vn/login\"\u003eIoT Platform - ThingsBoard\u003c/a\u003e. IoT Platform này mình cũng tự build dựa trên hạ tầng hiện tại.\u003c/li\u003e\n\u003cli\u003eTự làm một thiết bị Tracking cho bản thân.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-quản-lý-bán-hàng\"\u003e👉 Quản lý bán hàng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình sẽ setup một \u003cstrong\u003eSQL Server\u003c/strong\u003e, sau đó viết một desktop app đơn giản chạy trên Windows \u003cem\u003e(dùng công cụ \u003cstrong\u003eC++ Builder\u003c/strong\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eApp này sẽ có chức năng là cập nhật dữ liệu cho database, kiểm tra hàng hóa \u003cem\u003e(số lượng, mã QR)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-raspberry-camera\"\u003e👉 Raspberry Camera\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục đích là ôn luyện lại về \u003cstrong\u003eC++\u003c/strong\u003e cũng như đào sâu hơn về \u003cstrong\u003eNhúng Linux\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCó thể mình sẽ chia dự án này thành các phần:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eHardwar\nOS\nFirmware/Software\nPlatform\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eHardware: Raspberry Zero 2W + Camera for Pi.\u003c/li\u003e\n\u003cli\u003eOS: Yocto Linux\u003c/li\u003e\n\u003cli\u003eFirmware/Sofware:\n\u003cul\u003e\n\u003cli\u003eWeb Application:\n\u003cul\u003e\n\u003cli\u003eDHCP Server: Xem video ở local\u003c/li\u003e\n\u003cli\u003eDHCP Client: Kết nối mạng, send location data, Notifi Telegram.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDesktop Application: Config device\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePlatform: Lấy thông tin location, Update OTA, Image của camera.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNgoài ra mình sẽ code camera này theo \u003cstrong\u003eONVIF Protocol\u003c/strong\u003e, và theo \u003ca href=\"https://sotttt.angiang.gov.vn/sites/default/files/2025-01/qcvn%20135.2024-%20ip%20camera.pdf\"\u003eQCVN-135\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"-bad-usb\"\u003e👉 Bad USB\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục đích là để \u003cstrong\u003etrau dồi kỹ năng coding dùng ngôn ngữ Rust, và ứng dụng vào Red-Team\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eỞ đây mình dự định sẽ dùng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRaspberry Pico + Rust-lang + Embassy Framewok\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/others/y_tuong_project/",
      "date_published": "26026-26-09T252:2626:00+07:00",
      "date_modified": "26026-26-09T252:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "ffd246c4a4fc5e829bdbcbe79b2b069658e33707",
      "title": "Virtual_System",
      "summary": "",
      "content_text": "Lụm được bài viết 10 Virtualization Systems You Should Know\n",
      "content_html": "\u003cp\u003eLụm được bài viết \u003ca href=\"https://www.threads.net/@anastasis_king/post/DE-XeORssNx\"\u003e10 Virtualization Systems You Should Know\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_3.jfif\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_8.jpg\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_9.jpg\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_10.jpg\"\n  alt=\"Hình 10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/virtual_system/",
      "date_published": "10026-10-09T22:1010:00+07:00",
      "date_modified": "10026-10-09T22:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "ec78fc6e5f39ffda9be97974fa1cf6163f36f2af",
      "title": "RAID",
      "summary": "",
      "content_text": "Tham khảo video: Khái niệm về RAID RAID (Redundant Array of Independent/Inexpensive Disks) là một công nghệ lưu trữ dữ liệu cho phép kết hợp nhiều ổ đĩa cứng để tăng hiệu suất hoặc tạo khả năng chịu lỗi (fault tolerance).\nMột số cấp độ RAID phổ biến: RAID 0 (thường gọi là Striping): Ưu điểm của raid 0 chính là khả năng gộp ổ đĩa và có tốc độ đọc/ghi cao. Nhược điểm chính là dễ mất dữ liệu nếu ổ cứng bị hư. RAID 1 (thường gọi là Mirroring): Ưu điểm chính là về mặt an toàn dữ liệu. Nhược điểm là tốn tài nguyên của ổ cứng (vì cần phân vùng để lưu trữ backup). RAID 5 - Ít nhất phải có từ 3 ổ cứng trở lên RAID 5 có thể chịu được sự hỏng hóc của một ổ đĩa (Tức là trong 3 ổ, nếu có 1 ổ bị hỏng thì hệ thống vẫn hoạt động bình thường và vẫn đảm bảo về mặt an toàn dữ liệu). RAID 5 hoạt động tốt trong các ứng dụng chẳng hạn như hệ thống lưu trữ tập tin, máy chủ cơ sở dữ liệu, hoặc hệ thống lưu trữ tệp doanh nghiệp. RAID 6 RAID 6 là sự cải tiến từ RAID 5, sử dụng ít nhất là 4 ổ đĩa. Chịu được hỏng hóc của hai ổ đĩa. RAID 10 - Cần ít nhất 4 ổ đĩa. RAID 10 là dung hòa giữa RAID 0 và RAID 1. RAID 10 là lựa chọn lý tưởng trong các tình huống cần sự cân bằng giữa hiệu suất và độ an toàn dữ liệu. Bảng so sánh ",
      "content_html": "\u003ch2 id=\"tham-khảo-video-khái-niệm-về-raidhttpswwwyoutubecomwatchvi9kbfiswxpclistwlindex6\"\u003eTham khảo video: \u003ca href=\"https://www.youtube.com/watch?v=i9KbFISWXPc\u0026amp;list=WL\u0026amp;index=6\"\u003eKhái niệm về RAID\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eRAID (Redundant Array of Independent/Inexpensive Disks)\u003c/strong\u003e là một công nghệ lưu trữ dữ liệu cho phép kết hợp nhiều ổ đĩa cứng để tăng hiệu suất hoặc tạo khả năng chịu lỗi (fault tolerance).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"một-số-cấp-độ-raid-phổ-biến\"\u003eMột số cấp độ RAID phổ biến:\u003c/h2\u003e\n\u003ch3 id=\"raid-0-thường-gọi-là-striping\"\u003eRAID 0 \u003cem\u003e(thường gọi là Striping)\u003c/em\u003e:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eƯu điểm của \u003cstrong\u003eraid 0\u003c/strong\u003e chính là khả năng \u003cstrong\u003egộp ổ đĩa\u003c/strong\u003e và có tốc độ đọc/ghi cao.\u003c/li\u003e\n\u003cli\u003eNhược điểm chính là \u003cstrong\u003edễ mất dữ liệu\u003c/strong\u003e nếu ổ cứng bị hư.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-1-thường-gọi-là-mirroring\"\u003eRAID 1 \u003cem\u003e(thường gọi là Mirroring)\u003c/em\u003e:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eƯu điểm chính là về mặt \u003cstrong\u003ean toàn dữ liệu\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhược điểm là tốn tài nguyên của ổ cứng \u003cem\u003e(vì cần phân vùng để lưu trữ backup)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-5---ít-nhất-phải-có-từ-3-ổ-cứng-trở-lên\"\u003eRAID 5 - Ít nhất phải có từ 3 ổ cứng trở lên\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRAID 5 có thể chịu được sự hỏng hóc của một ổ đĩa \u003cem\u003e(Tức là trong 3 ổ, nếu có 1 ổ bị hỏng thì hệ thống vẫn hoạt động bình thường và vẫn đảm bảo về mặt an toàn dữ liệu)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eRAID 5 hoạt động tốt trong các ứng dụng chẳng hạn như hệ thống lưu trữ tập tin, máy chủ cơ sở dữ liệu, hoặc hệ thống lưu trữ tệp doanh nghiệp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-6\"\u003eRAID 6\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRAID 6\u003c/strong\u003e là sự cải tiến từ RAID 5, sử dụng ít nhất là 4 ổ đĩa.\u003c/li\u003e\n\u003cli\u003eChịu được hỏng hóc của hai ổ đĩa.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-10---cần-ít-nhất-4-ổ-đĩa\"\u003eRAID 10 - Cần ít nhất 4 ổ đĩa.\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRAID 10\u003c/strong\u003e là dung hòa giữa \u003cstrong\u003eRAID 0\u003c/strong\u003e và \u003cstrong\u003eRAID 1\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eRAID 10 là lựa chọn lý tưởng trong các tình huống cần sự cân bằng giữa hiệu suất và độ an toàn dữ liệu.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"bảng-so-sánh\"\u003eBảng so sánh\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/raid/",
      "date_published": "19016-19-09T146:1919:00+07:00",
      "date_modified": "19016-19-09T146:1919:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "23c06c85c6412d587b545bb756a83d0054681b2b",
      "title": "Desktop_App",
      "summary": "",
      "content_text": "Trong việc viết một desktop app thì có rất nhiều xu hướng, có thể dùng C#, C++ hoặc Rust.\nMình có tham khảo về việc dùng Rust để viết Desktop App. Rust Desktop app docs Framework mình tham khảo là Tauri:\nhttps://tauri.app/ https://www.twilio.com/en-us/blog/build-a-cross-platform-desktop-application-with-rust-using-tauri https://v1.tauri.app/v1/guides/getting-started/setup/ Tuy nhiên có thể mình sẽ chọn C++ để viết app. Lý do:\nThứ 1: Mình không muốn quên đi cách dùng ngôn ngữ C++ (nếu lâu quá không dùng thì sẽ dẫn đến quên). Thứ 2: Mình đã có khoảng thời gian gần 1 tháng tìm hiểu về một công cụ tên là C++ Builder, mình thấy công cụ này khá hay, và đáp ứng đc lý do thứ 1. (Ngoài ra mình cũng không muốn lãng phí 1 tháng đó. =]]). C++ Builder: https://blogs.embarcadero.com/everything-you-need-to-create-windows-apps-with-c/ https://devblogs.microsoft.com/cppblog/windows-desktop-development-with-c-in-visual-studio/ Theo mình tìm hiểu thì công cụ C++ Builder giúp mình có thể phát triển nhanh một app dành cho Windows. Công cụ này hỗ trợ gần như tận răng cho developer. C++ Builder đại đa số các extension của nó đều trả phí, tất nhiên vẫn có free, tuy nhiên việc code sẽ khó khăn hơn. Mình thấy các app dành cho Windows sẽ vẫn có một vị trí nhất định, và mình đã thấy các ứng dụng IoT cho desktop app được ứng dụng trong đời sống. Ứng dụng giữ xe thông minh. Một app chạy trên Windows, kết nối với thiết bị đọc RFID, Camera,\u0026hellip; Tag thẻ để nhận diện, camera chụp ảnh,\u0026hellip; Ứng dụng quản lý hàng hóa Thiết bị quét mã vạch kết nối với PC, khi quét app sẽ kiểm tra trong database và gửi ra thông tin. Có thể kết hợp với loa thông báo. ",
      "content_html": "\u003cp\u003eTrong việc viết một desktop app thì có rất nhiều xu hướng, có thể dùng C#, C++ hoặc Rust.\u003c/p\u003e\n\u003cp\u003eMình có tham khảo về việc dùng Rust để viết Desktop App. \u003ca href=\"https://blog.logrocket.com/build-desktop-app-qt-rust/\"\u003eRust Desktop app docs\u003c/a\u003e\nFramework mình tham khảo là \u003cstrong\u003eTauri\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tauri.app/\nhttps://www.twilio.com/en-us/blog/build-a-cross-platform-desktop-application-with-rust-using-tauri\nhttps://v1.tauri.app/v1/guides/getting-started/setup/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTuy nhiên có thể mình sẽ chọn C++ để viết app. Lý do:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThứ 1: Mình không muốn quên đi cách dùng ngôn ngữ C++ \u003cem\u003e(nếu lâu quá không dùng thì sẽ dẫn đến quên)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eThứ 2: Mình đã có khoảng thời gian gần 1 tháng tìm hiểu về một công cụ tên là \u003cstrong\u003eC++ Builder\u003c/strong\u003e, mình thấy công cụ này khá hay, và đáp ứng đc lý do thứ 1. \u003cem\u003e(Ngoài ra mình cũng không muốn lãng phí 1 tháng đó. =]])\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"c-builder\"\u003eC++ Builder:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://blogs.embarcadero.com/everything-you-need-to-create-windows-apps-with-c/\nhttps://devblogs.microsoft.com/cppblog/windows-desktop-development-with-c-in-visual-studio/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTheo mình tìm hiểu thì công cụ \u003cstrong\u003eC++ Builder\u003c/strong\u003e giúp mình có thể phát triển \u003cstrong\u003enhanh\u003c/strong\u003e một app dành cho Windows. Công cụ này hỗ trợ gần như \u003cstrong\u003etận răng\u003c/strong\u003e cho developer.\u003c/li\u003e\n\u003cli\u003eC++ Builder đại đa số các extension của nó đều \u003cstrong\u003etrả phí\u003c/strong\u003e, tất nhiên vẫn có \u003cstrong\u003efree\u003c/strong\u003e, tuy nhiên việc code sẽ khó khăn hơn.\u003c/li\u003e\n\u003cli\u003eMình thấy các app dành cho Windows sẽ vẫn có một vị trí nhất định, và mình đã thấy các ứng dụng IoT cho desktop app được ứng dụng trong đời sống.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ứng-dụng-giữ-xe-thông-minh\"\u003eỨng dụng giữ xe thông minh.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột app chạy trên Windows, kết nối với thiết bị đọc RFID, Camera,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eTag thẻ để nhận diện, camera chụp ảnh,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ứng-dụng-quản-lý-hàng-hóa\"\u003eỨng dụng quản lý hàng hóa\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThiết bị quét mã vạch kết nối với PC, khi quét app sẽ kiểm tra trong database và gửi ra thông tin.\u003c/li\u003e\n\u003cli\u003eCó thể kết hợp với loa thông báo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://i0.wp.com/blogs.embarcadero.com/wp-content/uploads/2020/08/jljleH.jpg?resize=512%2C256\u0026amp;ssl=1\"\n  alt=\"C\u0026#43;\u0026#43; Builder\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/desktop_app/",
      "date_published": "18016-18-09T122:1818:00+07:00",
      "date_modified": "18016-18-09T122:1818:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a0581688a31b709ce24dc5881aa840791987b478",
      "title": "CyberSecurity_Small_Businesses",
      "summary": "",
      "content_text": "Tổng hợp tài liệu về An toàn thông tin cho doanh nghiệp nhỏ: https://www.ftc.gov/business-guidance/small-businesses https://www.ftc.gov/business-guidance/small-businesses/cybersecurity https://www.ftc.gov/business-guidance/small-businesses/cybersecurity/basics https://www.ftc.gov/business-guidance/small-businesses/protecting-small-businesses-cases ",
      "content_html": "\u003ch3 id=\"tổng-hợp-tài-liệu-về-an-toàn-thông-tin-cho-doanh-nghiệp-nhỏ\"\u003eTổng hợp tài liệu về An toàn thông tin cho doanh nghiệp nhỏ:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.ftc.gov/business-guidance/small-businesses\nhttps://www.ftc.gov/business-guidance/small-businesses/cybersecurity\nhttps://www.ftc.gov/business-guidance/small-businesses/cybersecurity/basics\nhttps://www.ftc.gov/business-guidance/small-businesses/protecting-small-businesses-cases\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_8.jpg\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_9.jpg\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_10.jpg\"\n  alt=\"Hình 10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_11.jpg\"\n  alt=\"Hình 11\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_12.jpg\"\n  alt=\"Hình 12\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_13.jpg\"\n  alt=\"Hình 13\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_14.jpg\"\n  alt=\"Hình 14\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_15.jpg\"\n  alt=\"Hình 15\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_16.jpg\"\n  alt=\"Hình 16\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_17.jpg\"\n  alt=\"Hình 17\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_18.jpg\"\n  alt=\"Hình 18\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_19.jpg\"\n  alt=\"Hình 19\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_20.jpg\"\n  alt=\"Hình 20\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_21.jpg\"\n  alt=\"Hình 21\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_22.jpg\"\n  alt=\"Hình 22\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_23.jpg\"\n  alt=\"Hình 23\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_24.jpg\"\n  alt=\"Hình 24\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/cybersecurity_small_businesses/",
      "date_published": "17016-17-09T121:1717:00+07:00",
      "date_modified": "17016-17-09T121:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4a57b11d43630c5780b931bd58155e3637932a52",
      "title": "N8n",
      "summary": "",
      "content_text": "Giới thiệu n8n n8n là một công cụ tự động hóa luồng công việc (workflow automation) mã nguồn mở. Nó cho phép người dùng tạo ra các luồng công việc tự động bằng cách kết nối các ứng dụng, dịch vụ và API khác nhau mà không cần viết code. n8n phù hợp để tự động hóa các quy trình kinh doanh, quản lý dữ liệu và tích hợp ứng dụng. Ví dụ về Tự động hóa phát triển phần mềm: Tích hợp CI/CD: Khi có commit mới trên GitHub, n8n có thể kích hoạt một quy trình CI/CD trên Jenkins hoặc GitLab. Thông báo lỗi: Khi có lỗi xảy ra trong ứng dụng (được ghi nhận qua Sentry), n8n có thể gửi thông báo tới đội phát triển qua Slack. Một số bài viết về n8n: https://wiki.matbao.net/top-3-cong-nghe-ai-giup-tu-dong-hoa-quy-trinh-lam-viec-hieu-qua/ https://viblo.asia/p/gioi-thieu-n8n-nodes-chatwork-L4x5x3JblBM https://www.youtube.com/watch?v=oqNWwiFKAj0 Tham khảo tài liệu: Free versions: A free self-hosted community edition for self-hosted users Docker Installation: https://docs.n8n.io/hosting/installation/docker/ Build AI functionality using n8n: https://docs.n8n.io/advanced-ai/#related-resources https://docs.n8n.io/hosting/starter-kits/ai-starter-kit/ Install n8n on server super fast with only 1 command - AI Noodles Dựa theo video và tài liệu về n8n, thì có thể dùng n8n + AI để thực hiện các tác vụ nâng cao về automation. và trong video thì sử dụng LocalAI Install LocalAI: https://localai.io/basics/container/ https://localai.io/basics/build/ Enrich security incident tickets\n",
      "content_html": "\u003ch2 id=\"giới-thiệu-n8n\"\u003eGiới thiệu n8n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003en8n\u003c/strong\u003e là một công cụ \u003cstrong\u003etự động hóa luồng công việc\u003c/strong\u003e \u003cem\u003e(workflow automation)\u003c/em\u003e mã nguồn mở.\u003c/li\u003e\n\u003cli\u003eNó cho phép người dùng tạo ra các luồng công việc tự động bằng cách kết nối các ứng dụng, dịch vụ và API khác nhau mà không cần viết code.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003en8n\u003c/strong\u003e phù hợp để tự động hóa các quy trình kinh doanh, quản lý dữ liệu và tích hợp ứng dụng.\u003c/li\u003e\n\u003cli\u003eVí dụ về \u003cstrong\u003eTự động hóa phát triển phần mềm\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTích hợp CI/CD\u003c/strong\u003e: Khi có commit mới trên GitHub, n8n có thể kích hoạt một quy trình CI/CD trên Jenkins hoặc GitLab.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eThông báo lỗi\u003c/strong\u003e: Khi có lỗi xảy ra trong ứng dụng (được ghi nhận qua Sentry), n8n có thể gửi thông báo tới đội phát triển qua Slack.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMột số bài viết về \u003cstrong\u003en8n\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://wiki.matbao.net/top-3-cong-nghe-ai-giup-tu-dong-hoa-quy-trinh-lam-viec-hieu-qua/\nhttps://viblo.asia/p/gioi-thieu-n8n-nodes-chatwork-L4x5x3JblBM\nhttps://www.youtube.com/watch?v=oqNWwiFKAj0\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tham-khảo-tài-liệu\"\u003eTham khảo tài liệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.n8n.io/choose-n8n/#licenses\"\u003eFree versions\u003c/a\u003e: A free self-hosted community edition for self-hosted users\u003c/li\u003e\n\u003cli\u003eDocker Installation: \u003ca href=\"https://docs.n8n.io/hosting/installation/docker/\"\u003ehttps://docs.n8n.io/hosting/installation/docker/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eBuild AI functionality using n8n:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://docs.n8n.io/advanced-ai/#related-resources\nhttps://docs.n8n.io/hosting/starter-kits/ai-starter-kit/\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"install-n8n-on-server-super-fast-with-only-1-command---ai-noodleshttpswwwyoutubecomwatchvoflygnmskoq\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=OfLYgNmsKoQ\"\u003eInstall n8n on server super fast with only 1 command - AI Noodles\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa theo video và tài liệu về n8n, thì có thể dùng \u003cstrong\u003en8n + AI\u003c/strong\u003e để thực hiện các tác vụ nâng cao về automation.\u003c/li\u003e\n\u003cli\u003evà trong video thì sử dụng \u003ca href=\"https://localai.io/\"\u003eLocalAI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eInstall LocalAI:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://localai.io/basics/container/\nhttps://localai.io/basics/build/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEnrich security incident tickets\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://n8niostorageaccount.blob.core.windows.net/n8nio-strapi-blobs-prod/assets/secops_usecase_4c6aaad973.png\"\n  alt=\"n8n - SecOps\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/n8n/",
      "date_published": "17016-17-09T159:1717:00+07:00",
      "date_modified": "17016-17-09T159:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "619c010a490e554688b4fda9b97f007486f52708",
      "title": "Tailscale",
      "summary": "",
      "content_text": "Video: 3 Best Remote Access Methods for Your Homelab Revealed! Sau khi xem xong video này, mình thấy có một thông tin khá hay. Đó là về giải pháp VPN Tailscale Tailscale Tailscale một giải pháp VPN thay thế cho các kiểu VPN truyền thống. Mình có thể sử dụng Tailscale cho cá nhân (và nó free). Với bản free thì mình có thể add tối đa là 100 devices và giới hạn ở 3 account (dạng như là tạo các account con và phần quyền) Mình thấy Tailscale này có nét giống với ngrok và raspberry connect, tất nhiên là mục đích 2 công cụ này là khác nhau và ngrok thì bị giới hạn về số lượng thiết bị. Documents của Tailscale: https://tailscale.com/kb/1017/install https://tailscale.com/use-cases/homelab Một bài viết khác về Tailscale: https://thuanbui.me/tailscale-vpn/ Note Hiện tại thì mình đang dùng giải pháp VPN truyền thống (Fortigate VPN) và Jump-Server (Teleport). Nên giải pháp Tailscale mang tính chất tham khảo, cái này mình thấy cũng khá hay, biết đâu sau này lại có thể áp dụng vào đâu đó. How Tailscale works ",
      "content_html": "\u003ch3 id=\"video-3-best-remote-access-methods-for-your-homelab-revealedhttpswwwyoutubecomwatchvxmktcfb5vselistwlindex4t2s\"\u003eVideo: \u003ca href=\"https://www.youtube.com/watch?v=XMKTCFB5VsE\u0026amp;list=WL\u0026amp;index=4\u0026amp;t=2s\"\u003e3 Best Remote Access Methods for Your Homelab Revealed!\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi xem xong video này, mình thấy có một thông tin khá hay.\u003c/li\u003e\n\u003cli\u003eĐó là về giải pháp VPN \u003cstrong\u003eTailscale\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tailscalehttpstailscalecom\"\u003e\u003ca href=\"https://tailscale.com/\"\u003eTailscale\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTailscale một giải pháp VPN thay thế cho các kiểu \u003cem\u003eVPN truyền thống\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eMình có thể sử dụng Tailscale cho cá nhân \u003cem\u003e(và nó \u003cstrong\u003efree\u003c/strong\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eVới bản free thì mình có thể add tối đa là \u003cstrong\u003e100 devices\u003c/strong\u003e và giới hạn ở \u003cstrong\u003e3 account\u003c/strong\u003e \u003cem\u003e(dạng như là tạo các account con và phần quyền)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eMình thấy Tailscale này có nét giống với \u003cstrong\u003engrok\u003c/strong\u003e và \u003cstrong\u003eraspberry connect\u003c/strong\u003e, tất nhiên là mục đích 2 công cụ này là khác nhau và ngrok thì bị giới hạn về số lượng thiết bị.\u003c/li\u003e\n\u003cli\u003eDocuments của Tailscale:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tailscale.com/kb/1017/install\nhttps://tailscale.com/use-cases/homelab\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eMột bài viết khác về \u003cstrong\u003eTailscale\u003c/strong\u003e: \u003ca href=\"https://thuanbui.me/tailscale-vpn/\"\u003ehttps://thuanbui.me/tailscale-vpn/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiện tại thì mình đang dùng giải pháp VPN truyền thống \u003cem\u003e(Fortigate VPN)\u003c/em\u003e và Jump-Server \u003cem\u003e(Teleport)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eNên giải pháp \u003cstrong\u003eTailscale\u003c/strong\u003e mang tính chất tham khảo, cái này mình thấy cũng khá hay, biết đâu sau này lại có thể áp dụng vào đâu đó.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"how-tailscale-works\"\u003eHow Tailscale works\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://cdn.sanity.io/images/w77i7m8x/production/dbba97845c1ad1955669cc6a84c94f9d5fb78ade-1600x1080.svg?w=1920\u0026amp;q=75\u0026amp;fit=clip\u0026amp;auto=format\"\n  alt=\"Tailscale\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/tailscale/",
      "date_published": "17016-17-09T142:1717:00+07:00",
      "date_modified": "17016-17-09T142:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "78793621d7815d3fbfd1c0eb90c9aeed3088d9c5",
      "title": "OpenMediaVault",
      "summary": "",
      "content_text": "History STT Create Description 1 30/11/2024 Tạo nội dung về OMV. 2 28/12/2024 Thêm nội dung về một NAS OS - HexOS OpenMediaVault (OMV) Là một hệ điều hành mã nguồn mở được thiết kế đặc biệt để triển khai hệ thống lưu trữ mạng (Network Attached Storage - NAS). Dựa trên hệ điều hành Debian Linux, OMV cung cấp một giao diện web thân thiện để quản lý, cấu hình và vận hành các dịch vụ lưu trữ dữ liệu. Lưu ý là hiện tại OMV không hỗ trợ trên Ubuntu được. Ngoài ra mình cũng có thể cài OMV trên Raspberry. Download file ISO Documents: https://computingforgeeks.com/install-and-configure-openmediavault-nas-storage-server/#google_vignette https://pakstech.com/blog/openmediavault-proxmox/ https://www.youtube.com/watch?v=Bce7VT3kJ4g https://longervision.github.io/2024/08/08/OperatingSystems/RaspberryPi/openmediavault-nas/ https://github.com/openmediavault/openmediavault https://www.openmediavault.org/ https://linuxconfig.org/how-to-install-openmediavault-on-raspberry-pi https://www.the-diy-life.com/i-built-a-4-bay-raspberry-pi-5-based-nas/ My Dashboard OMV\nCập nhật ngày 28/12/2024 HexOS Đây là một OS dành cho việc lưu trữ, một OS dành cho NAS-Server. HexOS này được xây dựng dựa trên TrueNAS, và cũng là một dạng open-source. Storage, streaming, virtual machines and more. Create a secure, private server you can manage from anywhere with HexOS.\nTài liệu tham khảo và video: Home Servers Might Never Be The Same\u0026hellip; HexOS Is Here https://hexos.com/blog/the-magic-behind-hexos https://nascompares.com/2024/12/02/hexos-nas-software-review-of-the-beta/ Video so sánh: Best NAS Software: TrueNAS vs OpenMediaVault vs Unraid ",
      "content_html": "\u003ch2 id=\"history\"\u003eHistory\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eSTT\u003c/th\u003e\n\u003cth\u003eCreate\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e30/11/2024\u003c/td\u003e\n\u003ctd\u003eTạo nội dung về \u003cstrong\u003eOMV\u003c/strong\u003e.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e28/12/2024\u003c/td\u003e\n\u003ctd\u003eThêm nội dung về một NAS OS - \u003cstrong\u003eHexOS\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"openmediavault-omvhttpswwwopenmediavaultorg\"\u003e\u003ca href=\"https://www.openmediavault.org/\"\u003eOpenMediaVault (OMV)\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLà một hệ điều hành mã nguồn mở được thiết kế đặc biệt để triển khai hệ thống lưu trữ mạng (Network Attached Storage - NAS).\u003c/li\u003e\n\u003cli\u003eDựa trên hệ điều hành \u003cstrong\u003eDebian Linux\u003c/strong\u003e, OMV cung cấp một giao diện web thân thiện để quản lý, cấu hình và vận hành các dịch vụ lưu trữ dữ liệu.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLưu ý là hiện tại \u003cstrong\u003eOMV\u003c/strong\u003e không hỗ trợ trên Ubuntu được. \u003c/br\u003e\nNgoài ra mình cũng có thể cài OMV trên \u003cstrong\u003eRaspberry\u003c/strong\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"download-file-isohttpswwwopenmediavaultorgdownloadhtml\"\u003e\u003ca href=\"https://www.openmediavault.org/download.html\"\u003eDownload file ISO\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"documents\"\u003eDocuments:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://computingforgeeks.com/install-and-configure-openmediavault-nas-storage-server/#google_vignette\"\u003ehttps://computingforgeeks.com/install-and-configure-openmediavault-nas-storage-server/#google_vignette\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pakstech.com/blog/openmediavault-proxmox/\"\u003ehttps://pakstech.com/blog/openmediavault-proxmox/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=Bce7VT3kJ4g\"\u003ehttps://www.youtube.com/watch?v=Bce7VT3kJ4g\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://longervision.github.io/2024/08/08/OperatingSystems/RaspberryPi/openmediavault-nas/\"\u003ehttps://longervision.github.io/2024/08/08/OperatingSystems/RaspberryPi/openmediavault-nas/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/openmediavault/openmediavault\"\u003ehttps://github.com/openmediavault/openmediavault\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.openmediavault.org/\"\u003ehttps://www.openmediavault.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://linuxconfig.org/how-to-install-openmediavault-on-raspberry-pi\"\u003ehttps://linuxconfig.org/how-to-install-openmediavault-on-raspberry-pi\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.the-diy-life.com/i-built-a-4-bay-raspberry-pi-5-based-nas/\"\u003ehttps://www.the-diy-life.com/i-built-a-4-bay-raspberry-pi-5-based-nas/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMy Dashboard OMV\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/NAS_Server/Dashboard_OMV.png\"\n  alt=\"OMV\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-ngày-28122024\"\u003eCập nhật ngày 28/12/2024\u003c/h2\u003e\n\u003ch3 id=\"hexos\"\u003eHexOS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một OS dành cho việc lưu trữ, một OS dành cho NAS-Server. HexOS này được xây dựng dựa trên \u003cstrong\u003eTrueNAS\u003c/strong\u003e, và cũng là một dạng open-source.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eStorage, streaming, virtual machines and more. \u003c/br\u003e\nCreate a secure, private server you can manage from anywhere with HexOS.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/NAS_Server/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo-và-video\"\u003eTài liệu tham khảo và video:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=AfRZuZ6G1SM\"\u003eHome Servers Might Never Be The Same\u0026hellip; HexOS Is Here\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://hexos.com/blog/the-magic-behind-hexos\"\u003ehttps://hexos.com/blog/the-magic-behind-hexos\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nascompares.com/2024/12/02/hexos-nas-software-review-of-the-beta/\"\u003ehttps://nascompares.com/2024/12/02/hexos-nas-software-review-of-the-beta/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"video-so-sánh-best-nas-software-truenas-vs-openmediavault-vs-unraidhttpswwwyoutubecomwatchvxngpayc2iau\"\u003eVideo so sánh: \u003ca href=\"https://www.youtube.com/watch?v=xNGPAyC2iaU\"\u003eBest NAS Software: TrueNAS vs OpenMediaVault vs Unraid\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/NAS_Server/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/openmediavault/",
      "date_published": "28126-28-09T1238:2828:00+07:00",
      "date_modified": "28126-28-09T1238:2828:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7c7d735238dc0f4aee07cc79500aed744f63b4c5",
      "title": "ClamAV",
      "summary": "",
      "content_text": " ClamAV là một công cụ open-source, theo tài liệu thì có thể cài đặt trên nhiều OS từ Windows cho đến Linux. Tuy nhiên mình thấy trên Win đã có Windows Defender rất mạnh mẽ rồi. Hiện tại các công cụ Endpoint mình đang dùng bao gồm: Antivirus: Windows Defender, ClamAV (sẽ dùng trong tương lai gần) XDR: Wazuh Agent EDR: Aurora Agent ClamAV + Wazuh, powerful Anti-Virus protection for Linux Công cụ này sẽ thực sự hữu ích và phát huy tác dụng mạnh trên Linux. Giống như trong video có giới thiệu, việc kết hợp giữa ClamAV + Wazuh sẽ giúp mình monitor và phản ứng kịp thời các tác nhân gây hại đến server. Documentation https://github.com/Cisco-Talos/clamav https://docs.clamav.net/ https://www.clamav.net/downloads ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eClamAV là một công cụ open-source, theo tài liệu thì có thể cài đặt trên nhiều OS từ Windows cho đến Linux.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/ClamAV/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTuy nhiên mình thấy trên Win đã có \u003cstrong\u003eWindows Defender\u003c/strong\u003e rất mạnh mẽ rồi.\u003c/li\u003e\n\u003cli\u003eHiện tại các công cụ \u003cstrong\u003eEndpoint\u003c/strong\u003e mình đang dùng bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eAntivirus\u003c/strong\u003e: Windows Defender, ClamAV \u003cem\u003e(sẽ dùng trong tương lai gần)\u003c/em\u003e \u003c/br\u003e\n\u003cstrong\u003eXDR\u003c/strong\u003e: Wazuh Agent \u003c/br\u003e\n\u003cstrong\u003eEDR\u003c/strong\u003e: Aurora Agent \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"clamav--wazuh-powerful-anti-virus-protection-for-linuxhttpswwwyoutubecomwatchv9e45tq61h14\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=9e45TQ61H14\"\u003eClamAV + Wazuh, powerful Anti-Virus protection for Linux\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này sẽ thực sự hữu ích và phát huy tác dụng mạnh trên Linux.\u003c/li\u003e\n\u003cli\u003eGiống như trong video có giới thiệu, việc kết hợp giữa \u003cstrong\u003eClamAV + Wazuh\u003c/strong\u003e sẽ giúp mình monitor và phản ứng kịp thời các tác nhân gây hại đến server.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/ClamAV/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"documentation\"\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Cisco-Talos/clamav\"\u003ehttps://github.com/Cisco-Talos/clamav\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.clamav.net/\"\u003ehttps://docs.clamav.net/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.clamav.net/downloads\"\u003ehttps://www.clamav.net/downloads\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/clamav/",
      "date_published": "30116-30-09T1120:3030:00+07:00",
      "date_modified": "30116-30-09T1120:3030:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4ad146984946ab4ae6ecd241e37735fd7ae01a94",
      "title": "Huly",
      "summary": "",
      "content_text": "Một platform open-source quản lý dự án.\nCó các tính năng như:\nJira Meeting, chat Và documents như Notion Nếu như không muốn bỏ quá nhiều chi phí cho các nền tảng trả phí, thì có thể tham khảo để tự host Huly này để xài.\nTài liệu: https://docs.huly.io/getting-started/introduction-huly/ https://huly.io/ https://github.com/hcengineering/platform ",
      "content_html": "\u003cp\u003eMột platform open-source quản lý dự án.\u003c/p\u003e\n\u003cp\u003eCó các tính năng như:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJira\u003c/li\u003e\n\u003cli\u003eMeeting, chat\u003c/li\u003e\n\u003cli\u003eVà documents như Notion\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNếu như không muốn bỏ quá nhiều chi phí cho các nền tảng trả phí, thì có thể tham khảo để tự host \u003cstrong\u003eHuly\u003c/strong\u003e này để xài.\u003c/p\u003e\n\u003ch3 id=\"tài-liệu\"\u003eTài liệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.huly.io/getting-started/introduction-huly/\"\u003ehttps://docs.huly.io/getting-started/introduction-huly/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huly.io/\"\u003ehttps://huly.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/hcengineering/platform\"\u003ehttps://github.com/hcengineering/platform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/huly/",
      "date_published": "17116-17-09T1145:1717:00+07:00",
      "date_modified": "17116-17-09T1145:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "dcda9882e36876d12b63310331edb055fc9f5a92",
      "title": "Permission_Linux",
      "summary": "",
      "content_text": "Ghi chú về Permission trong linux.\nVideo: DevOps for Freshers | Bài 7: Quyền truy cập trong Linux | DevOps cho người mới bắt đầu Phân quyền - Permission Theo như trong video thì phân quyền sẽ có: Chủ sở hữu (u) - Nhóm sở hữu (g) - Nhóm khác (o) Muốn thay đổi quyền sở hữu (của tất cả tập tin có trong thư mục) thì dùng lệnh: sudo chown -R \u0026lt;chu_so_huu\u0026gt;:\u0026lt;nhom_so_huu\u0026gt; \u0026lt;folder_name\u0026gt; Mỗi nhóm sẽ đều có các quyền tác động khác nhau. Quyền tác động: read (4) - write (2) - execute (1) Câu lệnh để thay đổi đổi một quyền tác động của 1 file, ví dụ: sudo chmod 750 \u0026lt;file_name\u0026gt; Với 750 cho \u0026lt;file_name\u0026gt;, tức là file này: Có quyền r,w,e \u0026ndash;\u0026gt; Chủ sở hữu file Có quyền r,e \u0026ndash;\u0026gt; Nhóm sở hữu file Không có quyền thao tác trên file này đối với nhóm khác ",
      "content_html": "\u003cp\u003eGhi chú về \u003cstrong\u003ePermission trong linux\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"video-devops-for-freshers--bài-7-quyền-truy-cập-trong-linux--devops-cho-người-mới-bắt-đầuhttpswwwyoutubecomwatchvu5oufnvomt4listplsvroivfnp1ku8fouecc-hbjbqnaggwl2index8\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=U5Oufnvomt4\u0026amp;list=PLsvroIvFNP1KU8foUeCC-hbJbqnAggWL2\u0026amp;index=8\"\u003eVideo: DevOps for Freshers | Bài 7: Quyền truy cập trong Linux | DevOps cho người mới bắt đầu\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Permission_Linux/Permission.png\"\n  alt=\"Permission\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"phân-quyền---permission\"\u003ePhân quyền - Permission\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo như trong video thì phân quyền sẽ có:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eChủ sở hữu (u) - Nhóm sở hữu (g) - Nhóm khác (o)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eMuốn thay đổi quyền sở hữu (của tất cả tập tin có trong thư mục) thì dùng lệnh:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo chown -R \u0026lt;chu_so_huu\u0026gt;:\u0026lt;nhom_so_huu\u0026gt; \u0026lt;folder_name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eMỗi nhóm sẽ đều có các quyền tác động khác nhau.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"quyền-tác-động\"\u003eQuyền tác động:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eread (4) - write (2) - execute (1)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCâu lệnh để thay đổi đổi một quyền tác động của 1 file, ví dụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo chmod 750 \u0026lt;file_name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eVới \u003cstrong\u003e750\u003c/strong\u003e cho \u003ccode\u003e\u0026lt;file_name\u0026gt;\u003c/code\u003e, tức là file này:\n\u003cul\u003e\n\u003cli\u003eCó quyền \u003cstrong\u003er,w,e\u003c/strong\u003e \u0026ndash;\u0026gt; Chủ sở hữu file\u003c/li\u003e\n\u003cli\u003eCó quyền \u003cstrong\u003er,e\u003c/strong\u003e \u0026ndash;\u0026gt; Nhóm sở hữu file\u003c/li\u003e\n\u003cli\u003eKhông có quyền thao tác trên file này đối với nhóm khác\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Permission_Linux/Linux_File_Cheatsheet.jfif\"\n  alt=\"Cheatsheet\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/permission_linux/",
      "date_published": "17116-17-09T1139:1717:00+07:00",
      "date_modified": "17116-17-09T1139:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8952986493d99062e799e181787175b42c8ffafe",
      "title": "Kien_truc_may_tinh",
      "summary": "",
      "content_text": " Ngày Mô tả 27/8/2024 Khởi tạo bài viết 17/11/2024 Update thêm từ video ARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn? Kiển trúc Máy tính Kiến trúc máy tính - Von-Neumann Được chia làm 3 phần chính: CPU Memory IO Cả 3 thành phần này đều giao tiếp với nhau thông qua bus (gọi là data bus) kiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing) Sự khác biệt giữa kiến trúc Harvard vs Von-Neumann đó chính là sự bố trí giữa CPU - Memory.\nKiến trúc chip x86 Architecture Thường thấy trong các sản phẩm máy tính desktop hoặc laptop. Phổ biến là dòng chip của Intel. RISC Architectures MIPS Architecture: KIẾN TRÚC BỘ LỆNH ARM Architecture: Tài liệu ARMarch Một bài viết so sánh giữa ARM vs x86 Data Bus Có 2 kiểu truyền dữ liệu là:\nNối tiếp (Serial) Song song (Parallel) Song song Dùng cho display (truyền hình ảnh), PCI, printer,\u0026hellip; Nối tiếp: Dùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,\u0026hellip; Giao tiếp nối tiếp thì chia làm 2 loại là: Giao tiếp bất đồng bộ: UART, RS232, RS485 Giao tiếp đồng bộ: SPI Cập nhật 17/11/2024 Youtube: ARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn?\nViệc ARM được dùng trên di động thì không có gì mới lạ, nhưng việc ARM sử dụng trên PC (theo như trong video của anh Luân) thì cái này mình mới biết.\nChip ARM được sinh ra để khắc phục nhược điểm của x86.\nTrong video anh Luân nói về việc tương thích phần mềm giữa x86 với ARM. Và mình cũng đã gặp phải một case như vậy. Ban đầu mình có viết một app nho nhỏ bằng ngôn ngữ Rust-lang, chạy trên Linux (Ubuntu) kiến trúc x86 AMD64. App chạy bình thường, sau đó sử dụng rust cross-compile để convert file chạy trên raspberry. Convert xong thì chạy ko đc. Mình nghi là các library đang dùng không support cho arm. =]] ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e27/8/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/11/2024\u003c/td\u003e\n\u003ctd\u003eUpdate thêm từ video \u003cstrong\u003eARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn?\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"kiển-trúc-máy-tính\"\u003eKiển trúc Máy tính\u003c/h2\u003e\n\u003ch3 id=\"kiến-trúc-máy-tính---von-neumannhttpswwwdigikeycomenmakerblogs2024von-neumann-architecture\"\u003e\u003ca href=\"https://www.digikey.com/en/maker/blogs/2024/von-neumann-architecture\"\u003eKiến trúc máy tính - Von-Neumann\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐược chia làm 3 phần chính:\n\u003cul\u003e\n\u003cli\u003eCPU\u003c/li\u003e\n\u003cli\u003eMemory\u003c/li\u003e\n\u003cli\u003eIO\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCả 3 thành phần này đều giao tiếp với nhau thông qua \u003cstrong\u003ebus\u003c/strong\u003e (gọi là \u003ccode\u003edata bus\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kiến-trúc-harvard-sử-dụng-rộng-rãi-trong-các-bộ-vi-điều-khiển-và-dsp-digital-signal-processing\"\u003ekiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing)\u003c/h3\u003e\n\u003cp\u003eSự khác biệt giữa kiến trúc \u003cstrong\u003eHarvard\u003c/strong\u003e vs \u003cstrong\u003eVon-Neumann\u003c/strong\u003e đó chính là sự bố trí giữa \u003cstrong\u003eCPU - Memory\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"kiến-trúc-chiphttpsinc42comglossarychip-architecture\"\u003e\u003ca href=\"https://inc42.com/glossary/chip-architecture/\"\u003eKiến trúc chip\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"x86-architecture\"\u003ex86 Architecture\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThường thấy trong các sản phẩm máy tính desktop hoặc laptop.\u003c/li\u003e\n\u003cli\u003ePhổ biến là dòng chip của \u003cstrong\u003eIntel\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"risc-architectures\"\u003eRISC Architectures\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMIPS Architecture: \u003ca href=\"https://www.cit.ctu.edu.vn/~dtnghi/cod/ch3.pdf\"\u003eKIẾN TRÚC BỘ LỆNH\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eARM Architecture:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.csie.ntu.edu.tw/~cyy/courses/assembly/12fall/lectures/handouts/lec08_ARMarch.pdf\"\u003eTài liệu ARMarch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.candtsolution.com/news_events-detail/what-is-the-difference-between-arm-and-x86/\"\u003eMột bài viết so sánh giữa ARM vs x86\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"data-bushttpswwwdigikeycomenmakertutorials2023what-is-serial-communication-and-how-does-it-compare-to-paralleltextwhats20the20difference20between20serialdata20that20can20be20transferred\"\u003e\u003ca href=\"https://www.digikey.com/en/maker/tutorials/2023/what-is-serial-communication-and-how-does-it-compare-to-parallel#:~:text=What's%20the%20Difference%20Between%20Serial,data%20that%20can%20be%20transferred\"\u003eData Bus\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCó 2 kiểu truyền dữ liệu là:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eNối tiếp (Serial)\nSong song (Parallel)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Kien_truc_may_tinh/Communicate.jpg\"\n  alt=\"Communicate\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"song-song\"\u003eSong song\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng cho display (truyền hình ảnh), PCI, printer,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nối-tiếp\"\u003eNối tiếp:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eGiao tiếp nối tiếp thì chia làm 2 loại là:\n\u003cul\u003e\n\u003cli\u003eGiao tiếp bất đồng bộ: UART, RS232, RS485\u003c/li\u003e\n\u003cli\u003eGiao tiếp đồng bộ: SPI\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-17112024\"\u003eCập nhật 17/11/2024\u003c/h2\u003e\n\u003cp\u003eYoutube: \u003ca href=\"https://www.youtube.com/watch?v=9zurhPRRXRM\"\u003eARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn?\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eViệc \u003cstrong\u003eARM\u003c/strong\u003e được dùng trên di động thì không có gì mới lạ, nhưng việc \u003cstrong\u003eARM sử dụng trên PC\u003c/strong\u003e \u003cem\u003e(theo như trong video của anh Luân)\u003c/em\u003e thì cái này mình mới biết.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Kien_truc_may_tinh/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eChip ARM được sinh ra để khắc phục nhược điểm của x86\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Kien_truc_may_tinh/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video anh Luân nói về việc tương thích phần mềm giữa \u003cstrong\u003ex86\u003c/strong\u003e với \u003cstrong\u003eARM\u003c/strong\u003e. Và mình cũng đã gặp phải một case như vậy.\u003c/li\u003e\n\u003cli\u003eBan đầu mình có viết một app nho nhỏ bằng ngôn ngữ \u003cstrong\u003eRust-lang\u003c/strong\u003e, chạy trên \u003cstrong\u003eLinux (Ubuntu) kiến trúc x86 AMD64\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eApp chạy bình thường, sau đó sử dụng \u003cstrong\u003erust cross-compile\u003c/strong\u003e để convert file chạy trên raspberry. Convert xong thì chạy ko đc.\u003c/li\u003e\n\u003cli\u003eMình nghi là các library đang dùng không support cho \u003cstrong\u003earm\u003c/strong\u003e. =]]\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/kien_truc_may_tinh/",
      "date_published": "17116-17-09T1111:1717:00+07:00",
      "date_modified": "17116-17-09T1111:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "f76f0d4ffc1fe7d93ee318f5333661e1fb4b243a",
      "title": "OBD2_PIDs",
      "summary": "",
      "content_text": "Xem thêm thông tin về CAN_OBDII\nTổng hợp tài liệu liên quan:\nCAN Bus Explained - A Simple Intro Wiki: OBDII PIDs OBD2 PID Overview OBD Diagnostic Trouble Code Converter \u0026amp; Lookup Tool Một tài liệu về sản phẩm tham khảo và thông tin về OBDII: OBD2 - Intro \u0026amp; Data Logger Guide DTC (Diagnostic Trouble Codes) DTC là các mã lỗi mà hệ thống chẩn đoán OBD-II tạo ra khi phát hiện vấn đề về hoạt động của xe. Chúng giúp xác định nguyên nhân của các sự cố liên quan đến hệ thống động cơ, khí thải, và các thành phần khác. PID (Parameter IDs) PID là các mã định danh tham số được sử dụng để yêu cầu và nhận dữ liệu từ các cảm biến và hệ thống khác nhau trên xe. Dữ liệu này giúp theo dõi tình trạng hoạt động của xe, chẳng hạn như tốc độ xe, tốc độ động cơ, nhiệt độ chất làm mát, v.v. DTC vs PIDs DTC để chẩn đoán lỗi. PID để giám sát dữ liệu. Ví dụ mình có dòng chip STN1110: Nếu cần lấy thông tin về xe thì mình dùng mã lệnh PID để gửi cho ECU, và nhận phản hồi từ ECU. Còn DTC (mã lỗi) thì xe sẽ tự động tạo ra mã lỗi này khi phát hiện vấn đề. Ví dụ, nếu xe của bạn gặp sự cố liên quan đến xi-lanh, ECU sẽ tạo ra mã lỗi P0301 và lưu trữ nó. khi bạn kết nối công cụ quét OBD-II (như STN1110) với cổng OBD-II của xe, công cụ này sẽ tự động đọc và hiển thị mã DTC mà ECU đã lưu trữ. Giới thiệu về STN1110 IC STN1110 là một OBD-II to UART interpreter IC (thiết bị trình dịch OBD-II sang UART) Thay vào đó, nó được sử dụng để chuyển đổi các thông điệp OBD-II thành các thông điệp UART, cho phép kết nối với các thiết bị khác như máy tính hoặc microcontroller thông qua giao tiếp UART. Nó hoạt động như một trung gian giúp truy xuất dữ liệu từ hệ thống OBD-II của xe, bao gồm các mã lỗi DTC, thông số hiệu suất, và nhiều thông tin khác. Để tạo ra một thiết bị tương tự như STN1110, bạn sẽ cần những thành phần cơ bản sau: MCU, CAN Controller, CAN Transceiver. Tham khảo Telematics Dashboards - Visualize CAN Data Dashboard này nhìn đẹp, rất hay ho, thật sự đáng nghiên cứu và học hỏi. Vừa kết hợp được những thông tin cơ bản lấy từ OBD2, vừa kết hợp với thông tin GPS của thiết bị tracking. Tổng hợp các lệnh PIDs thường dùng. Nhiệt độ làm mát (Engine Coolant Temperature - TMP) Tốc độ động cơ (Engine speed - RPM) Tốc độ phương tiện (Vehicle speed - SPD) Mass air flow sensor (MAF) Calculated engine load ",
      "content_html": "\u003cp\u003eXem thêm thông tin về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/hardware/can_obdii/\"\u003eCAN_OBDII\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTổng hợp tài liệu liên quan:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.csselectronics.com/pages/can-bus-simple-intro-tutorial\"\u003eCAN Bus Explained - A Simple Intro\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/OBD-II_PIDs\"\u003eWiki: OBDII PIDs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.csselectronics.com/pages/obd2-pid-table-on-board-diagnostics-j1979\"\u003eOBD2 PID Overview\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.csselectronics.com/pages/obd-trouble-code-dtc-lookup-converter-tool\"\u003eOBD Diagnostic Trouble Code Converter \u0026amp; Lookup Tool\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMột tài liệu về sản phẩm tham khảo và thông tin về OBDII: \u003ca href=\"/docs/OBD2_data_starter_pack.pdf\"\u003eOBD2 - Intro \u0026amp; Data Logger Guide\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"dtc-diagnostic-trouble-codes\"\u003eDTC (Diagnostic Trouble Codes)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDTC là \u003cstrong\u003ecác mã lỗi\u003c/strong\u003e mà hệ thống chẩn đoán OBD-II tạo ra khi phát hiện vấn đề về hoạt động của xe.\u003c/li\u003e\n\u003cli\u003eChúng giúp xác định nguyên nhân của các sự cố liên quan đến hệ thống động cơ, khí thải, và các thành phần khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pid-parameter-ids\"\u003ePID (Parameter IDs)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePID là \u003cstrong\u003ecác mã định danh tham số\u003c/strong\u003e được sử dụng để yêu cầu và nhận dữ liệu từ các cảm biến và hệ thống khác nhau trên xe.\u003c/li\u003e\n\u003cli\u003eDữ liệu này giúp theo dõi tình trạng hoạt động của xe, chẳng hạn như tốc độ xe, tốc độ động cơ, nhiệt độ chất làm mát, v.v.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"dtc-vs-pids\"\u003eDTC vs PIDs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDTC để chẩn đoán lỗi. PID để giám sát dữ liệu\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVí dụ mình có dòng chip \u003cstrong\u003eSTN1110\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNếu cần lấy thông tin về xe thì mình dùng mã lệnh PID để gửi cho ECU, và nhận phản hồi từ ECU. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCòn DTC (mã lỗi) thì xe sẽ \u003cstrong\u003etự động tạo ra mã lỗi\u003c/strong\u003e này khi phát hiện vấn đề. Ví dụ, nếu xe của bạn gặp sự cố liên quan đến xi-lanh, ECU sẽ tạo ra mã lỗi P0301 và lưu trữ nó. khi bạn kết nối công cụ quét OBD-II (như STN1110) với cổng OBD-II của xe, \u003cstrong\u003ecông cụ này sẽ tự động đọc và hiển thị mã DTC mà ECU đã lưu trữ\u003c/strong\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"giới-thiệu-về-stn1110httpswwwobdsolcomsolutionschipsstn1110formmg0av3\"\u003eGiới thiệu về \u003ca href=\"https://www.obdsol.com/solutions/chips/stn1110/?form=MG0AV3\"\u003eSTN1110\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIC STN1110 là một OBD-II to UART interpreter IC (thiết bị trình dịch OBD-II sang UART)\u003c/li\u003e\n\u003cli\u003eThay vào đó, nó được sử dụng để chuyển đổi các thông điệp OBD-II thành các thông điệp UART, cho phép kết nối với các thiết bị khác như máy tính hoặc microcontroller thông qua giao tiếp UART.\u003c/li\u003e\n\u003cli\u003eNó hoạt động như một trung gian giúp truy xuất dữ liệu từ hệ thống OBD-II của xe, bao gồm các mã lỗi DTC, thông số hiệu suất, và nhiều thông tin khác.\u003c/li\u003e\n\u003cli\u003eĐể tạo ra một thiết bị tương tự như STN1110, bạn sẽ cần những thành phần cơ bản sau: \u003ccode\u003eMCU\u003c/code\u003e, \u003ccode\u003eCAN Controller\u003c/code\u003e, \u003ccode\u003eCAN Transceiver\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"tham-khảo-telematics-dashboards---visualize-can-datahttpswwwcsselectronicscompagestelematics-dashboard-open-source\"\u003eTham khảo \u003ca href=\"https://www.csselectronics.com/pages/telematics-dashboard-open-source\"\u003eTelematics Dashboards - Visualize CAN Data\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/Sample_OBDII_Dashboard.webp\"\n  alt=\"Sample_OBDII_Dashboard\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDashboard này nhìn đẹp, rất hay ho, thật sự đáng nghiên cứu và học hỏi.\u003c/li\u003e\n\u003cli\u003eVừa kết hợp được những \u003cstrong\u003ethông tin cơ bản lấy từ OBD2\u003c/strong\u003e, vừa kết hợp với \u003cstrong\u003ethông tin GPS của thiết bị tracking\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tổng-hợp-các-lệnh-pids-thường-dùng\"\u003eTổng hợp các lệnh PIDs thường dùng.\u003c/h2\u003e\n\u003ch3 id=\"nhiệt-độ-làm-mát-engine-coolant-temperature---tmp\"\u003eNhiệt độ làm mát (Engine Coolant Temperature - TMP)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/TMP.png\"\n  alt=\"TMP\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tốc-độ-động-cơ-engine-speed---rpm\"\u003eTốc độ động cơ (Engine speed - RPM)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/RPM.png\"\n  alt=\"RPM\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tốc-độ-phương-tiện-vehicle-speed---spd\"\u003eTốc độ phương tiện (Vehicle speed - SPD)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/SPD.png\"\n  alt=\"SPD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"mass-air-flow-sensor-maf\"\u003eMass air flow sensor (MAF)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/MAF.png\"\n  alt=\"MAF\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"calculated-engine-load\"\u003eCalculated engine load\u003c/h3\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/obd2_pids/",
      "date_published": "11106-11-09T1023:1111:00+07:00",
      "date_modified": "11106-11-09T1023:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "cc904edd51e47395566e93d3d0857041c529937e",
      "title": "CAN_OBDII",
      "summary": "",
      "content_text": "CAN Bus: Serial Communication - How It Works? Controller Area Network (CAN hoặc CAN Bus) một giao thức truyền thông nối tiếp bất đồng bộ. Bus CAN chỉ có 2 dây giúp kết nối các module điều khiển với nhau dễ dàng hơn khi so sánh với cách làm truyền thống. Do trên ô tô tín hiệu bị nhiễu rất nhiều (sử dụng nhiều mô-tơ), nên CAN Protocol đã được phát triển để chống nhiễu. Ban đầu CAN được thiết kế dành cho ngành công nghiệp ô tô, tuy nhiên hiện nay CAN cũng đã trở thành một tiêu chuẩn phổ biến trong tự động hóa công nghiệp và các ngành khác. Bit Rate (Tốc độ truyền dữ liệu) và Transmission Distances (Khoảng cách truyền dữ liệu) CAN bus sử dụng các tốc độ truyền dữ liệu khác nhau, thường được tính bằng kilobit trên giây (kbps). Hình dưới là công thức: Tốc độ truyền dữ liệu càng cao thì lượng dữ liệu có thể truyền trong một khoảng thời gian càng lớn, nhưng lại có sự đánh đổi với khoảng cách truyền. Dưới đây là bảng biểu thị mối quan hệ giữa tốc độ truyền dữ liệu và khoảng cách truyền tối đa cho CAN bus: Ngoài tốc độ truyền và khoảng cách, một số yếu tố khác cũng có thể ảnh hưởng đến hiệu suất truyền dẫn trên CAN bus: Chất lượng dây cáp: Dây cáp có trở kháng phù hợp sẽ giúp tín hiệu truyền ổn định hơn. Nhiễu điện từ: Môi trường có nhiều nhiễu điện từ (EMI) có thể làm giảm chất lượng tín hiệu. Số lượng thiết bị trên bus: Mỗi thiết bị trên CAN bus sẽ tạo ra tải (load) và có thể ảnh hưởng đến hiệu suất tổng thể. CAN Bus Version CAN Transceiver CAN transceiver không thực hiện bất kỳ xử lý logic nào liên quan đến giao thức CAN mà chỉ làm nhiệm vụ chuyển đổi tín hiệu. Một ví dụ phổ biến về CAN transceiver là MCP2551 của Microchip, được sử dụng rất nhiều trong các ứng dụng CAN bus. Ngoài ra cũng có một số loại CAN Transceiver khác như: TJA1050 SN65HVD230 CAN Bus Controllers CAN bus Controller là một vi mạch tích hợp (IC) chứa tất cả các logic và khả năng xử lý dữ liệu để gửi và nhận các thông điệp CAN bus. Tuy nhiên, nó không có các chân đầu ra trực tiếp CAN_H và CAN_L (là các đường tín hiệu vật lý của CAN bus), mà thay vào đó chỉ có các chân TX và RX ở mức logic. Điều này có nghĩa là nó cần phải được kết nối với một CAN transceiver (bộ chuyển đổi CAN) để chuyển đổi tín hiệu logic thành tín hiệu vật lý trên CAN bus. Bởi vì CAN Controller chỉ hoạt động ở mức logic (0 và 1), cần có một CAN transceiver để chuyển đổi tín hiệu logic đó thành tín hiệu differential (tín hiệu vi sai) trên CAN_H và CAN_L (đây là hai dây tín hiệu của CAN bus). CAN Bus Microcontroller Peripherals: Nhiều vi điều khiển (MCU) hiện đại có tích hợp CAN controller như một phần peripheral bên trong. Ví dụ, các dòng vi điều khiển như STM32 hoặc ESP32 có thể chứa sẵn CAN controller trên chip. Điều này giúp giảm thiểu sự phức tạp trong thiết kế phần cứng vì không cần thêm một IC CAN controller bên ngoài. Mối quan hệ giữa CAN Controller và Transceiver: Như vậy, để giao tiếp hoàn chỉnh trên CAN bus, cả CAN controller và CAN transceiver đều cần thiết: CAN controller: Thực hiện các chức năng logic, quản lý giao thức CAN, và truyền/nhận dữ liệu qua các tín hiệu TX/RX ở mức logic. CAN transceiver: Chuyển đổi các tín hiệu logic từ CAN controller thành tín hiệu vi sai và ngược lại để tương tác với mạng CAN vật lý (CAN_H và CAN_L). Một thiết kế CAN bus điển hình sẽ bao gồm: Vi điều khiển (MCU): Gửi/nhận dữ liệu và điều khiển hệ thống. CAN Controller: Xử lý thông điệp CAN, giao tiếp với MCU qua các giao thức như SPI. CAN Transceiver: Chuyển đổi tín hiệu giữa CAN Controller và CAN bus. Tài liệu tham khảo: Tài liệu Car Hacking Tài liệu khác: https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1727681723175\u0026amp;ref_url=https%253A%252F%252Fwww.google.com.sg%252F https://mesidas.com/can-canbus/ https://community.nxp.com/t5/NXP-Tech-Blog/101-Controller-Area-Network-CAN-standard/ba-p/1217054 https://www.typhoon-hil.com/documentation/typhoon-hil-software-manual/References/can_bus_protocol.html https://blog.mbedded.ninja/electronics/communication-protocols/can-protocol/ https://www.csselectronics.com/pages/can-bus-simple-intro-tutorial OBD Các bài viết liên quan: https://www.otosaigon.com/threads/huong-dan-chan-doan-loi-bang-may-quet-obd2-cho-nguoi-nghiep-du.9075318/ https://autoitech.vn/obd-ii-ma-loi-tren-o-to-phan-1/ https://vinfastauto.com/vn_vi/he-thong-obd-tren-o-to-va-nhung-dieu-can-biet https://www.thegioididong.com/hoi-dap/cong-obd-2-la-gi-cac-tien-ich-tu-cong-obd-2-tren-xe-o-to-1292647 OBD (On – Board Diagnostics), hay còn gọi là hệ thống chẩn đoán lỗi OBD, được trang bị trên ô tô để theo dõi và điều chỉnh một số hoạt động của phương tiện. Hệ thống này thu thập thông tin từ mạng lưới các cảm biến gắn cố định quanh xe, phát hiện lỗi hư hỏng và cảnh báo tới người lái nhằm kịp thời đưa ra phương án xử lý.\nCổng kết nối OBDII: Note Theo mình hiểu thì OBD là một chuẩn (gồm cổng kết nối, protocol) để các hãng xe làm theo quy chuẩn này. Mình liên tưởng điều này với bộ thiết bị GSHT, ví dụ với mỗi nhà phát hành một thiết bị GSHT thì sẽ có một bộ protocol của họ. Tuy nhiên các thiết bị GSHT này đều phải tuân theo QCVN31 (bao gồm công kết nối, protocol của bản tin). Khi tuân theo chuẩn chung này thì nhà nước, chính quyền có thể đọc thông tin từ thiết bị GSHT khi có vấn đề xảy ra. Nếu hiểu như vậy thì sẽ phân biệt và dễ hiểu hơn giữa CAN vs OBD. Tài liệu về mã lỗi trên OBDII https://www.obd-codes.com/ https://www.obd-codes.com/faq/obd2-codes-explained.php https://en.wikipedia.org/wiki/OBD-II_PIDs ",
      "content_html": "\u003ch2 id=\"can-bus-serial-communication---how-it-workshttpswwwyoutubecomwatchvjzsczrt9tto\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=JZSCzRT9TTo\"\u003eCAN Bus: Serial Communication - How It Works?\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_1.png\"\n  alt=\"CAN_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eController Area Network (CAN hoặc CAN Bus)\u003c/strong\u003e một giao thức truyền thông nối tiếp bất đồng bộ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_2.png\"\n  alt=\"CAN_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBus CAN chỉ có 2 dây giúp kết nối các module điều khiển với nhau dễ dàng hơn khi so sánh với cách làm truyền thống.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_3.png\"\n  alt=\"CAN_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDo trên ô tô tín hiệu bị nhiễu rất nhiều (sử dụng nhiều mô-tơ), nên \u003cstrong\u003eCAN Protocol\u003c/strong\u003e đã được phát triển để \u003cstrong\u003echống nhiễu\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eBan đầu CAN được thiết kế dành cho ngành công nghiệp ô tô, tuy nhiên hiện nay CAN cũng đã trở thành một tiêu chuẩn phổ biến trong tự động hóa công nghiệp và các ngành khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bit-rate-tốc-độ-truyền-dữ-liệu-và-transmission-distances-khoảng-cách-truyền-dữ-liệu\"\u003eBit Rate (Tốc độ truyền dữ liệu) và Transmission Distances (Khoảng cách truyền dữ liệu)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCAN bus sử dụng các tốc độ truyền dữ liệu khác nhau, thường được tính bằng kilobit trên giây (kbps).\u003c/li\u003e\n\u003cli\u003eHình dưới là công thức:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_4.png\"\n  alt=\"CAN_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTốc độ truyền dữ liệu càng cao thì lượng dữ liệu có thể truyền trong một khoảng thời gian càng lớn, nhưng lại có sự đánh đổi với \u003cstrong\u003ekhoảng cách truyền\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDưới đây là bảng biểu thị mối quan hệ giữa tốc độ truyền dữ liệu và khoảng cách truyền tối đa cho CAN bus:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_5.png\"\n  alt=\"CAN_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNgoài tốc độ truyền và khoảng cách, một số yếu tố khác cũng có thể ảnh hưởng đến hiệu suất truyền dẫn trên CAN bus:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eChất lượng dây cáp\u003c/strong\u003e: Dây cáp có trở kháng phù hợp sẽ giúp tín hiệu truyền ổn định hơn.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNhiễu điện từ\u003c/strong\u003e: Môi trường có nhiều nhiễu điện từ (EMI) có thể làm giảm chất lượng tín hiệu.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSố lượng thiết bị trên bus\u003c/strong\u003e: Mỗi thiết bị trên CAN bus sẽ tạo ra tải (load) và có thể ảnh hưởng đến hiệu suất tổng thể.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"can-bus-version\"\u003eCAN Bus Version\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_Bus_Version.png\"\n  alt=\"CAN_Bus_Version\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"can-transceiver\"\u003eCAN Transceiver\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCAN transceiver không thực hiện bất kỳ xử lý logic nào liên quan đến giao thức CAN mà chỉ làm nhiệm vụ chuyển đổi tín hiệu. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eMột ví dụ phổ biến về CAN transceiver là \u003ca href=\"https://ww1.microchip.com/downloads/en/devicedoc/20001667g.pdf\"\u003eMCP2551\u003c/a\u003e của Microchip, được sử dụng rất nhiều trong các ứng dụng CAN bus.\u003c/li\u003e\n\u003cli\u003eNgoài ra cũng có một số loại \u003cstrong\u003eCAN Transceiver\u003c/strong\u003e khác như:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.nxp.com/docs/en/data-sheet/TJA1050.pdf\"\u003eTJA1050\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.ti.com/lit/ds/symlink/sn65hvd230.pdf?ts=1727771231223\u0026amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FSN65HVD230%253Futm_source%253Dgoogle%2526utm_medium%253Dcpc%2526utm_campaign%253Dasc-null-null-GPN_EN-cpc-pf-google-soas%2526utm_content%253DSN65HVD230%2526ds_k%253DSN65HVD230+Datasheet%2526DCM%253Dyes%2526gad_source%253D1%2526gclid%253DCj0KCQjwu-63BhC9ARIsAMMTLXR7R_weCPL_OVEche7n0ns9PKmoIPJQEKCm7Smr_0-Ta597tHP5OdEaAt8jEALw_wcB%2526gclsrc%253Daw.ds\"\u003eSN65HVD230\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"can-bus-controllers\"\u003eCAN Bus Controllers\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCAN bus Controller\u003c/strong\u003e là một vi mạch tích hợp (IC) chứa tất cả các logic và khả năng xử lý dữ liệu để gửi và nhận các thông điệp CAN bus.\u003c/li\u003e\n\u003cli\u003eTuy nhiên, nó không có các chân đầu ra trực tiếp \u003ccode\u003eCAN_H\u003c/code\u003e và \u003ccode\u003eCAN_L\u003c/code\u003e (là các đường tín hiệu vật lý của CAN bus), mà thay vào đó chỉ có các chân TX và RX ở mức logic.\u003c/li\u003e\n\u003cli\u003eĐiều này có nghĩa là nó cần phải được kết nối với một CAN transceiver (bộ chuyển đổi CAN) để chuyển đổi tín hiệu logic thành tín hiệu vật lý trên CAN bus.\u003c/li\u003e\n\u003cli\u003eBởi vì CAN Controller chỉ hoạt động ở mức logic (0 và 1), cần có một CAN transceiver để chuyển đổi tín hiệu logic đó thành tín hiệu differential \u003cem\u003e(tín hiệu vi sai)\u003c/em\u003e trên \u003ccode\u003eCAN_H\u003c/code\u003e và \u003ccode\u003eCAN_L\u003c/code\u003e (đây là hai dây tín hiệu của CAN bus).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_6.png\"\n  alt=\"CAN_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCAN Bus Microcontroller Peripherals\u003c/strong\u003e: Nhiều vi điều khiển (MCU) hiện đại có tích hợp CAN controller như một phần peripheral bên trong.\nVí dụ, các dòng vi điều khiển như \u003cstrong\u003eSTM32\u003c/strong\u003e hoặc \u003cstrong\u003eESP32\u003c/strong\u003e có thể chứa sẵn CAN controller trên chip. Điều này giúp giảm thiểu sự phức tạp trong thiết kế phần cứng vì không cần thêm một IC CAN controller bên ngoài.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mối-quan-hệ-giữa-can-controller-và-transceiver\"\u003eMối quan hệ giữa CAN Controller và Transceiver:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNhư vậy, để giao tiếp hoàn chỉnh trên CAN bus, cả CAN controller và CAN transceiver đều cần thiết:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCAN controller\u003c/strong\u003e: Thực hiện các chức năng logic, quản lý giao thức CAN, và truyền/nhận dữ liệu qua các tín hiệu TX/RX ở mức logic.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCAN transceiver\u003c/strong\u003e: Chuyển đổi các tín hiệu logic từ CAN controller thành tín hiệu vi sai và ngược lại để tương tác với mạng CAN vật lý (\u003ccode\u003eCAN_H\u003c/code\u003e và \u003ccode\u003eCAN_L\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMột thiết kế CAN bus điển hình sẽ bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eVi điều khiển (MCU)\u003c/strong\u003e: Gửi/nhận dữ liệu và điều khiển hệ thống. \u003c/br\u003e\n\u003cstrong\u003eCAN Controller\u003c/strong\u003e: Xử lý thông điệp CAN, giao tiếp với MCU qua các giao thức như SPI. \u003c/br\u003e\n\u003cstrong\u003eCAN Transceiver\u003c/strong\u003e: Chuyển đổi tín hiệu giữa CAN Controller và CAN bus. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo\"\u003eTài liệu tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf\"\u003eTài liệu Car Hacking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1727681723175\u0026amp;ref_url=https%253A%252F%252Fwww.google.com.sg%252F\nhttps://mesidas.com/can-canbus/\nhttps://community.nxp.com/t5/NXP-Tech-Blog/101-Controller-Area-Network-CAN-standard/ba-p/1217054\nhttps://www.typhoon-hil.com/documentation/typhoon-hil-software-manual/References/can_bus_protocol.html\nhttps://blog.mbedded.ninja/electronics/communication-protocols/can-protocol/\nhttps://www.csselectronics.com/pages/can-bus-simple-intro-tutorial\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"obd\"\u003eOBD\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác bài viết liên quan:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.otosaigon.com/threads/huong-dan-chan-doan-loi-bang-may-quet-obd2-cho-nguoi-nghiep-du.9075318/\nhttps://autoitech.vn/obd-ii-ma-loi-tren-o-to-phan-1/\nhttps://vinfastauto.com/vn_vi/he-thong-obd-tren-o-to-va-nhung-dieu-can-biet\nhttps://www.thegioididong.com/hoi-dap/cong-obd-2-la-gi-cac-tien-ich-tu-cong-obd-2-tren-xe-o-to-1292647\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eOBD (On – Board Diagnostics)\u003c/strong\u003e, hay còn gọi là hệ thống chẩn đoán lỗi OBD, được trang bị trên ô tô để theo dõi và điều chỉnh một số hoạt động của phương tiện. Hệ thống này thu thập thông tin từ mạng lưới các cảm biến gắn cố định quanh xe, phát hiện lỗi hư hỏng và cảnh báo tới người lái nhằm kịp thời đưa ra phương án xử lý.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/H%e1%bb%87_th%e1%bb%91ng_OBD.jpg\"\n  alt=\"OBD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCổng kết nối OBDII:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/OBDII_Pinout.jpg\"\n  alt=\"OBD_pinout\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo mình hiểu thì OBD là một chuẩn (gồm cổng kết nối, protocol) để các hãng xe làm theo quy chuẩn này.\u003c/li\u003e\n\u003cli\u003eMình liên tưởng điều này với bộ thiết bị GSHT, ví dụ với mỗi nhà phát hành một thiết bị GSHT thì sẽ có một bộ protocol của họ.\u003c/li\u003e\n\u003cli\u003eTuy nhiên các thiết bị GSHT này đều phải tuân theo \u003cstrong\u003eQCVN31\u003c/strong\u003e (bao gồm công kết nối, protocol của bản tin). Khi tuân theo chuẩn chung này thì nhà nước, chính quyền có thể đọc thông tin từ thiết bị GSHT khi có vấn đề xảy ra.\u003c/li\u003e\n\u003cli\u003eNếu hiểu như vậy thì sẽ phân biệt và dễ hiểu hơn giữa \u003cstrong\u003eCAN vs OBD\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tài-liệu-về-mã-lỗi-trên-obdii\"\u003eTài liệu về mã lỗi trên OBDII\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.obd-codes.com/\nhttps://www.obd-codes.com/faq/obd2-codes-explained.php\nhttps://en.wikipedia.org/wiki/OBD-II_PIDs\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/can_obdii/",
      "date_published": "11106-11-09T1056:1111:00+07:00",
      "date_modified": "11106-11-09T1056:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1ba79970c01707fa06415de9e7b567c85620aa8e",
      "title": "DMA",
      "summary": "",
      "content_text": "Trong quá trình tìm hiểu lại về DMA, mình lại vô trình biết thêm một trang web chia sẻ kiến thức về Điện tử, Lập trình,\u0026hellip;\n👉 Website: Lập trình - Điện tử\nNgoài ra mình cũng tìm đc một bài viết khá hay, cũng liên quan một phần đến DMA.\n🌱 Bài viết Các kỹ thuật thiết kế luồng xử lý trong chương trình nhúng Đối với một số chương trình nhỏ, các chương trình mà các bạn mới thực hành (blink LED, đọc nút bấm, \u0026hellip;) có một đặc điểm chung, đó là chương trình đều liên tục thực thi, kiểm tra một số lệnh nào đó, trong vòng lặp while (1). Điều này dẫn đến nhiều nhược điểm, chẳng hạn: Những lệnh đứng sau phải đợi những lệnh đứng trước thực thi xong, như vậy có thể gây bỏ lỡ các sự kiện nếu kích thước chương trình lớn. 3 cách thiết kế luồng xử lý đơn giản nhất trong chương trình nhúng, đó là Polling, Interrupt, DMA. Polling Cách mà chúng ta vẫn hay làm như vậy, trong vòng lặp while(1), gọi là kỹ thuật Polling - liên tục kiểm tra, liên tục thực thi. Hin\nTuy nhiên, với các chương trình lớn, phức tạp hơn, đòi hỏi đáp ứng nhanh hơn, thì polling sẽ rất khó đáp ứng được. Polling trong các trường hợp này có thể gây mất các sự kiện Interrupt Hiểu đơn giản thay vì liên tục kiểm tra nút bấm, ta cài đặt cho nó là 1 ngắt. Thì khi bấm nút, chương trình sẽ bị gián đoạn, và CPU phải kiểm tra xem điều gì đang xảy ra Ưu điểm là Interrupt là giúp chương trình đáp ứng nhanh với những cái ta cần. Có thể sử dụng chế độ tiết kiệm năng lượng khi vi điều khiển không làm gì. Tuy nhiên, nhược điểm của nó là ta cần khống chế chương trình con thực thi ngắt ISR để tránh việc chương trình phục vụ một ngắt quá lâu. Lời khuyên là nên viết chương trình ISR càng ngắn về mặt thời gian càng tốt. DMA - Direct Memory Access Kỹ thuật này để sử dụng để truyền dữ liệu trực tiếp giữa bộ nhớ và ngoại vi mà không thông qua CPU (trong lúc này, CPU có thể làm việc khác nhờ thế tiết kiệm thời gian CPU rất nhiều). Trong hầu hết các thiết bị nhúng, các thiết bị ngoại vi không hỗ trợ truyền nhiều bit cùng lúc, với ngoại lệ là giao thức CAN. Thay vào đó, vi điều khiển (MCU) phải ghi từng byte một, và sau đó chờ cho đến khi thiết bị ngoại vi sẵn sàng để gửi byte tiếp theo. 💬 Cơ chế hoạt động thông thường của Core:\nHãy nhìn hình vẽ trên, CPU sẽ điều khiển việc transfer data giữa Peripheral (UART, I2C, SPI, \u0026hellip;) và bộ nhớ (RAM) qua các đường bus. Cơ chế này được hiểu như cơ chế Master - Slave, với CPU đóng vai trò là Master, Peripheral và Memory đóng vai trò như các slave. Nên việc giao tiếp giữa 2 Slave sẽ do Master điều khiển. Tuy nhiên với việc CPU phải làm thêm 1 công việc quan trọng khác - Fetch lệnh từ bộ nhớ (FLASH) để thực thi các lệnh của chương trình. Vì vậy, khi cần truyền dữ liệu liên tục giữa Peripheral và RAM, CPU sẽ bị chiếm dụng, và không có thời gian làm các công việc khác, hoặc có thể gây miss dữ liệu khi transfer. Chính vì vậy, hệ thống hỗ trợ một Master khác để chuyên làm công việc này, đó là DMA. 💬 Một số kiến trúc Vi điều khiển không hỗ trợ DMA (8051, AVR, PIC, \u0026hellip;), có thể sử dụng bộ chip ngoài DMAC - DMA Controller để thay thể. Ở đây chúng ta chỉ xét đến các dòng có hỗ trợ DMA nội, cụ thể là trong Vi điềuk khiển STM32.\nDMA cho phép MCU thiết lập một luồng truyền dữ liệu (gửi hoặc nhận) và sau đó chờ cho đến khi luồng truyền hoàn tất. Khi sử dụng DMA, sau khi bắt đầu, MCU không cần can thiệp cho đến khi việc truyền dữ liệu hoàn tất, có nghĩa là MCU có thể thực hiện các tính toán khác hoặc thiết lập các I/O khác trong khi luồng truyền đang diễn ra. Tài liệu tham khảo thêm về DMA https://github.com/embassy-rs/embassy/wiki https://www.laptrinhdientu.com/2022/04/DMA1.html ",
      "content_html": "\u003cp\u003eTrong quá trình tìm hiểu lại về \u003cstrong\u003eDMA\u003c/strong\u003e, mình lại vô trình biết thêm một trang web chia sẻ kiến thức về \u003cstrong\u003eĐiện tử, Lập trình,\u0026hellip;\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e👉 Website: \u003ca href=\"https://www.laptrinhdientu.com/\"\u003eLập trình - Điện tử\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eNgoài ra mình cũng tìm đc một bài viết khá hay, cũng liên quan một phần đến DMA.\u003c/p\u003e\n\u003ch2 id=\"-bài-viết-các-kỹ-thuật-thiết-kế-luồng-xử-lý-trong-chương-trình-nhúnghttpswwwlaptrinhdientucom202201embeddeddesignhtml\"\u003e🌱 Bài viết \u003ca href=\"https://www.laptrinhdientu.com/2022/01/EmbeddedDesign.html\"\u003eCác kỹ thuật thiết kế luồng xử lý trong chương trình nhúng\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eĐối với một số chương trình nhỏ, các chương trình mà các bạn mới thực hành (blink LED, đọc nút bấm, \u0026hellip;) có một đặc điểm chung, đó là chương trình đều liên tục thực thi, kiểm tra một số lệnh nào đó, trong vòng lặp while (1). Điều này dẫn đến nhiều nhược điểm, chẳng hạn: Những lệnh đứng sau phải đợi những lệnh đứng trước thực thi xong, như vậy có thể gây bỏ lỡ các sự kiện nếu kích thước chương trình lớn. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e3 cách thiết kế luồng xử lý đơn giản nhất trong chương trình nhúng, đó là \u003ccode\u003ePolling\u003c/code\u003e, \u003ccode\u003eInterrupt\u003c/code\u003e, \u003ccode\u003eDMA\u003c/code\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"polling\"\u003ePolling\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCách mà chúng ta vẫn hay làm như vậy, trong vòng lặp \u003cstrong\u003ewhile(1)\u003c/strong\u003e, gọi là kỹ thuật Polling - liên tục kiểm tra, liên tục thực thi.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_1.webp\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\nHin\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTuy nhiên, với các chương trình lớn, phức tạp hơn, đòi hỏi đáp ứng nhanh hơn, thì polling sẽ rất khó đáp ứng được. Polling trong các trường hợp này có thể gây mất các sự kiện\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"interrupt\"\u003eInterrupt\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiểu đơn giản thay vì liên tục kiểm tra nút bấm, ta cài đặt cho nó là 1 ngắt.\u003c/li\u003e\n\u003cli\u003eThì khi bấm nút, chương trình sẽ bị gián đoạn, và CPU phải kiểm tra xem điều gì đang xảy ra\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_2.webp\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eƯu điểm là Interrupt là giúp chương trình đáp ứng nhanh với những cái ta cần. Có thể sử dụng chế độ tiết kiệm năng lượng khi vi điều khiển không làm gì.\u003c/li\u003e\n\u003cli\u003eTuy nhiên, nhược điểm của nó là ta cần khống chế chương trình con thực thi ngắt ISR để tránh việc chương trình phục vụ một ngắt quá lâu. Lời khuyên là nên viết chương trình ISR càng ngắn về mặt thời gian càng tốt.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"markdma---direct-memory-accessmark\"\u003e\u003cmark\u003eDMA - Direct Memory Access\u003c/mark\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKỹ thuật này để sử dụng để truyền dữ liệu trực tiếp giữa bộ nhớ và ngoại vi mà không thông qua CPU (trong lúc này, CPU có thể làm việc khác nhờ thế tiết kiệm thời gian CPU rất nhiều).\u003c/li\u003e\n\u003cli\u003eTrong hầu hết các thiết bị nhúng, các thiết bị ngoại vi không hỗ trợ truyền nhiều bit cùng lúc, với ngoại lệ là giao thức CAN. Thay vào đó, vi điều khiển (MCU) phải ghi từng byte một, và sau đó chờ cho đến khi thiết bị ngoại vi sẵn sàng để gửi byte tiếp theo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e💬 Cơ chế hoạt động thông thường của Core:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_3.webp\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHãy nhìn hình vẽ trên, CPU sẽ điều khiển việc transfer data giữa Peripheral (UART, I2C, SPI, \u0026hellip;) và bộ nhớ (RAM) qua các đường bus. Cơ chế này được hiểu như cơ chế \u003cstrong\u003eMaster - Slave\u003c/strong\u003e, với CPU đóng vai trò là Master, Peripheral và Memory đóng vai trò như các slave. Nên việc giao tiếp giữa 2 Slave sẽ do Master điều khiển. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTuy nhiên với việc CPU phải làm thêm 1 công việc quan trọng khác - Fetch lệnh từ bộ nhớ (FLASH) để thực thi các lệnh của chương trình. Vì vậy, khi cần truyền dữ liệu liên tục giữa Peripheral và RAM, CPU sẽ bị chiếm dụng, và không có thời gian làm các công việc khác, hoặc có thể gây miss dữ liệu khi transfer. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eChính vì vậy, hệ thống hỗ trợ một \u003cstrong\u003eMaster\u003c/strong\u003e khác để chuyên làm công việc này, đó là \u003cstrong\u003eDMA\u003c/strong\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e💬 Một số kiến trúc Vi điều khiển không hỗ trợ DMA (8051, AVR, PIC, \u0026hellip;), có thể sử dụng bộ chip ngoài DMAC - DMA Controller để thay thể. Ở đây chúng ta chỉ xét đến các dòng có hỗ trợ DMA nội, cụ thể là trong Vi điềuk khiển STM32.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDMA cho phép MCU thiết lập một luồng truyền dữ liệu (gửi hoặc nhận) và sau đó chờ cho đến khi luồng truyền hoàn tất. Khi sử dụng DMA, sau khi bắt đầu, MCU không cần can thiệp cho đến khi việc truyền dữ liệu hoàn tất, có nghĩa là MCU có thể thực hiện các tính toán khác hoặc thiết lập các I/O khác trong khi luồng truyền đang diễn ra.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_4.webp\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu tham khảo thêm về DMA\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/embassy-rs/embassy/wiki\nhttps://www.laptrinhdientu.com/2022/04/DMA1.html\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/dma/",
      "date_published": "11106-11-09T1021:1111:00+07:00",
      "date_modified": "11106-11-09T1021:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "5339aede944e7541ae1695d5e04399522d2b95d3",
      "title": "Rust_for_ARM",
      "summary": "",
      "content_text": " Ngày Mô tả 10/10/2024 Khởi tạo bài viết, ghi chú về Rust for ARM 12/10/2024 Ghi chú thêm một số tài liệu về OpenWRT Hiện tại đã dùng Rust để code Bất đồng bộ.\nVới MCU thì dùng framework embassy Với Linux (hoặc Windows) thì dùng tokio Với framework tokio thì mình đã có một project nhỏ (tên là Tracking_Report), mục tiêu là build app để lấy thông tin trên NATS Server và gửi data lên ThingsBoard.\nTheo suy nghĩ đơn giản thì mình chỉ cần build code để chạy trên kiến trúc ARM là được. Nhưng khi dùng Cross Compilation để build thì lại lỗi tè le.\nChưa rõ lý do. Tạm thời sẽ documents lại những gì làm đc và những tài liệu liên quan.\nDocument lại Rust Cross Compilation cho ARM Mình có tìm được một project về Cross Compilation, tên là rust cross compilation Mình đã làm theo và test thử cho raspberry thì chạy được, nhưng khi áp dụng vào Tracking_Report thì build vẫn lỗi. Kiểm tra thông tin của Raspberry CM4 Kiểm tra phần cứng: cat /sys/firmware/devicetree/base/model Kiểm tra kiến trúc: lscpu Vậy phần cứng Raspberry CM4, thông tin: Model name: Cortex-A72 Architecture: armv7l Theo tài liệu trên github rust_cross_compilation thì: # For my armv7l embedded computer $ rustup target add armv7-unknown-linux-gnueabi # For my Raspberry Pi Zero W $ rustup target add arm-unknown-linux-gnueabihf Dựa trên platform support có thông tin: target std Note armv7-unknown-linux-gnueabi ✓ Armv7-A Linux (kernel 4.15, glibc 2.27) Setup trên máy Ubuntu Đầu tiên là cài rust cho linux (ở đây là máy Ubuntu). Sau đó mình cần cài đặt một số công cụ: rustup target add armv7-unknown-linux-gnueabi sudo apt install gcc-arm-linux-gnueabi Download project: git clone https://github.com/LOCNNIL/rust_cross_compilation.git cd rust_cross_compilation/ cargo build --target armv7-unknown-linux-gnueabi Lưu ý về file .cargo/config.toml: # target config for Embedded Computer with armv7l arch [target.armv7-unknown-linux-gnueabi] linker = \u0026#34;arm-linux-gnueabi-gcc\u0026#34; rustflags = [\u0026#34;-C\u0026#34;, \u0026#34;target-feature=+crt-static\u0026#34;] Sau đó copy file sang Pi: sudo scp target/armv7-unknown-linux-gnueabi/debug/cross-arm pi@192.168.10.100: Run on Pi Quay lại Pi, và chạy lệnh: ./cross-arm Đã chạy đc thành công. Tổng hợp một số tài liệu khác: https://www.acmesystems.it/arm9_toolchain https://harmonicss.co.uk/rust/rust-on-a-raspberry-pi-part-1/ Đây là một tutorial làm quen với việc viết OS cho Raspberry, tên project: rust-raspberrypi-OS-tutorials Ghi chú khác về armv7-unknown-linux-uclibceabi This target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U). Tức là khi code rust và build file với target là armv7-unknown-linux-uclibceabi thì có thể sẽ chạy được trên OpneWRT. Cập nhật 12/10/2024 Ghi chú tổng hợp một số tài liệu về OpenWRT cho Rust\nBuilding Rust code for my OpenWrt Wi-Fi router Đây là một ghi chú khác về cross compiling Rust programs ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e10/10/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết, ghi chú về Rust for ARM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e12/10/2024\u003c/td\u003e\n\u003ctd\u003eGhi chú thêm một số tài liệu về OpenWRT\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHiện tại đã dùng \u003cstrong\u003eRust\u003c/strong\u003e để code \u003cstrong\u003eBất đồng bộ\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVới MCU thì dùng framework \u003ca href=\"https://github.com/embassy-rs/embassy\"\u003eembassy\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eVới Linux (hoặc Windows) thì dùng \u003ca href=\"https://github.com/tokio-rs/tokio\"\u003etokio\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVới framework tokio thì mình đã có một project nhỏ \u003cem\u003e(tên là Tracking_Report)\u003c/em\u003e, mục tiêu là build app để lấy thông tin trên \u003cstrong\u003eNATS Server\u003c/strong\u003e và gửi data lên \u003cstrong\u003eThingsBoard\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTheo suy nghĩ đơn giản thì mình chỉ cần build code để chạy trên kiến trúc \u003cstrong\u003eARM\u003c/strong\u003e là được. Nhưng khi dùng \u003cstrong\u003eCross Compilation\u003c/strong\u003e để build thì lại \u003cstrong\u003elỗi tè le\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eChưa rõ lý do. Tạm thời sẽ documents lại những gì làm đc và những tài liệu liên quan.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"document-lại-rust-cross-compilation-cho-arm\"\u003eDocument lại Rust Cross Compilation cho ARM\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMình có tìm được một project về \u003cem\u003eCross Compilation\u003c/em\u003e, tên là \u003ca href=\"https://github.com/locnnil/rust_cross_compilation\"\u003erust cross compilation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMình đã làm theo và test thử cho raspberry thì chạy được, \u003cstrong\u003enhưng khi áp dụng vào Tracking_Report thì build vẫn lỗi\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kiểm-tra-thông-tin-của-raspberry-cm4\"\u003eKiểm tra thông tin của Raspberry CM4\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKiểm tra phần cứng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecat /sys/firmware/devicetree/base/model\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eKiểm tra kiến trúc:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elscpu\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Rust_for_ARM/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVậy phần cứng \u003cstrong\u003eRaspberry CM4\u003c/strong\u003e, thông tin:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eModel name: Cortex-A72\nArchitecture: armv7l\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTheo tài liệu trên github \u003ca href=\"https://github.com/locnnil/rust_cross_compilation\"\u003erust_cross_compilation\u003c/a\u003e thì:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# For my armv7l embedded computer\n$ rustup target add armv7-unknown-linux-gnueabi \n\n# For my Raspberry Pi Zero W\n$ rustup target add arm-unknown-linux-gnueabihf\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eDựa trên \u003ca href=\"https://doc.rust-lang.org/beta/rustc/platform-support.html\"\u003eplatform support\u003c/a\u003e có thông tin:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003etarget\u003c/th\u003e\n\u003cth\u003estd\u003c/th\u003e\n\u003cth\u003eNote\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003earmv7-unknown-linux-gnueabi\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003ctd\u003eArmv7-A Linux (kernel 4.15, glibc 2.27)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"setup-trên-máy-ubuntu\"\u003eSetup trên máy Ubuntu\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐầu tiên là cài rust cho linux \u003cem\u003e(ở đây là máy Ubuntu)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eSau đó mình cần cài đặt một số công cụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003erustup target add armv7-unknown-linux-gnueabi\nsudo apt install gcc-arm-linux-gnueabi\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eDownload project:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egit clone https://github.com/LOCNNIL/rust_cross_compilation.git\ncd rust_cross_compilation/\ncargo build --target armv7-unknown-linux-gnueabi\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eLưu ý về file \u003ccode\u003e.cargo/config.toml\u003c/code\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# target config for Embedded Computer with armv7l arch\n[target.armv7-unknown-linux-gnueabi]\nlinker = \u0026#34;arm-linux-gnueabi-gcc\u0026#34;\nrustflags = [\u0026#34;-C\u0026#34;, \u0026#34;target-feature=+crt-static\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eSau đó copy file sang Pi:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo scp target/armv7-unknown-linux-gnueabi/debug/cross-arm pi@192.168.10.100:\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"run-on-pi\"\u003eRun on Pi\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eQuay lại Pi, và chạy lệnh:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./cross-arm\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐã chạy đc thành công.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Rust_for_ARM/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"tổng-hợp-một-số-tài-liệu-khác\"\u003eTổng hợp một số tài liệu khác:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.acmesystems.it/arm9_toolchain\nhttps://harmonicss.co.uk/rust/rust-on-a-raspberry-pi-part-1/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐây là một tutorial làm quen với việc \u003cstrong\u003eviết OS cho Raspberry\u003c/strong\u003e, tên project: \u003ca href=\"https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials\"\u003erust-raspberrypi-OS-tutorials\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ghi-chú-khác-về-armv7-unknown-linux-uclibceabihttpsdocrust-langorgrustcplatform-supportarmv7-unknown-linux-uclibceabihtml\"\u003eGhi chú khác về \u003ca href=\"https://doc.rust-lang.org/rustc/platform-support/armv7-unknown-linux-uclibceabi.html\"\u003earmv7-unknown-linux-uclibceabi\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U). \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eTức là khi code rust và build file với target là \u003ccode\u003earmv7-unknown-linux-uclibceabi\u003c/code\u003e thì có thể sẽ chạy được trên \u003cstrong\u003eOpneWRT\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-12102024\"\u003eCập nhật 12/10/2024\u003c/h2\u003e\n\u003cp\u003eGhi chú tổng hợp một số tài liệu về \u003ca href=\"https://openwrt.org/about\"\u003eOpenWRT\u003c/a\u003e cho Rust\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.dend.ro/building-rust-for-routers/\"\u003eBuilding Rust code for my OpenWrt Wi-Fi router\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eĐây là một ghi chú khác về \u003ca href=\"https://github.com/japaric/rust-cross\"\u003ecross compiling Rust programs\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust_for_arm/",
      "date_published": "10106-10-09T1030:1010:00+07:00",
      "date_modified": "10106-10-09T1030:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a652262b2916c6795da636201503398e8ab0c326",
      "title": "Android_Automotive",
      "summary": "",
      "content_text": "Trong lúc lướt lát trên facebook, mình vô tình bắt gặp một bài viết Android Automotive Boot Process A-Z.\nTừ đó vô tình biết thêm được một trang chia sẻ kiến thức về mảng Automotive.\n👉Website: https://devlinux.vn/newest\nTrang tổng hợp các bài viết về Android Automotive Tổng quát về bài viết Android Automotive Boot Process A-Z Tóm tắt các bước chính trong quá trình khởi động Android: Boot ROM: Khi hệ thống bật nguồn, bộ nhớ ROM được kích hoạt đầu tiên. Đây là nơi chứa mã khởi động ban đầu giúp xác định thiết bị lưu trữ chứa phần mềm hệ điều hành.\nBootloader: Sau khi Boot ROM hoàn thành, Bootloader được tải lên để bắt đầu nạp kernel của hệ điều hành vào bộ nhớ.\nRead Boot Config: Bootloader đọc cấu hình khởi động từ các thiết bị lưu trữ (như thẻ SD, eMMC, USB).\nChọn thiết bị khởi động (Boot Device): Dựa trên cấu hình boot, hệ thống chọn thiết bị chứa kernel của hệ điều hành.\nKernel Linux: Kernel của Linux được tải và bắt đầu thực hiện các chức năng cốt lõi của hệ điều hành.\nAndroid Init Process: Quá trình khởi tạo của Android được thực hiện, bao gồm khởi chạy các dịch vụ cơ bản và phân quyền bằng SELinux.\nZygote Process: Zygote là một tiến trình quan trọng trong Android, khởi tạo các hệ thống máy ảo Dalvik/ART, giúp tạo ra các tiến trình ứng dụng.\nSystem Server: Khởi động các dịch vụ hệ thống Android như quản lý pin, cảm biến, dịch vụ mạng, dịch vụ quản lý ứng dụng và các dịch vụ liên quan đến phương tiện di chuyển.\nLauncher: Cuối cùng, Android khởi động giao diện người dùng chính (Launcher), nơi người dùng có thể tương tác với hệ thống.\n",
      "content_html": "\u003cp\u003eTrong lúc lướt lát trên facebook, mình vô tình bắt gặp một bài viết \u003cstrong\u003eAndroid Automotive Boot Process A-Z\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTừ đó vô tình biết thêm được một trang chia sẻ kiến thức về mảng Automotive.\u003c/p\u003e\n\u003cp\u003e👉Website: \u003ca href=\"https://devlinux.vn/newest\"\u003ehttps://devlinux.vn/newest\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"trang-tổng-hợp-các-bài-viết-về-android-automotivehttpsdevlinuxvnseriesbasic-android-automotive\"\u003eTrang tổng hợp các bài viết về \u003ca href=\"https://devlinux.vn/series/basic-android-automotive\"\u003eAndroid Automotive\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"tổng-quát-về-bài-viết-android-automotive-boot-process-a-zhttpsdevlinuxvnpostandroid-boot-process-a-z\"\u003eTổng quát về bài viết \u003ca href=\"https://devlinux.vn/post/android-boot-process-a-z\"\u003eAndroid Automotive Boot Process A-Z\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTóm tắt các bước chính trong quá trình khởi động Android: \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBoot ROM\u003c/strong\u003e: Khi hệ thống bật nguồn, bộ nhớ ROM được kích hoạt đầu tiên. Đây là nơi chứa mã khởi động ban đầu giúp xác định thiết bị lưu trữ chứa phần mềm hệ điều hành.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBootloader\u003c/strong\u003e: Sau khi Boot ROM hoàn thành, Bootloader được tải lên để bắt đầu nạp kernel của hệ điều hành vào bộ nhớ.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eRead Boot Config\u003c/strong\u003e: Bootloader đọc cấu hình khởi động từ các thiết bị lưu trữ (như thẻ SD, eMMC, USB).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eChọn thiết bị khởi động (Boot Device)\u003c/strong\u003e: Dựa trên cấu hình boot, hệ thống chọn thiết bị chứa kernel của hệ điều hành.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eKernel Linux\u003c/strong\u003e: Kernel của Linux được tải và bắt đầu thực hiện các chức năng cốt lõi của hệ điều hành.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eAndroid Init Process\u003c/strong\u003e: Quá trình khởi tạo của Android được thực hiện, bao gồm khởi chạy các dịch vụ cơ bản và phân quyền bằng SELinux.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eZygote Process\u003c/strong\u003e: Zygote là một tiến trình quan trọng trong Android, khởi tạo các hệ thống máy ảo Dalvik/ART, giúp tạo ra các tiến trình ứng dụng.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSystem Server\u003c/strong\u003e: Khởi động các dịch vụ hệ thống Android như quản lý pin, cảm biến, dịch vụ mạng, dịch vụ quản lý ứng dụng và các dịch vụ liên quan đến phương tiện di chuyển.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eLauncher\u003c/strong\u003e: Cuối cùng, Android khởi động giao diện người dùng chính (Launcher), nơi người dùng có thể tương tác với hệ thống.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Android_Automotive_Boot_Process.jpg\"\n  alt=\"Boot_Process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/android_automotive/",
      "date_published": "7106-07-09T106:77:00+07:00",
      "date_modified": "7106-07-09T106:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c838ed435f6add572f7c3bd52057eae348c78374",
      "title": "Fault_Injection",
      "summary": "",
      "content_text": "Fault Injection là một kỹ thuật được sử dụng trong việc kiểm tra và đảm bảo độ tin cậy của các hệ thống phần mềm và phần cứng.\nMục đích của kỹ thuật này là cố tình tạo ra các lỗi hoặc điều kiện bất thường trong hệ thống để xem hệ thống sẽ phản ứng như thế nào, từ đó đánh giá được tính ổn định và khả năng xử lý lỗi của hệ thống.\nCó thể hiểu đơn giản rằng khi bạn phát triển một hệ thống, bạn luôn mong muốn nó hoạt động một cách hoàn hảo.\nNhưng trong thực tế, có nhiều yếu tố như lỗi phần cứng, lỗi phần mềm, hoặc những sự cố bất ngờ từ môi trường ngoài có thể ảnh hưởng đến hệ thống.\nFault injection giúp mô phỏng những tình huống này bằng cách cố tình đưa ra các lỗi, ví dụ như:\nLỗi phần cứng: Giả lập các vấn đề như bộ nhớ bị lỗi, đường truyền bị gián đoạn. Lỗi phần mềm: Gây ra lỗi trong code như chia cho 0, tràn bộ đệm (buffer overflow), hoặc làm hỏng dữ liệu. Điều kiện thời gian: Gây trễ (delay) hoặc thay đổi thời gian xử lý để kiểm tra khả năng xử lý của hệ thống trong những điều kiện bất lợi. Mục tiêu của Fault Injection là đảm bảo hệ thống có thể hoạt động tốt, hoặc ít nhất là không bị phá hỏng hoàn toàn, khi xảy ra các lỗi này.\nĐây là một phương pháp rất hữu ích trong việc tăng cường độ tin cậy và an toàn của các hệ thống, đặc biệt là trong các ứng dụng quan trọng như hàng không, ô tô, y tế, hay các hệ thống nhúng.\nBài viết How to voltage fault injection Trong quá trình đánh giá bảo mật vật lý của thiết bị IoT, một trong những mục tiêu là tận dụng giao diện gỡ lỗi của chip để có thể truy cập và nghiên cứu cách hoạt động của thiết bị. Một kịch bản lý tưởng là trích xuất toàn bộ hệ thống tệp để tìm cách giành quyền truy cập root vào thiết bị. Sau đó là kiểm tra những dịch vụ nào đang chạy, debug để cuối cùng là kiểm soát mục tiêu (target). Khi bắt đầu quá trình kiểm tra, chúng ta thường gặp phải các biện pháp bảo vệ trên giao diện gỡ lỗi cấm truy cập vào đầy đủ chức năng của nó hoặc trên chuỗi khởi động cấm bất kỳ sửa đổi nào trên đó. Glitching là một cách để cố gắng vượt qua loại bảo vệ này. Glitching Glitching là một kỹ thuật tấn công trong bảo mật, trong đó kẻ tấn công cố tình gây ra sự cố hoặc nhiễu trong hệ thống để tạo ra các hành vi bất thường. Phương pháp này thường áp dụng cho các vi điều khiển hoặc thiết bị nhúng, nơi mà việc gây nhiễu tạm thời vào nguồn điện, xung nhịp, hoặc các tín hiệu khác có thể khiến hệ thống thực hiện các lệnh sai hoặc bỏ qua các bước kiểm tra an ninh. Điều này có thể dẫn đến việc tiết lộ thông tin nhạy cảm hoặc truy cập trái phép. ",
      "content_html": "\u003cp\u003e\u003cstrong\u003eFault Injection\u003c/strong\u003e là một kỹ thuật được sử dụng trong việc kiểm tra và đảm bảo độ tin cậy của các hệ thống phần mềm và phần cứng.\u003c/p\u003e\n\u003cp\u003eMục đích của kỹ thuật này là cố tình tạo ra các lỗi hoặc điều kiện bất thường trong hệ thống để xem hệ thống sẽ phản ứng như thế nào, từ đó đánh giá được tính ổn định và khả năng xử lý lỗi của hệ thống.\u003c/p\u003e\n\u003cp\u003eCó thể hiểu đơn giản rằng khi bạn phát triển một hệ thống, bạn luôn mong muốn nó hoạt động một cách hoàn hảo.\u003c/p\u003e\n\u003cp\u003eNhưng trong thực tế, có nhiều yếu tố như lỗi phần cứng, lỗi phần mềm, hoặc những sự cố bất ngờ từ môi trường ngoài có thể ảnh hưởng đến hệ thống.\u003c/p\u003e\n\u003cp\u003eFault injection giúp mô phỏng những tình huống này bằng cách cố tình đưa ra các lỗi, ví dụ như:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eLỗi phần cứng\u003c/strong\u003e: Giả lập các vấn đề như bộ nhớ bị lỗi, đường truyền bị gián đoạn. \u003c/br\u003e\n\u003cstrong\u003eLỗi phần mềm\u003c/strong\u003e: Gây ra lỗi trong code như chia cho 0, tràn bộ đệm (buffer overflow), hoặc làm hỏng dữ liệu. \u003c/br\u003e\n\u003cstrong\u003eĐiều kiện thời gian\u003c/strong\u003e: Gây trễ (delay) hoặc thay đổi thời gian xử lý để kiểm tra khả năng xử lý của hệ thống trong những điều kiện bất lợi. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMục tiêu của Fault Injection là đảm bảo hệ thống có thể hoạt động tốt, hoặc ít nhất là không bị phá hỏng hoàn toàn, khi xảy ra các lỗi này.\u003c/p\u003e\n\u003cp\u003eĐây là một phương pháp rất hữu ích trong việc tăng cường độ tin cậy và an toàn của các hệ thống, đặc biệt là trong các ứng dụng quan trọng như hàng không, ô tô, y tế, hay các hệ thống nhúng.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.techtarget.com/rms/onlineimages/whatis-fault_injection_testing.png\"\n  alt=\"Fault Injection\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"bài-viết-how-to-voltage-fault-injectionhttpswwwsynacktivcompublicationshow-to-voltage-fault-injection\"\u003eBài viết \u003ca href=\"https://www.synacktiv.com/publications/how-to-voltage-fault-injection\"\u003eHow to voltage fault injection\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTrong quá trình đánh giá bảo mật vật lý của thiết bị IoT, một trong những mục tiêu là \u003cstrong\u003etận dụng giao diện gỡ lỗi\u003c/strong\u003e của chip để có thể truy cập và nghiên cứu cách hoạt động của thiết bị. \u003c/br\u003e\nMột kịch bản lý tưởng là trích xuất toàn bộ hệ thống tệp để \u003cstrong\u003etìm cách giành quyền truy cập root vào thiết bị\u003c/strong\u003e. Sau đó là \u003cem\u003ekiểm tra những dịch vụ nào đang chạy\u003c/em\u003e, \u003cem\u003edebug\u003c/em\u003e để cuối cùng là kiểm soát mục tiêu (target). \u003c/br\u003e\nKhi bắt đầu quá trình kiểm tra, chúng ta thường gặp phải các biện pháp bảo vệ trên giao diện gỡ lỗi cấm truy cập vào đầy đủ chức năng của nó hoặc trên chuỗi khởi động cấm bất kỳ sửa đổi nào trên đó. \u003c/br\u003e\n\u003ccode\u003eGlitching\u003c/code\u003e là một cách để cố gắng vượt qua loại bảo vệ này. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"glitching\"\u003eGlitching\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGlitching là một kỹ thuật tấn công trong bảo mật, trong đó kẻ tấn công cố tình gây ra sự cố hoặc nhiễu trong hệ thống để tạo ra các hành vi bất thường.\u003c/li\u003e\n\u003cli\u003ePhương pháp này thường áp dụng cho các vi điều khiển hoặc thiết bị nhúng, nơi mà việc gây nhiễu tạm thời vào nguồn điện, xung nhịp, hoặc các tín hiệu khác có thể khiến hệ thống thực hiện các lệnh sai hoặc bỏ qua các bước kiểm tra an ninh.\u003c/li\u003e\n\u003cli\u003eĐiều này có thể dẫn đến việc tiết lộ thông tin nhạy cảm hoặc truy cập trái phép.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/fault_injection/",
      "date_published": "5106-05-09T1013:55:00+07:00",
      "date_modified": "5106-05-09T1013:55:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a4fba5c94b9684813ebdfb7f5ee87834050fd32",
      "title": "Car_Hacking",
      "summary": "",
      "content_text": "Book: The Car Hacker Handbook Trong quá trình tìm hiểu về CAN - OBDII vô tình lụm được tài liệu về Car Hacking.\nCó những thông tin, kiến thức mà thông thường tìm hiểu về CAN-Bus sẽ không thấy. Từ những key-work này lại tiếp tục research thêm, và có thêm được những thông tin thú vị khác.\nCAN Bus Packet Điểm đặc trưng của CAN bus là các gói tin được phát quảng bá (broadcast) đến tất cả các thiết bị (controllers) trên cùng mạng, giống như cách UDP hoạt động trên mạng Ethernet.\nMột số vấn đề chính liên quan đến cơ chế này:\nPhát quảng bá trên CAN bus Trong mạng CAN bus, các gói tin (packets) được gửi ra sẽ không chỉ định đích cụ thể cho một thiết bị nào mà thay vào đó, tất cả các node (thiết bị) trên bus sẽ nhận được gói tin đó. Điều này có nghĩa là:\nMọi thiết bị trên cùng một mạng CAN đều nhìn thấy mọi gói tin. Các thiết bị sẽ tự quyết định liệu có xử lý gói tin hay bỏ qua nó, dựa trên ID của gói tin. Gói tin chứa một trường ID (identifier) để các thiết bị nhận diện loại dữ liệu và quyết định liệu nó có phải xử lý thông tin hay không. Không có thông tin về nguồn gốc của gói tin Các gói tin trên CAN bus không chứa thông tin về nguồn gốc (tức là không có địa chỉ của thiết bị gửi), mà chỉ có ID của thông điệp. Điều này tạo ra một số vấn đề:\nKhông có cách để biết được thiết bị nào đã gửi gói tin, điều này có thể gây ra khó khăn trong việc giám sát và bảo mật. Giả lập thiết bị khác: Bất kỳ thiết bị nào trên mạng CAN đều có thể gửi gói tin với ID bất kỳ. Điều này có nghĩa là nếu một thiết bị hoặc một kẻ tấn công muốn giả lập một thiết bị khác, họ có thể dễ dàng gửi các gói tin với ID của thiết bị cần giả lập, khiến các thiết bị khác nghĩ rằng dữ liệu đến từ thiết bị chính thức. Tấn công trên CAN bus Do tính chất mở và phát quảng bá của CAN bus, nó dễ trở thành mục tiêu cho các cuộc tấn công:\nTấn công giả lập (Spoofing): Như đã nêu, kẻ tấn công có thể gửi các gói tin giả mạo từ một thiết bị khác mà các node khác không thể phân biệt được, vì CAN không có cách để xác minh nguồn gốc của gói tin. Tấn công phát ngập (Flooding): Kẻ tấn công có thể phát liên tục các gói tin với độ ưu tiên cao, làm tắc nghẽn mạng, ngăn các thiết bị khác truyền thông tin. Tấn công từ chối dịch vụ (DoS): Bằng cách phát đi các gói tin không hợp lệ hoặc giả mạo, kẻ tấn công có thể làm gián đoạn hoạt động của hệ thống CAN. Bảo mật hạn chế trên CAN bus Do CAN bus ban đầu được thiết kế cho các hệ thống nhúng không kết nối với bên ngoài (như ô tô, máy móc công nghiệp), bảo mật không được ưu tiên trong thiết kế của giao thức:\nKhông có cơ chế xác thực: CAN bus không có cơ chế tích hợp để xác thực nguồn gốc của các gói tin. Không có mã hóa: Dữ liệu truyền trên CAN bus không được mã hóa, vì vậy bất kỳ thiết bị nào trên mạng cũng có thể đọc được toàn bộ nội dung của các gói tin. Giải pháp bảo mật Vì các vấn đề bảo mật vốn có của CAN bus, các giải pháp bảo mật cần được thiết kế thêm ở cấp độ ứng dụng hoặc hệ thống, bao gồm:\nXác thực gói tin: Sử dụng các giải pháp xác thực ở mức ứng dụng để kiểm tra xem gói tin có được gửi từ nguồn tin cậy không. Mã hóa dữ liệu: Mặc dù CAN bus không hỗ trợ mã hóa dữ liệu nội tại, các giải pháp mã hóa có thể được thêm vào ở lớp ứng dụng để bảo vệ dữ liệu nhạy cảm. Giám sát mạng CAN: Các hệ thống giám sát (IDS/IPS) có thể được sử dụng để phát hiện các hành vi bất thường trên mạng, như tấn công phát ngập hoặc giả lập thiết bị. Tools SocketCAN SocketCAN là một framework trong Linux giúp quản lý và giao tiếp với CAN bus thông qua giao diện lập trình socket, giống như cách xử lý các giao tiếp mạng khác như Ethernet. Nó giúp lập trình viên dễ dàng sử dụng CAN bus mà không cần phải tìm hiểu các giao thức phức tạp hoặc các driver riêng biệt.\nInstall can-utils: sudo apt-get install can-utils Nhìn chung đây là một công cụ phần mềm dành cho CAN-Bus (giống như công cụ minicom dành cho cổng Serial). Do đó mình sẽ cần một thiết bị phần cứng để giao tiếp CAN-Bus, giống như trong video MCP2515 CAN Bus Module Tutorial with Arduino and Linux Wireshark Đây là công cụ quá phổ biến cho việc bắt gói tin. Do đó mình có thể dùng wireshark để bắt gói tin của CAN. Để bắt được gói tin CAN, thì mình cần dùng kết hợp giữa SocketCAN với Wireshark. Đôi khi wireshark không thể lắng nghe thiết bị slcanX, do đó mình sẽ cần dùng các command có trong bộ công cụ can-utils: candump cansniffer Kayak is an application for CAN bus diagnosis and monitoring. Github Project Kayak- tutorial Features: - view raw CAN data on a bus - view CAN frames interpreted as signals and messages - XML-based bus definitions - connect to to multiple CAN busses on different machines at once - multiple users can connect to the same CAN bus using a single CAN controller - no platform dependend code - core library without dependencies for use in other applications that need to handle CAN frames - rich client application (Netbeans RCP) - easily write your own plugins using the Netbeans plugin system ECUsim OBD simulator ECUsim 2000: Simulators can generate faults and MIL lights, and they include fault knobs for changing common vehicle parameters, such as speed.\nDocument: ECUsim 2000 User Guide Document: ECUsim Programming Manual Other Documents OBD CAN Bus Equipped Vehicles ECU PIN-OUT DIAGRAMS ChipWhisperer getting-started Documentation Home Education \u0026amp; Training ",
      "content_html": "\u003ch1 id=\"book-the-car-hacker-handbookhttpsdocsalexomarcombibliotecathecarhackershandbookpdf\"\u003eBook: \u003ca href=\"https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf\"\u003eThe Car Hacker Handbook\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Car_Hacking/Car_Hacking.jpg\"\n  alt=\"Car Hacking\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eTrong quá trình tìm hiểu về \u003ccode\u003eCAN - OBDII\u003c/code\u003e vô tình \u003cstrong\u003elụm\u003c/strong\u003e được tài liệu về \u003cstrong\u003eCar Hacking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCó những thông tin, kiến thức mà thông thường tìm hiểu về CAN-Bus sẽ không thấy. Từ những \u003cstrong\u003ekey-work\u003c/strong\u003e này lại tiếp tục research thêm, và có thêm được những thông tin thú vị khác.\u003c/p\u003e\n\u003ch2 id=\"can-bus-packet\"\u003eCAN Bus Packet\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Car_Hacking/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐiểm đặc trưng của CAN bus là các gói tin được phát quảng bá \u003cstrong\u003e(broadcast)\u003c/strong\u003e đến tất cả các thiết bị (controllers) trên cùng mạng, giống như cách UDP hoạt động trên mạng Ethernet.\u003c/p\u003e\n\u003cp\u003eMột số vấn đề chính liên quan đến cơ chế này:\u003c/p\u003e\n\u003ch3 id=\"phát-quảng-bá-trên-can-bus\"\u003ePhát quảng bá trên CAN bus\u003c/h3\u003e\n\u003cp\u003eTrong mạng CAN bus, các gói tin (packets) được gửi ra sẽ không chỉ định đích cụ thể cho một thiết bị nào mà thay vào đó, tất cả các node (thiết bị) trên bus sẽ nhận được gói tin đó. Điều này có nghĩa là:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eMọi thiết bị trên cùng một mạng CAN đều nhìn thấy mọi gói tin\u003c/strong\u003e. \u003c/br\u003e\nCác thiết bị sẽ tự quyết định liệu có xử lý gói tin hay bỏ qua nó, dựa trên ID của gói tin. Gói tin chứa một trường ID (identifier) để các thiết bị nhận diện loại dữ liệu và quyết định liệu nó có phải xử lý thông tin hay không. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"không-có-thông-tin-về-nguồn-gốc-của-gói-tin\"\u003eKhông có thông tin về nguồn gốc của gói tin\u003c/h3\u003e\n\u003cp\u003eCác gói tin trên CAN bus không chứa thông tin về nguồn gốc (tức là không có địa chỉ của thiết bị gửi), mà chỉ có ID của thông điệp. Điều này tạo ra một số vấn đề:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eKhông có cách để biết được thiết bị nào đã gửi gói tin\u003c/strong\u003e, điều này có thể gây ra khó khăn trong việc giám sát và bảo mật. \u003c/br\u003e\n\u003cstrong\u003eGiả lập thiết bị khác\u003c/strong\u003e: Bất kỳ thiết bị nào trên mạng CAN đều có thể gửi gói tin với ID bất kỳ. Điều này có nghĩa là nếu một thiết bị hoặc một kẻ tấn công muốn giả lập một thiết bị khác, họ có thể dễ dàng gửi các gói tin với ID của thiết bị cần giả lập, khiến các thiết bị khác nghĩ rằng dữ liệu đến từ thiết bị chính thức. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tấn-công-trên-can-bus\"\u003eTấn công trên CAN bus\u003c/h3\u003e\n\u003cp\u003eDo tính chất mở và phát quảng bá của CAN bus, nó dễ trở thành mục tiêu cho các cuộc tấn công:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTấn công giả lập (Spoofing)\u003c/strong\u003e: Như đã nêu, kẻ tấn công có thể gửi các gói tin giả mạo từ một thiết bị khác mà các node khác không thể phân biệt được, vì CAN không có cách để xác minh nguồn gốc của gói tin. \u003c/br\u003e\n\u003cstrong\u003eTấn công phát ngập (Flooding)\u003c/strong\u003e: Kẻ tấn công có thể phát liên tục các gói tin với độ ưu tiên cao, làm tắc nghẽn mạng, ngăn các thiết bị khác truyền thông tin. \u003c/br\u003e\n\u003cstrong\u003eTấn công từ chối dịch vụ (DoS)\u003c/strong\u003e: Bằng cách phát đi các gói tin không hợp lệ hoặc giả mạo, kẻ tấn công có thể làm gián đoạn hoạt động của hệ thống CAN. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"bảo-mật-hạn-chế-trên-can-bus\"\u003eBảo mật hạn chế trên CAN bus\u003c/h3\u003e\n\u003cp\u003eDo CAN bus ban đầu được thiết kế cho các hệ thống nhúng không kết nối với bên ngoài (như ô tô, máy móc công nghiệp), bảo mật không được ưu tiên trong thiết kế của giao thức:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eKhông có cơ chế xác thực\u003c/strong\u003e: CAN bus không có cơ chế tích hợp để xác thực nguồn gốc của các gói tin. \u003c/br\u003e\n\u003cstrong\u003eKhông có mã hóa\u003c/strong\u003e: Dữ liệu truyền trên CAN bus không được mã hóa, vì vậy bất kỳ thiết bị nào trên mạng cũng có thể đọc được toàn bộ nội dung của các gói tin. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"giải-pháp-bảo-mật\"\u003eGiải pháp bảo mật\u003c/h3\u003e\n\u003cp\u003eVì các vấn đề bảo mật vốn có của CAN bus, các giải pháp bảo mật cần được thiết kế thêm ở cấp độ ứng dụng hoặc hệ thống, bao gồm:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eXác thực gói tin\u003c/strong\u003e: Sử dụng các giải pháp xác thực ở mức ứng dụng để kiểm tra xem gói tin có được gửi từ nguồn tin cậy không. \u003c/br\u003e\n\u003cstrong\u003eMã hóa dữ liệu\u003c/strong\u003e: Mặc dù CAN bus không hỗ trợ mã hóa dữ liệu nội tại, các giải pháp mã hóa có thể được thêm vào ở lớp ứng dụng để bảo vệ dữ liệu nhạy cảm. \u003c/br\u003e\n\u003cstrong\u003eGiám sát mạng CAN\u003c/strong\u003e: Các hệ thống giám sát (IDS/IPS) có thể được sử dụng để phát hiện các hành vi bất thường trên mạng, như tấn công phát ngập hoặc giả lập thiết bị. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"tools\"\u003eTools\u003c/h2\u003e\n\u003ch3 id=\"socketcan\"\u003eSocketCAN\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSocketCAN là một framework trong Linux giúp quản lý và giao tiếp với CAN bus thông qua giao diện lập trình socket, giống như cách xử lý các giao tiếp mạng khác như Ethernet. Nó giúp lập trình viên dễ dàng sử dụng CAN bus mà không cần phải tìm hiểu các giao thức phức tạp hoặc các driver riêng biệt.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Car_Hacking/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstall \u003ca href=\"https://github.com/linux-can/can-utils\"\u003ecan-utils\u003c/a\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo apt-get install can-utils\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eNhìn chung đây là một công cụ phần mềm dành cho CAN-Bus \u003cem\u003e(giống như công cụ minicom dành cho cổng Serial)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eDo đó mình sẽ cần một \u003ca href=\"https://www.amazon.com/dp/B07P9JGXXB?ref=ppx_yo2ov_dt_b_product_details\u0026amp;th=1\"\u003ethiết bị phần cứng\u003c/a\u003e để giao tiếp CAN-Bus, giống như trong video \u003ca href=\"https://www.youtube.com/watch?v=GA-KNEuAR9w\"\u003eMCP2515 CAN Bus Module Tutorial with Arduino and Linux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"wireshark\"\u003eWireshark\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là công cụ quá phổ biến cho việc bắt gói tin.\u003c/li\u003e\n\u003cli\u003eDo đó mình có thể dùng \u003cem\u003ewireshark\u003c/em\u003e để bắt gói tin của CAN.\u003c/li\u003e\n\u003cli\u003eĐể bắt được gói tin CAN, thì mình cần dùng kết hợp giữa \u003cstrong\u003eSocketCAN\u003c/strong\u003e với \u003cstrong\u003eWireshark\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐôi khi wireshark không thể lắng nghe thiết bị \u003ccode\u003eslcanX\u003c/code\u003e, do đó mình sẽ cần dùng các command có trong bộ công cụ \u003cstrong\u003ecan-utils\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecandump\ncansniffer\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"kayakhttpsdschanoehgithubiokayak-is-an-application-for-can-bus-diagnosis-and-monitoring\"\u003e\u003ca href=\"https://dschanoeh.github.io/Kayak/\"\u003eKayak\u003c/a\u003e is an application for CAN bus diagnosis and monitoring.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/dschanoeh/Kayak\"\u003eGithub Project\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dschanoeh.github.io/Kayak/tutorial.html\"\u003eKayak- tutorial\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eFeatures:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- view raw CAN data on a bus\n- view CAN frames interpreted as signals and messages\n- XML-based bus definitions\n- connect to to multiple CAN busses on different machines at once\n- multiple users can connect to the same CAN bus using a single CAN controller\n- no platform dependend code\n- core library without dependencies for use in other applications that need to handle CAN frames\n- rich client application (Netbeans RCP)\n- easily write your own plugins using the Netbeans plugin system\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"ecusim-obd-simulator\"\u003eECUsim OBD simulator\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.obdsol.com/solutions/development-tools/obd-simulators/ecusim-2000/\"\u003eECUsim 2000\u003c/a\u003e: Simulators can generate faults and MIL lights, and they include fault knobs for changing common vehicle parameters, such as speed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.scantool.net/static/images/products/ecusim_2000/ecusim_2000_diagram_web.png\"\n  alt=\"ECUsim 2000\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDocument: \u003ca href=\"https://www.scantool.net/scantool/downloads/101/ecusim_2000-ug.pdf\"\u003eECUsim 2000 User Guide\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocument: \u003ca href=\"https://www.scantool.net/static/documentation/ecusim/ecusim-pm.pdf\"\u003eECUsim Programming Manual\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"other-documents\"\u003eOther Documents\u003c/h2\u003e\n\u003ch3 id=\"obd-can-bus-equipped-vehicleshttpwwwauterrawebcomaboutcanhtml\"\u003e\u003ca href=\"http://www.auterraweb.com/aboutcan.html\"\u003eOBD CAN Bus Equipped Vehicles\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"ecu-pin-out-diagramshttpswwwinnovatemotorsportscomecu-pin-out-diagrams\"\u003e\u003ca href=\"https://www.innovatemotorsports.com/ecu-pin-out-diagrams/\"\u003eECU PIN-OUT DIAGRAMS\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"chipwhispererhttpswwwnewaecomchipwhisperer\"\u003e\u003ca href=\"https://www.newae.com/chipwhisperer\"\u003eChipWhisperer\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://chipwhisperer.readthedocs.io/en/latest/getting-started.html\"\u003egetting-started\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://rtfm.newae.com/\"\u003eDocumentation Home\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.newae.com/education\"\u003eEducation \u0026amp; Training\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/car_hacking/",
      "date_published": "5106-05-09T1055:55:00+07:00",
      "date_modified": "5106-05-09T1055:55:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1d6e1d9d82c5e034cbee811a39d8ea0cdf4dfb8b",
      "title": "Rust Lang",
      "summary": "",
      "content_text": " Ngày Mô tả 1/4/2024 Khởi tạo bài viết 17/8/2024 Cập nhật bài viết, thêm thông tin về Rust-lang 13/9/2024 Update thêm documents về Rust Hạn chế Năm 2023 xảy ra nhiều dramma của Rust Found Rust là ngôn ngữ khó học, code khó. 5 things I wish I knew before learning Rust Why do developers hate Rust? Cộng đồng DEV chưa quá đông như Golang. Top Programming Languages 2023 Lợi ích Rust là ngôn ngữ low level, được sử dụng cho nhiều mục đích khác nhau: Dùng để code nhúng. Dùng để code phía Server. Có thể dùng để code OS - như Rust for Linux Rust chú trọng vào sự an toàn - memory safety. Cộng đồng Rust vẫn đang phát triển. Dựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang Rust Roadmap Tài liệu về Rust Rust IDE - RustRover\nThe Embedded Rust Book\nStandard library developers Guide\nBlog Rust\nRust By Example\nRust Tiếng Việt\nYoutube - Crust of Rust\nYoutube - Let\u0026rsquo;s Get Rusty\nRust Cheatsheet\nWriting an OS in Rust\nCập nhật 17/8/2024 Youtube: Where is Rust being used? Tổng hợp Rust is for Robotics Project ros2_rust Project CleanIt Doc: Offline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard nostd-wifi-lamp esp32c3-no-std-async-mqtt-demo Framework cho MQTT cho Rust: rumqtt rust-mqtt Framework NATS for Rust: nats.rs Có thể sử dụng NATS cho ThingsBoard. Sample code từ ChatGPT: use nats::asynk::Connection; use serde::{Deserialize, Serialize}; use serde_json::json; use tokio::time::{sleep, Duration}; #[derive(Debug, Serialize, Deserialize)] struct TelemetryData { device_id: String, temperature: f64, humidity: f64, timestamp: u64, } #[tokio::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { // Connect to the NATS server let nc: Connection = nats::asynk::connect(\u0026#34;demo.nats.io\u0026#34;).await?; // Subscribe to a subject where ThingsBoard publishes telemetry data let subscription = nc.subscribe(\u0026#34;thingsboard.telemetry\u0026#34;).await?; // Process incoming messages while let Some(msg) = subscription.next().await { // Parse the telemetry data (assumed to be JSON) let telemetry: TelemetryData = serde_json::from_slice(\u0026amp;msg.data).expect(\u0026#34;Failed to parse telemetry data\u0026#34;); println!(\u0026#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}\u0026#34;, telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp); // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject let response_subject = format!(\u0026#34;thingsboard.ack.{}\u0026#34;, telemetry.device_id); let ack_message = json!({ \u0026#34;device_id\u0026#34;: telemetry.device_id, \u0026#34;status\u0026#34;: \u0026#34;acknowledged\u0026#34;, \u0026#34;timestamp\u0026#34;: telemetry.timestamp }); nc.publish(\u0026amp;response_subject, ack_message.to_string().as_bytes()).await?; } Ok(()) } Cập nhật 13/9/2024 Bài viết: 35 Rust Learning Resources Every Beginner Should Know in 2022 Trong bài viết này tổng hợp rất nhiều documents cho beginner để bắt đầu với Rust. Ở đây mình thấy có những trang rất hay, ví dụ: Tour of Rust Trang này có tiếng Việt và có thêm phần để run code.\nA half-hour to learn Rust A Gentle Introduction To Rust Easy Rust ",
      "content_html": "\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust_Embedded.png\"\n  alt=\"Rust_Embedded\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1/4/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/8/2024\u003c/td\u003e\n\u003ctd\u003eCập nhật bài viết, thêm thông tin về Rust-lang\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e13/9/2024\u003c/td\u003e\n\u003ctd\u003eUpdate thêm documents về Rust\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"hạn-chế\"\u003eHạn chế\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://users.rust-lang.org/t/why-is-there-so-much-mismanagement-in-the-rust-foundation-and-core-team/94822\"\u003eNăm 2023 xảy ra nhiều dramma của Rust Found\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eRust là ngôn ngữ \u003cstrong\u003ekhó học, code khó\u003c/strong\u003e.\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=EYCBm0xAWow\u0026amp;list=LL\u0026amp;index=3\"\u003e5 things I wish I knew before learning Rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=fknamfNtKk0\"\u003eWhy do developers hate Rust?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCộng đồng \u003cstrong\u003eDEV\u003c/strong\u003e chưa quá đông như Golang. \u003ca href=\"https://spectrum.ieee.org/the-top-programming-languages-2023\"\u003eTop Programming Languages 2023\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"lợi-ích\"\u003eLợi ích\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRust là ngôn ngữ \u003cstrong\u003elow level\u003c/strong\u003e, được sử dụng cho nhiều mục đích khác nhau:\n\u003cul\u003e\n\u003cli\u003eDùng để code nhúng.\u003c/li\u003e\n\u003cli\u003eDùng để code phía Server.\u003c/li\u003e\n\u003cli\u003eCó thể dùng để code OS - như \u003ca href=\"https://rust-for-linux.com/\"\u003eRust for Linux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRust chú trọng vào sự an toàn - \u003cstrong\u003ememory safety\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCộng đồng Rust vẫn đang phát triển. \u003ca href=\"https://pypl.github.io/PYPL.html\"\u003eDựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"rust-roadmaphttpsroadmapshrust\"\u003e\u003ca href=\"https://roadmap.sh/rust\"\u003eRust Roadmap\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tài-liệu-về-rust\"\u003eTài liệu về Rust\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/help/rust/getting-started.html\"\u003eRust IDE - RustRover\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://docs.rust-embedded.org/book/\"\u003eThe Embedded Rust Book\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://std-dev-guide.rust-lang.org/\"\u003eStandard library developers Guide\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://blog.rust-lang.org/\"\u003eBlog Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/rust-by-example/index.html\"\u003eRust By Example\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://rust-tieng-viet.github.io/getting-started/first-project.html\"\u003eRust Tiếng Việt\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=rAl-9HwD858\u0026amp;list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa\u0026amp;index=3\"\u003eYoutube - Crust of Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/@letsgetrusty\"\u003eYoutube - Let\u0026rsquo;s Get Rusty\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://docs.google.com/document/d/1kQidzAlbqapu-WZTuw4Djik0uTqMZYyiMXTM9F21Dz4/edit?lid=75778#heading=h.gjdgxs\"\u003eRust Cheatsheet\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://os.phil-opp.com/\"\u003eWriting an OS in Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"cập-nhật-1782024\"\u003eCập nhật 17/8/2024\u003c/h1\u003e\n\u003ch3 id=\"youtube-where-is-rust-being-usedhttpswwwyoutubecomwatchv42fhqwq6sva\"\u003eYoutube: \u003ca href=\"https://www.youtube.com/watch?v=42FhQWQ6SVA\"\u003eWhere is Rust being used?\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"tổng-hợp-rust-is-for-roboticshttpsroboticsrs\"\u003eTổng hợp \u003ca href=\"https://robotics.rs/\"\u003eRust is for Robotics\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProject \u003ca href=\"https://github.com/ros2-rust/ros2_rust\"\u003eros2_rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eProject \u003ca href=\"https://github.com/Sollimann/CleanIt\"\u003eCleanIt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"doc-offline-first-smart-energy-monitor-with-rust-esp32-and-thingsboardhttpsmoslehiancomposts20223-ofmon\"\u003eDoc: \u003ca href=\"https://moslehian.com/posts/2022/3-ofmon/\"\u003eOffline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Nereuxofficial/nostd-wifi-lamp\"\u003enostd-wifi-lamp\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/JurajSadel/esp32c3-no-std-async-mqtt-demo\"\u003eesp32c3-no-std-async-mqtt-demo\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"framework-cho-mqtt-cho-rust-rumqtthttpsgithubcombytebeamiorumqtt\"\u003eFramework cho MQTT cho Rust: \u003ca href=\"https://github.com/bytebeamio/rumqtt\"\u003erumqtt\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/obabec/rust-mqtt\"\u003erust-mqtt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"framework-nats-for-rust-natsrshttpsgithubcomnats-ionatsrs\"\u003eFramework NATS for Rust: \u003ca href=\"https://github.com/nats-io/nats.rs\"\u003enats.rs\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó thể sử dụng NATS cho ThingsBoard.\u003c/li\u003e\n\u003cli\u003eSample code từ ChatGPT:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse nats::asynk::Connection;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse tokio::time::{sleep, Duration};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct TelemetryData {\n    device_id: String,\n    temperature: f64,\n    humidity: f64,\n    timestamp: u64,\n}\n\n#[tokio::main]\nasync fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; {\n    // Connect to the NATS server\n    let nc: Connection = nats::asynk::connect(\u0026#34;demo.nats.io\u0026#34;).await?;\n\n    // Subscribe to a subject where ThingsBoard publishes telemetry data\n    let subscription = nc.subscribe(\u0026#34;thingsboard.telemetry\u0026#34;).await?;\n\n    // Process incoming messages\n    while let Some(msg) = subscription.next().await {\n        // Parse the telemetry data (assumed to be JSON)\n        let telemetry: TelemetryData = serde_json::from_slice(\u0026amp;msg.data).expect(\u0026#34;Failed to parse telemetry data\u0026#34;);\n\n        println!(\u0026#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}\u0026#34;,\n                 telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp);\n\n        // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject\n        let response_subject = format!(\u0026#34;thingsboard.ack.{}\u0026#34;, telemetry.device_id);\n        let ack_message = json!({\n            \u0026#34;device_id\u0026#34;: telemetry.device_id,\n            \u0026#34;status\u0026#34;: \u0026#34;acknowledged\u0026#34;,\n            \u0026#34;timestamp\u0026#34;: telemetry.timestamp\n        });\n\n        nc.publish(\u0026amp;response_subject, ack_message.to_string().as_bytes()).await?;\n    }\n\n    Ok(())\n}\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch1 id=\"cập-nhật-1392024\"\u003eCập nhật 13/9/2024\u003c/h1\u003e\n\u003ch2 id=\"bài-viết-35-rust-learning-resources-every-beginner-should-know-in-2022httpsblogtheembeddedrustaceancom35-rust-learning-resources-every-beginner-should-know-in-2022\"\u003eBài viết: \u003ca href=\"https://blog.theembeddedrustacean.com/35-rust-learning-resources-every-beginner-should-know-in-2022\"\u003e35 Rust Learning Resources Every Beginner Should Know in 2022\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong bài viết này tổng hợp rất nhiều documents cho beginner để bắt đầu với Rust.\u003c/li\u003e\n\u003cli\u003eỞ đây mình thấy có những trang rất hay, ví dụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tour-of-rusthttpstourofrustcom\"\u003e\u003ca href=\"https://tourofrust.com/\"\u003eTour of Rust\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTrang này có tiếng Việt và có thêm phần để run code.\u003c/p\u003e\n\u003ch3 id=\"a-half-hour-to-learn-rusthttpsfasterthanlimearticlesa-half-hour-to-learn-rust\"\u003e\u003ca href=\"https://fasterthanli.me/articles/a-half-hour-to-learn-rust\"\u003eA half-hour to learn Rust\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"a-gentle-introduction-to-rusthttpsstevedonovangithubiorust-gentle-introreadmehtml\"\u003e\u003ca href=\"https://stevedonovan.github.io/rust-gentle-intro/readme.html\"\u003eA Gentle Introduction To Rust\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"easy-rusthttpsdhghomongithubioeasy_rustchapter_1html\"\u003e\u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_1.html\"\u003eEasy Rust\u003c/a\u003e\u003c/h3\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust-lang/",
      "date_published": "13096-13-09T914:1313:00+07:00",
      "date_modified": "13096-13-09T914:1313:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "6f5f5c06dee021d91043f0407390373f173cefb9",
      "title": "Hoi_thao_2024",
      "summary": "",
      "content_text": "Link Video: Hội thảo và Triển lãm An toàn Thông tin phía Nam 2024 Sau khi xem và nghe xong thì mình có nhiều thông tin hữu ích như sau\nThiết bị phần cứng - Khóa xác thực Với loại sản phẩm này thì bên VinCSS cũng có. Và ngoài ra, hiện tại HPT cũng đang bán sản phẩm chính hãng Khóa bảo mật Yubikey Mình đã mua 1 cái, sau khi xem clip của anh Duy Luân, link. Phishing Trong video thì có nói về 1 trong các kiểu tấn công phổ biến hiện nay, để từ đó trình bày cách phòng thủ cho phù hợp. Và thường thì quá trình tấn công của hacker hiện tại là phishing. Gửi email có mã độc \u0026mdash;\u0026gt; Cài malware vào máy nạn nhân trong tổ chức. Âm thầm mò mẫm trong hệ thống Network của tổ chức, và tìm cơ hội để tấn công vào Server. Backdoor Hacker thường cài cắm backdoor thường bằng 1 trong 3 cách. Thứ 1: Tạo Webshell, nguy cơ này đến từ việc sử dụng mã nguồn không hợp lệ. Thứ 2: Tạo account dễ nhầm lẫn. Giả sử hacker đã xâm nhập vào máy nạn nhân, vậy tránh bị phát hiện thì hacker sẽ tạo ra các account với tên bình thường để tránh bị phát hiện. Thứ 3: Dùng DLL (cái này thì mình cũng chưa rõ lắm). Backup Giờ mình mới biết có thuật ngữ mới backup 32110 Có ít nhất là 3 bản dữ liệu (kể cả bản đang vận hành). Vị trí đặt các bản sao phải ở 2 địa điểm khác nhau. Có ít nhất 1 bản copy đặt ở local. Có ít nhất 1 bản offline. Tất cả các bản backup phải đều không bị lỗi và có thể sử dụng được. NOTE: Một lưu ý quan trọng là tất cả data backup phải được mã hóa.\nCác hình ảnh được capture từ bài trình bày của nhóm Chống lừa đảo ",
      "content_html": "\u003ch2 id=\"link-video-hội-thảo-và-triển-lãm-an-toàn-thông-tin-phía-nam-2024httpswwwfacebookcomvnisahcmvideos1461942441187294\"\u003eLink Video: \u003ca href=\"https://www.facebook.com/VNISA.HCM/videos/1461942441187294\"\u003eHội thảo và Triển lãm An toàn Thông tin phía Nam 2024\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSau khi xem và nghe xong thì mình có nhiều thông tin hữu ích như sau\u003c/p\u003e\n\u003ch3 id=\"thiết-bị-phần-cứng---khóa-xác-thực\"\u003eThiết bị phần cứng - Khóa xác thực\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVới loại sản phẩm này thì bên VinCSS cũng có.\u003c/li\u003e\n\u003cli\u003eVà ngoài ra, hiện tại \u003cstrong\u003eHPT\u003c/strong\u003e cũng đang bán sản phẩm chính hãng \u003ca href=\"https://hpttechstore.com/collections/khoa-bao-mat-yubikey\"\u003eKhóa bảo mật Yubikey\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMình đã mua 1 cái, sau khi xem clip của anh Duy Luân, \u003ca href=\"https://www.youtube.com/watch?v=wmC7ZDJfHa0\"\u003elink.\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"phishing\"\u003ePhishing\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/4_layer.png\"\n  alt=\"4_layer\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video thì có nói về 1 trong các kiểu tấn công phổ biến hiện nay, để từ đó trình bày cách phòng thủ cho phù hợp.\u003c/li\u003e\n\u003cli\u003eVà thường thì quá trình tấn công của hacker hiện tại là \u003cstrong\u003ephishing\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGửi email\u003c/strong\u003e có mã độc \u0026mdash;\u0026gt; \u003cstrong\u003eCài malware\u003c/strong\u003e vào máy nạn nhân trong tổ chức.\u003c/li\u003e\n\u003cli\u003eÂm thầm \u003cem\u003emò mẫm\u003c/em\u003e trong \u003cstrong\u003ehệ thống Network\u003c/strong\u003e của tổ chức, và tìm cơ hội để \u003cstrong\u003etấn công vào Server\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"backdoor\"\u003eBackdoor\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/3_cach_backdoor.png\"\n  alt=\"backdoor\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHacker thường cài cắm backdoor thường bằng 1 trong 3 cách.\u003c/li\u003e\n\u003cli\u003eThứ 1: Tạo \u003cstrong\u003eWebshell\u003c/strong\u003e, nguy cơ này đến từ việc sử dụng mã nguồn không hợp lệ.\u003c/li\u003e\n\u003cli\u003eThứ 2: \u003cstrong\u003eTạo account dễ nhầm lẫn\u003c/strong\u003e. Giả sử hacker đã xâm nhập vào máy nạn nhân, vậy tránh bị phát hiện thì hacker sẽ tạo ra các account với tên \u003cstrong\u003ebình thường\u003c/strong\u003e để tránh bị phát hiện.\u003c/li\u003e\n\u003cli\u003eThứ 3: Dùng \u003cstrong\u003eDLL\u003c/strong\u003e (\u003cem\u003ecái này thì mình cũng chưa rõ lắm\u003c/em\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"backup\"\u003eBackup\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Backup_zip_code.png\"\n  alt=\"backup\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGiờ mình mới biết có thuật ngữ mới backup \u003ccode\u003e32110\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCó \u003cstrong\u003eít nhất\u003c/strong\u003e là 3 bản dữ liệu \u003cem\u003e(kể cả bản đang vận hành)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eVị trí đặt các bản sao phải ở \u003cstrong\u003e2 địa điểm\u003c/strong\u003e khác nhau.\u003c/li\u003e\n\u003cli\u003eCó ít nhất \u003cstrong\u003e1 bản copy đặt ở local\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCó ít nhất \u003cstrong\u003e1 bản offline\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTất cả các bản backup phải đều \u003cstrong\u003ekhông bị lỗi\u003c/strong\u003e và có thể sử dụng được.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: Một lưu ý quan trọng là tất cả data backup phải được mã hóa.\u003c/p\u003e\n\u003ch3 id=\"các-hình-ảnh-được-capture-từ-bài-trình-bày-của-nhóm-chống-lừa-đảo\"\u003eCác hình ảnh được capture từ bài trình bày của nhóm \u003cstrong\u003eChống lừa đảo\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_1.png\"\n  alt=\"Hình_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_2.png\"\n  alt=\"Hình_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_3.png\"\n  alt=\"Hình_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_4.png\"\n  alt=\"Hình_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_5.png\"\n  alt=\"Hình_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_6.png\"\n  alt=\"Hình_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_7.png\"\n  alt=\"Hình_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/hoi_thao_2024/",
      "date_published": "2096-02-09T929:22:00+07:00",
      "date_modified": "2096-02-09T929:22:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "02d4eeaa8ce44a303d67c920fd5c38f39c32a151",
      "title": "Box_RFID",
      "summary": "",
      "content_text": "Sau quá trình Research_CR95 và vất vả code FW cho bộ hộp đọc thẻ này.\nCuối cùng cũng đã hoàn thành.\nThông tin về bộ đọc thẻ RFID. Yêu cầu thông tin về thẻ tài xế GPLX: 12 ký tự số. Tên tài xế: Sử dụng ký tự chữ (Viết hoa). ID: 10 ký tự số Hộp đọc thẻ RFID Nếu đọc thẻ thành công, thì đèn led DN sẽ chớp sáng 1 lần.\nLần tag thẻ tiếp theo cần phải cách lần tag thẻ trước đó, ít nhất là 3s.\nFeature (Tính năng) Debug: Show debug, send command: IT_TRACE1 Turn off debug, send command: IT_TRACE0 Request Version: Send Response $DVSRFID,VER $DVSRFID,VER,1.2 Đọc thẻ Khi đặt thẻ vào bộ đọc, nếu đọc thành công, thiết bị sẽ gửi ra thông tin: $DVSRFID,READ,123456789012,NGUYENVANA,1234567890 Trong đó:\n123456789012: là thông tin về GPLX NGUYENVANA: là tên tài xế (NGUYEN VAN A) 1234567890: là thông tin ID Card Nếu thẻ bị lỗi thông tin, thì thiết bị sẽ trả ra: $DVSRFID,READ,,, ",
      "content_html": "\u003cp\u003eSau quá trình \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/hardware/research_cr95/\"\u003eResearch_CR95\u003c/a\u003e và vất vả code FW cho bộ hộp đọc thẻ này.\u003c/p\u003e\n\u003cp\u003eCuối cùng cũng đã hoàn thành.\u003c/p\u003e\n\u003ch1 id=\"thông-tin-về-bộ-đọc-thẻ-rfid\"\u003eThông tin về bộ đọc thẻ RFID.\u003c/h1\u003e\n\u003ch2 id=\"yêu-cầu-thông-tin-về-thẻ-tài-xế\"\u003eYêu cầu thông tin về thẻ tài xế\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGPLX\u003c/strong\u003e: 12 ký tự số.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTên tài xế\u003c/strong\u003e: Sử dụng ký tự chữ (Viết hoa).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eID\u003c/strong\u003e: 10 ký tự số\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"hộp-đọc-thẻ-rfid\"\u003eHộp đọc thẻ RFID\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/RFID_Box.jpg\"\n  alt=\"RFID\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eNếu đọc thẻ thành công, thì đèn led \u003cstrong\u003eDN\u003c/strong\u003e sẽ chớp sáng \u003cstrong\u003e1 lần\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLần tag thẻ tiếp theo\u003c/strong\u003e cần phải cách \u003cstrong\u003elần tag thẻ trước đó\u003c/strong\u003e, ít nhất là \u003cstrong\u003e3s\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"feature-tính-năng\"\u003eFeature (Tính năng)\u003c/h2\u003e\n\u003ch3 id=\"debug\"\u003eDebug:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eShow debug, send command: \u003ccode\u003eIT_TRACE1\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTurn off debug, send command: \u003ccode\u003eIT_TRACE0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"request-version\"\u003eRequest Version:\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eSend\u003c/th\u003e\n\u003cth\u003eResponse\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e$DVSRFID,VER\u003c/td\u003e\n\u003ctd\u003e$DVSRFID,VER,1.2\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"đọc-thẻ\"\u003eĐọc thẻ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đặt thẻ vào bộ đọc, nếu đọc thành công, thiết bị sẽ gửi ra thông tin:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$DVSRFID,READ,123456789012,NGUYENVANA,1234567890\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTrong đó:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e123456789012\u003c/strong\u003e: là thông tin về GPLX \u003cbr\u003e\n\u003cstrong\u003eNGUYENVANA\u003c/strong\u003e: là tên tài xế (NGUYEN VAN A) \u003cbr\u003e\n\u003cstrong\u003e1234567890\u003c/strong\u003e: là thông tin ID Card \u003cbr\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eNếu thẻ bị lỗi thông tin, thì thiết bị sẽ trả ra:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$DVSRFID,READ,,,\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/box_rfid/",
      "date_published": "29086-29-09T838:2929:00+07:00",
      "date_modified": "29086-29-09T838:2929:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "afef4961bf5cabcf54173cd8303e7abbfd2bf1ec",
      "title": "NFC_PWA",
      "summary": "",
      "content_text": "Một số bài viết về việc sử dụng Web PWA để đánh cắp thông tin: https://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa https://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/ https://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info Github project: nfcgate https://github.com/nfcgate/nfcgate/tree/v2/doc https://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md https://github.com/nfcgate/nfcgate/tree/v2/doc/mode Ghi chú theo cách hiểu của bản thân Lúc trước mình có tìm hiểu qua về Web PWA (lúc đó có nghiên cứu về bluetooth trên di động). Với các ứng dụng web PWA thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động. Đầu tiên đầu tiên là dẫn dụ (có thể qua phishing) cài đặt một ứng dụng (có chứa malware) bằng đường link Web PWA. Dùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native. Lúc này hacker dùng nfcgate để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch. Khi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân. Như trong Video Youtube ",
      "content_html": "\u003ch3 id=\"một-số-bài-viết-về-việc-sử-dụng-web-pwa-để-đánh-cắp-thông-tin\"\u003eMột số bài viết về việc sử dụng Web PWA để đánh cắp thông tin:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa\nhttps://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/\nhttps://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"github-project-nfcgatehttpsgithubcomnfcgatenfcgate\"\u003eGithub project: \u003ca href=\"https://github.com/nfcgate/nfcgate\"\u003enfcgate\u003c/a\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/nfcgate/nfcgate/tree/v2/doc\nhttps://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md\nhttps://github.com/nfcgate/nfcgate/tree/v2/doc/mode\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"ghi-chú-theo-cách-hiểu-của-bản-thân\"\u003eGhi chú theo cách hiểu của bản thân\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước mình có tìm hiểu qua về \u003cstrong\u003eWeb PWA\u003c/strong\u003e (lúc đó có nghiên cứu về \u003cem\u003ebluetooth\u003c/em\u003e trên di động).\u003c/li\u003e\n\u003cli\u003eVới các ứng dụng web \u003ccode\u003ePWA\u003c/code\u003e thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/NFC_PWA/entire-process.webp\"\n  alt=\"entire-process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐầu tiên đầu tiên là dẫn dụ \u003cem\u003e(có thể qua phishing)\u003c/em\u003e cài đặt một ứng dụng (có chứa malware) bằng đường link \u003cstrong\u003eWeb PWA\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native.\u003c/li\u003e\n\u003cli\u003eLúc này hacker dùng \u003cstrong\u003enfcgate\u003c/strong\u003e để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/NFC_PWA/nfc-replay.webp\"\n  alt=\"nfc-replay\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân.\u003c/li\u003e\n\u003cli\u003eNhư trong \u003ca href=\"https://youtu.be/q69--5rdlmI\"\u003eVideo Youtube\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/nfc_pwa/",
      "date_published": "27086-27-09T847:2727:00+07:00",
      "date_modified": "27086-27-09T847:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "377c454df8e403d4adbd6e21b260c4d8c1a7686c",
      "title": "Radxa_X4",
      "summary": "",
      "content_text": "Thông tin: https://www.youtube.com/watch?v=F2atAHDOaIA https://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040 https://github.com/geerlingguy/sbc-reviews/issues/48 https://radxa.com/products/x/x4/ Giải thích theo cách hiểu cá nhân: Cụm từ x86 with a side of Arm trong trường hợp của Radxa X4 SBC (Single Board Computer) mô tả việc tích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.\nĐiều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.\nGiải thích cụ thể:\nIntel N100 và Kiến trúc x86: Intel N100 đây là một bộ vi xử lý x86 của Intel, thuộc dòng Alder Lake-N, sử dụng kiến trúc x86-64. X86 được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó. Ứng dụng: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ. Raspberry Pi RP2040 và Kiến trúc ARM: RP2040: Đây là một bộ vi điều khiển dựa trên kiến trúc ARM Cortex-M0+ do Raspberry Pi Foundation phát triển. Đây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực. Ứng dụng: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng. Tại sao sử dụng cả x86 và ARM trên cùng một bo mạch? Sử dụng tối ưu tài nguyên: x86: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. ARM: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. Tăng tính linh hoạt và hiệu suất:\nSự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính Đồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn. Điều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng. Tính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.\nKết luận: Radxa X4 SBC mô tả việc kết hợp cả hai kiến trúc trong một thiết bị Sử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực. Đây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống. ",
      "content_html": "\u003ch3 id=\"thông-tin\"\u003eThông tin:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=F2atAHDOaIA\nhttps://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040\nhttps://github.com/geerlingguy/sbc-reviews/issues/48\nhttps://radxa.com/products/x/x4/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://radxa.com/x/x4/banner_radxa_x4.webp\"\n  alt=\"radxa_x4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch1 id=\"giải-thích-theo-cách-hiểu-cá-nhân\"\u003eGiải thích theo cách hiểu cá nhân:\u003c/h1\u003e\n\u003cp\u003eCụm từ \u003cstrong\u003ex86 with a side of Arm\u003c/strong\u003e trong trường hợp của \u003ccode\u003eRadxa X4 SBC (Single Board Computer)\u003c/code\u003e mô tả việc \u003cstrong\u003etích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch\u003c/strong\u003e, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.\u003c/p\u003e\n\u003cp\u003eĐiều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.\u003c/p\u003e\n\u003cp\u003eGiải thích cụ thể:\u003c/p\u003e\n\u003ch3 id=\"intel-n100-và-kiến-trúc-x86\"\u003eIntel N100 và Kiến trúc x86:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eIntel N100\u003c/strong\u003e đây là một bộ \u003cstrong\u003evi xử lý x86\u003c/strong\u003e của Intel, thuộc dòng Alder Lake-N, sử dụng \u003ccode\u003ekiến trúc x86-64\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eX86\u003c/strong\u003e được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó.\u003c/li\u003e\n\u003cli\u003e\u003cmark\u003eỨng dụng\u003c/mark\u003e: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raspberry-pi-rp2040-và-kiến-trúc-arm\"\u003eRaspberry Pi RP2040 và Kiến trúc ARM:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRP2040\u003c/strong\u003e: Đây là một bộ \u003cstrong\u003evi điều khiển\u003c/strong\u003e dựa trên \u003ccode\u003ekiến trúc ARM Cortex-M0+\u003c/code\u003e do Raspberry Pi Foundation phát triển.\u003c/li\u003e\n\u003cli\u003eĐây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực.\u003c/li\u003e\n\u003cli\u003e\u003cmark\u003eỨng dụng\u003c/mark\u003e: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tại-sao-sử-dụng-cả-x86-và-arm-trên-cùng-một-bo-mạch\"\u003eTại sao sử dụng cả x86 và ARM trên cùng một bo mạch?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSử dụng tối ưu tài nguyên:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ex86\u003c/strong\u003e: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. \u003cbr\u003e\n\u003cstrong\u003eARM\u003c/strong\u003e: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. \u003cbr\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTăng tính linh hoạt và hiệu suất:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính\u003c/li\u003e\n\u003cli\u003eĐồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn.\u003c/li\u003e\n\u003cli\u003eĐiều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kết-luận\"\u003eKết luận:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRadxa X4 SBC mô tả việc \u003cstrong\u003ekết hợp cả hai kiến trúc trong một thiết bị\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eSử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực.\u003c/li\u003e\n\u003cli\u003eĐây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/radxa_x4/",
      "date_published": "27086-27-09T839:2727:00+07:00",
      "date_modified": "27086-27-09T839:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "34c808d0a63f277e04fb23a5f76cc83d0a3e024b",
      "title": "News",
      "summary": "",
      "content_text": "Changelog Ngày Mô tả 10/4/2024 Khởi tạo bài viết 26/8/2024 Cập nhật một số trang blog và youtube về chủ đề Hardware Hacking Đây là danh sách các kênh mà mình cập nhật tin tức. Cũng như bổ sung kiến thức. Danh sách các kênh tài liệu và Youtube để cập nhật kiến thức. Các trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm: NCSC VN Whitehat Còn trang của nước ngoài thì gồm (trong đó có telegram): Cyber Security News Telegram: Cyber Threat Intelligence Kênh youtube: Mình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới. Các kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System. Ngày 26/8/2024 Một số trang blog và kênh Youtube về Hardware Hacking\nNCC Group Matt Brown: IoT Pentester \u0026amp; Hardware Security Researcher Blog Youtube Channel: Matt Brown hextree.io: Một nền tảng học tập về hacking. Youtube Channel: LiveOverflow IoT Pentesting Guide IoTSecurity101 GameHacking.GG Trò chơi để luyện tập về reverse và hacking game. Github Hướng dẫn synacktiv Publications Advisories Resources ",
      "content_html": "\u003ch3 id=\"changelog\"\u003eChangelog\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e10/4/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e26/8/2024\u003c/td\u003e\n\u003ctd\u003eCập nhật một số trang blog và youtube về chủ đề Hardware Hacking\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là danh sách các kênh mà mình cập nhật tin tức.\u003c/li\u003e\n\u003cli\u003eCũng như bổ sung kiến thức.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"danh-sách-các-kênh-tài-liệu-và-youtube-để-cập-nhật-kiến-thức\"\u003eDanh sách các kênh tài liệu và Youtube để cập nhật kiến thức.\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ncsc-vnhttpstinnhiemmangvnnoi-bat\"\u003e\u003ca href=\"https://tinnhiemmang.vn/noi-bat\"\u003eNCSC VN\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"whitehathttpswhitehatvn\"\u003e\u003ca href=\"https://whitehat.vn/\"\u003eWhitehat\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCòn trang của nước ngoài thì gồm (trong đó có telegram):\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"cyber-security-newshttpscybersecuritynewscom\"\u003e\u003ca href=\"https://cybersecuritynews.com/\"\u003eCyber Security News\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"telegram-cyber-threat-intelligencehttpstmectinow\"\u003e\u003ca href=\"https://t.me/ctinow\"\u003eTelegram: Cyber Threat Intelligence\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"kênh-youtube\"\u003eKênh youtube:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới.\u003c/li\u003e\n\u003cli\u003eCác kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Top_Youtube_Channel_Hacking.jpg\"\n  alt=\"Youtube\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"ngày-2682024\"\u003eNgày 26/8/2024\u003c/h2\u003e\n\u003cp\u003eMột số trang blog và kênh Youtube về Hardware Hacking\u003c/p\u003e\n\u003ch3 id=\"ncc-grouphttpsresearchnccgroupcomcategoryhardware-embedded-systems\"\u003e\u003ca href=\"https://research.nccgroup.com/category/hardware-embedded-systems/\"\u003eNCC Group\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"matt-brown-iot-pentester--hardware-security-researcher\"\u003eMatt Brown: IoT Pentester \u0026amp; Hardware Security Researcher\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://brownfinesecurity.com/blog/\"\u003eBlog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eYoutube Channel: \u003ca href=\"https://www.youtube.com/@mattbrwn\"\u003eMatt Brown\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hextreeiohttpsapphextreeio-một-nền-tảng-học-tập-về-hacking\"\u003e\u003ca href=\"https://app.hextree.io/\"\u003ehextree.io\u003c/a\u003e: Một nền tảng học tập về hacking.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eYoutube Channel: \u003ca href=\"https://www.youtube.com/@LiveOverflow\"\u003eLiveOverflow\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"iot-pentesting-guidehttpswwwiotpentestingguidecom\"\u003e\u003ca href=\"https://www.iotpentestingguide.com/\"\u003eIoT Pentesting Guide\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"iotsecurity101httpsv33rugithubioiotsecurity101\"\u003e\u003ca href=\"https://v33ru.github.io/IoTSecurity101/\"\u003eIoTSecurity101\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"gamehackinggghttpsgamehackinggg\"\u003e\u003ca href=\"https://gamehacking.gg/\"\u003eGameHacking.GG\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrò chơi để luyện tập về \u003cstrong\u003ereverse\u003c/strong\u003e và hacking game.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jhllc/Unity-Game\"\u003eGithub Hướng dẫn\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"synacktivhttpswwwsynacktivcomenour-publications\"\u003e\u003ca href=\"https://www.synacktiv.com/en/our-publications\"\u003esynacktiv\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/publications\"\u003ePublications\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/advisories\"\u003eAdvisories\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/ressources\"\u003eResources\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/news/",
      "date_published": "26086-26-09T827:2626:00+07:00",
      "date_modified": "26086-26-09T827:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "261aa46d7ac1d848e6c22e49147fd08d6ad6071f",
      "title": "Protect_Camera",
      "summary": "",
      "content_text": "Lướt lát trên Internet, vô tình lụm được các bức ảnh (được cắt ra trên một seminar nào đó) nói về các cách bảo vệ Camera.\nSau khi đọc xong thì mình thấy các nội dung trong đây không chỉ dành riêng cho camera, mà có thể áp dụng tư duy và kỹ thuật này cả vào red-team và blue-team.\nKỹ thuật cho Red-Team Phishing Attacks Đây là kỹ thuật rất phổ biến và hay được dùng. Đính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web fake. Để rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này. Sử dụng phần mềm độc hại Hacker tạo ra các con malware, sau đó nhúng nó vào các file như file ảnh, pdf,\u0026hellip; Khi nạn nhân nhấp vào thì sẽ có các tiến trình chạy ẩn bên trong máy. Ví dụ như tạo ra backdoor kết nối về máy chủ C2 của hacker. Câu hỏi là làm sao dẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm Để làm được điều này thì một trong những kỹ thuật cần dùng là Phishing Attacks.\nKhai thác lỗ hổng phần mềm Phần mềm ở đây mang nghĩa cũng hơi rộng. Có thể là web, moblie hoặc một ứng dụng desktop. Chỉ cần phần mềm đó có lỗ hổng và mình khai thác (ví dụ như Reverse Shell hoặc RAT) được thì cũng làm được khá nhiều trò. Fake WIFI Cách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker. Hacker sẽ fake một free wifi, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet. Hoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,\u0026hellip; Tư duy Blue-Team Sử dụng Password mạnh mẽ Ít nhất 8 ký tự, có cả số lẫn chữ. Trong có phải bao gồm ít nhất phải có một ký tự đặc biệt, và một ký tự chữ in hoa. Sử dụng 2FA Xác thực OTP (One Time Password). Có thể dùng app GG Authen để xác thực 2 bước. Phân quyền Cận thận với những app cài đặt với quyền Admin. Phân quyền lại cho user, được phép và không được phép làm điều gì. Kiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng không thể leo thang đặc quyền được. Bảo vệ vật lý Hiểu nôm na là sử dụng công cụ vật lý để xác thực. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng. Ví dụ như sản phẩm FIDO2® Touch 1 của công ty VinCSS Công cụ khác Hãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng. Sử dụng Firewall (cả phần cứng và phần mềm) để bảo vệ hạ tầng và ứng dụng của bạn. Sử dụng VPN để bảo vệ thông tin của bạn. Sử dụng các công cụ diệt virus để bảo vệ máy tính của bạn. Và đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack (vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu). Human - Con người Dù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là con người Lỗ hổng này nằm trong tư duy, nhận thức về An toàn và Bảo mật thông tin. ",
      "content_html": "\u003cp\u003eLướt lát trên Internet, vô tình \u003cstrong\u003elụm\u003c/strong\u003e được các bức ảnh \u003cem\u003e(được cắt ra trên một seminar nào đó)\u003c/em\u003e nói về các cách bảo vệ Camera.\u003c/p\u003e\n\u003cp\u003eSau khi đọc xong thì mình thấy các nội dung trong đây \u003cstrong\u003ekhông chỉ dành riêng cho camera\u003c/strong\u003e, mà có thể áp dụng \u003cstrong\u003etư duy và kỹ thuật\u003c/strong\u003e này cả vào red-team và blue-team.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/1.jpg\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"kỹ-thuật-cho-red-team\"\u003eKỹ thuật cho Red-Team\u003c/h2\u003e\n\u003ch3 id=\"phishing-attacks\"\u003ePhishing Attacks\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/2.jpg\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là kỹ thuật rất phổ biến và hay được dùng.\u003c/li\u003e\n\u003cli\u003eĐính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web \u003cstrong\u003efake\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐể rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-phần-mềm-độc-hại\"\u003eSử dụng phần mềm độc hại\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/3.jpg\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHacker tạo ra các con \u003cstrong\u003emalware\u003c/strong\u003e, sau đó \u003cstrong\u003enhúng\u003c/strong\u003e nó vào các file như file ảnh, pdf,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eKhi nạn nhân nhấp vào thì sẽ có các \u003cstrong\u003etiến trình chạy ẩn\u003c/strong\u003e bên trong máy.\u003c/li\u003e\n\u003cli\u003eVí dụ như tạo ra \u003cstrong\u003ebackdoor\u003c/strong\u003e kết nối về \u003cstrong\u003emáy chủ C2\u003c/strong\u003e của hacker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/4.jpg\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCâu hỏi là làm sao \u003cstrong\u003edẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm\u003c/strong\u003e \u003cbr\u003e\nĐể làm được điều này thì một trong những kỹ thuật cần dùng là \u003cmark\u003ePhishing Attacks\u003c/mark\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"khai-thác-lỗ-hổng-phần-mềm\"\u003eKhai thác lỗ hổng phần mềm\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/5.jpg\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePhần mềm\u003c/strong\u003e ở đây mang nghĩa cũng hơi rộng. Có thể là \u003ccode\u003eweb\u003c/code\u003e, \u003ccode\u003emoblie\u003c/code\u003e hoặc một ứng dụng \u003ccode\u003edesktop\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eChỉ cần phần mềm đó có \u003cstrong\u003elỗ hổng\u003c/strong\u003e và mình khai thác (ví dụ như \u003cmark\u003eReverse Shell\u003c/mark\u003e hoặc \u003cstrong\u003eRAT\u003c/strong\u003e) được thì cũng làm được khá nhiều trò.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"fake-wifi\"\u003eFake WIFI\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/6.jpg\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker.\u003c/li\u003e\n\u003cli\u003eHacker sẽ fake một \u003cstrong\u003efree wifi\u003c/strong\u003e, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet.\u003c/li\u003e\n\u003cli\u003eHoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tư-duy-blue-team\"\u003eTư duy Blue-Team\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/7.jpg\"\n  alt=\"Hinh_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"sử-dụng-password-mạnh-mẽ\"\u003eSử dụng Password mạnh mẽ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eÍt nhất \u003cstrong\u003e8 ký tự\u003c/strong\u003e, có cả số lẫn chữ.\u003c/li\u003e\n\u003cli\u003eTrong có phải bao gồm ít nhất phải có một \u003cstrong\u003eký tự đặc biệt\u003c/strong\u003e, và một ký tự \u003cstrong\u003echữ in hoa\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-2fa\"\u003eSử dụng 2FA\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXác thực \u003cstrong\u003eOTP\u003c/strong\u003e (One Time Password).\u003c/li\u003e\n\u003cli\u003eCó thể dùng app \u003cstrong\u003eGG Authen\u003c/strong\u003e để xác thực 2 bước.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"phân-quyền\"\u003ePhân quyền\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCận thận với những app cài đặt với quyền Admin\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003ePhân quyền lại cho \u003cstrong\u003euser\u003c/strong\u003e, được phép và không được phép làm điều gì.\u003c/li\u003e\n\u003cli\u003eKiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng \u003cstrong\u003ekhông thể leo thang đặc quyền\u003c/strong\u003e được.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bảo-vệ-vật-lý\"\u003eBảo vệ vật lý\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiểu nôm na là sử dụng \u003cstrong\u003ecông cụ vật lý để xác thực\u003c/strong\u003e. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng.\u003c/li\u003e\n\u003cli\u003eVí dụ như sản phẩm \u003ca href=\"https://vincss.net/vi/product/khoa-xac-thuc-manh-vincss-fido2-touch-1-ket-noi-usb-type-a-ho-tro-xac-thuc-an-toan-khong-mat-khau-chuan-uaf-u2f-fido2-hang-chinh-hang/\"\u003eFIDO2® Touch 1\u003c/a\u003e của công ty \u003cstrong\u003eVinCSS\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-khác\"\u003eCông cụ khác\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/10.jpg\"\n  alt=\"Hinh_10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003cstrong\u003eFirewall\u003c/strong\u003e \u003cem\u003e(cả phần cứng và phần mềm)\u003c/em\u003e để bảo vệ hạ tầng và ứng dụng của bạn.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003cstrong\u003eVPN\u003c/strong\u003e để bảo vệ thông tin của bạn.\u003c/li\u003e\n\u003cli\u003eSử dụng các công cụ \u003cstrong\u003ediệt virus\u003c/strong\u003e để bảo vệ máy tính của bạn.\u003c/li\u003e\n\u003cli\u003eVà đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack \u003cem\u003e(vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"human---con-người\"\u003eHuman - Con người\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là \u003cstrong\u003econ người\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eLỗ hổng này nằm trong \u003cstrong\u003etư duy\u003c/strong\u003e, \u003cstrong\u003enhận thức\u003c/strong\u003e về An toàn và Bảo mật thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/8.jpg\"\n  alt=\"Hinh_8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/protect_camera/",
      "date_published": "18086-18-09T87:1818:00+07:00",
      "date_modified": "18086-18-09T87:1818:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "20ccc7228320b7e728440959d1e27bbe5951a067",
      "title": "RE_Tool_BinaryNinjaFree",
      "summary": "",
      "content_text": "Một bài viết về RE (Reverse Engineering)\nCông cụ IDA - The Interactive Disassembler Công cụ này có bản free và hỗ trợ cài đặt trên nhiều nền tảng. Mình tải và cài đặt bản free cho Windows. Tuy nhiên thì: Với bản free thì mình chỉ có thể dùng cho các file PE format. Là dạng các file .exe trên windows. Với bản free thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng. Công cụ Online - Decompiler Explorer Phần mềm Binary Ninja Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.\nVideo youtube tham khảo: How to Crack Software (Reverse Engineering) Learning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting An Intro to Binary Ninja (Free) for Malware Analysis Binary Ninja: 4.1 Feature Stream! Community provided Binary Ninja plugins: community-plugins Download Free Đây là một công cụ mạnh mẽ, nhưng được sử dụng free. Nếu so sánh thì phần mềm này ăn đứt IDA về tính năng của bản free: Supports x86, x86_64, and ARMv7 architectures. Hỗ trợ Disassemble (phân tích), Pseudo C (dịch ngược), HLIL. Mình đã tải và cài thử trên Windows, sau đó thử mở một file ELF (file code rust-tracking) Mình có thể dùng với Strings, Hex Editor,\u0026hellip; Công cụ quá mạnh mẽ. ",
      "content_html": "\u003cp\u003eMột bài viết về \u003ca href=\"https://whitehat.vn/threads/re1-gioi-thieu-ve-reverse-engineering.875/\"\u003eRE (Reverse Engineering)\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"công-cụ-ida---the-interactive-disassemblerhttpswhitehatvnthreadsre3-huong-dan-su-dung-ida913\"\u003e\u003ca href=\"https://whitehat.vn/threads/re3-huong-dan-su-dung-ida.913/\"\u003eCông cụ IDA - The Interactive Disassembler\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này có \u003ca href=\"https://hex-rays.com/ida-free/#download\"\u003ebản free\u003c/a\u003e và hỗ trợ cài đặt trên nhiều nền tảng.\u003c/li\u003e\n\u003cli\u003eMình tải và cài đặt bản free cho Windows. Tuy nhiên thì:\n\u003cul\u003e\n\u003cli\u003eVới bản free thì mình chỉ có thể dùng cho các file \u003cstrong\u003ePE format\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLà dạng các file \u003ccode\u003e.exe\u003c/code\u003e trên windows.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eVới bản \u003cem\u003efree\u003c/em\u003e thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-online---decompiler-explorerhttpsdogboltorg\"\u003eCông cụ Online - \u003ca href=\"https://dogbolt.org/\"\u003eDecompiler Explorer\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"phần-mềm-binary-ninjahttpsbinaryninja\"\u003ePhần mềm \u003ca href=\"https://binary.ninja/\"\u003eBinary Ninja\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eBinary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"video-youtube-tham-khảo\"\u003eVideo youtube tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=FBwRTWEzGN0\u0026amp;list=WL\u0026amp;index=11\"\u003eHow to Crack Software (Reverse Engineering)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=tCcLhsTdFEw\"\u003eLearning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=-RaOeooSmug\"\u003eAn Intro to Binary Ninja (Free) for Malware Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=IdNFMIQ9roQ\"\u003eBinary Ninja: 4.1 Feature Stream!\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"community-provided-binary-ninja-plugins-community-pluginshttpsgithubcomvector35community-plugins\"\u003eCommunity provided Binary Ninja plugins: \u003ca href=\"https://github.com/Vector35/community-plugins\"\u003ecommunity-plugins\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"download-freehttpsbinaryninjafree\"\u003e\u003ca href=\"https://binary.ninja/free/\"\u003eDownload Free\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ mạnh mẽ, nhưng được sử dụng \u003cstrong\u003efree\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNếu so sánh thì phần mềm này \u003cstrong\u003eăn đứt IDA\u003c/strong\u003e về tính năng của bản free:\n\u003cul\u003e\n\u003cli\u003eSupports x86, x86_64, and ARMv7 architectures.\u003c/li\u003e\n\u003cli\u003eHỗ trợ \u003cstrong\u003eDisassemble\u003c/strong\u003e (phân tích), \u003cstrong\u003ePseudo C\u003c/strong\u003e (dịch ngược), \u003cstrong\u003eHLIL\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMình đã tải và cài thử trên Windows, sau đó thử mở một \u003cstrong\u003efile ELF\u003c/strong\u003e (file code rust-tracking)\u003c/li\u003e\n\u003cli\u003eMình có thể dùng với \u003cstrong\u003eStrings\u003c/strong\u003e, \u003cstrong\u003eHex Editor\u003c/strong\u003e,\u0026hellip;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCông cụ quá mạnh mẽ\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Binary_Ninja_Free.png\"\n  alt=\"Binary_Ninja_Free\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/re_tool_binaryninjafree/",
      "date_published": "16086-16-09T87:1616:00+07:00",
      "date_modified": "16086-16-09T87:1616:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8858de0373b9ed077f6a2e9fc778bc7ae286a217",
      "title": "Read_Write_UART_STM32Fx",
      "summary": "",
      "content_text": "Code Test Read Write Data trên UART của chip STM32F103 #![no_std] #![no_main] #![feature(type_alias_impl_trait)] #![feature(alloc_error_handler)] //------------------------- Define Macro Alloc ------------------------------------ extern crate alloc; use alloc_cortex_m::CortexMHeap; // this is the allocator the application will use #[global_allocator] static ALLOCATOR: CortexMHeap = CortexMHeap::empty(); const HEAP_SIZE: usize = 1024; // in bytes //----------------------------------------------------------------------------------- use defmt::*; use defmt_rtt as _; use embassy_executor::Spawner; use embassy_stm32::usart::{Config, Uart}; use embassy_stm32::{bind_interrupts, peripherals, usart}; use embassy_time::{with_timeout, Duration}; use panic_halt as _; bind_interrupts!(struct Irqs { USART1 =\u0026gt; usart::InterruptHandler\u0026lt;peripherals::USART1\u0026gt;; }); #[embassy_executor::main] async fn main(_spawner: Spawner) { // Initialize the allocator BEFORE you use it unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) } info!(\u0026#34;Test UART\u0026#34;); let p = embassy_stm32::init(Default::default()); let mut uart = Uart::new( p.USART1, p.PA10, p.PA9, Irqs, p.DMA1_CH4, p.DMA1_CH5, Config::default(), ) .unwrap(); uart.write(b\u0026#34;Start Test UART\\r\\n\u0026#34;).await.unwrap(); let mut response_data = [0u8; 25]; // Buffer for one byte at a time. loop { match with_timeout(Duration::from_millis(100), uart.read_until_idle(\u0026amp;mut response_data)).await { Ok(_) =\u0026gt; { println!(\u0026#34;Data Test: {}\u0026#34;, response_data); if let Ok(message) = core::str::from_utf8(\u0026amp;response_data) { println!(\u0026#34;DATA OK: {}\u0026#34;, message); } // clean buffer response_data.fill(0); } Err(_e) =\u0026gt; { // debug!(\u0026#34;Read UART Error\u0026#34;); } } } } // define what happens in an Out Of Memory (OOM) condition #[alloc_error_handler] fn alloc_error(_layout: core::alloc::Layout) -\u0026gt; ! { loop {} } Note Đoạn code này dùng timeout với read_until_idle. Với read_until_idle là để tự detect các ký tự xuống dòng như \\r\\n. Kết quả test thành công: ",
      "content_html": "\u003ch2 id=\"code-test-read-write-data-trên-uart-của-chip-stm32f103\"\u003eCode Test Read Write Data trên UART của chip STM32F103\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#![no_std]\n#![no_main]\n#![feature(type_alias_impl_trait)]\n#![feature(alloc_error_handler)]\n//------------------------- Define Macro Alloc ------------------------------------\nextern crate alloc;\nuse alloc_cortex_m::CortexMHeap;\n\n// this is the allocator the application will use\n#[global_allocator]\nstatic ALLOCATOR: CortexMHeap = CortexMHeap::empty();\n\nconst HEAP_SIZE: usize = 1024; // in bytes\n\n//-----------------------------------------------------------------------------------\nuse defmt::*;\nuse defmt_rtt as _;\nuse embassy_executor::Spawner;\nuse embassy_stm32::usart::{Config, Uart};\nuse embassy_stm32::{bind_interrupts, peripherals, usart};\nuse embassy_time::{with_timeout, Duration};\nuse panic_halt as _;\n\nbind_interrupts!(struct Irqs {\n    USART1 =\u0026gt; usart::InterruptHandler\u0026lt;peripherals::USART1\u0026gt;;\n});\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    // Initialize the allocator BEFORE you use it\n    unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) }\n\n    info!(\u0026#34;Test UART\u0026#34;);\n    let p = embassy_stm32::init(Default::default());\n\n    let mut uart = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        Irqs,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        Config::default(),\n    )\n    .unwrap();\n\n    uart.write(b\u0026#34;Start Test UART\\r\\n\u0026#34;).await.unwrap();\n    let mut response_data = [0u8; 25]; // Buffer for one byte at a time.\n\n    loop {\n        match with_timeout(Duration::from_millis(100), uart.read_until_idle(\u0026amp;mut response_data)).await {\n            Ok(_) =\u0026gt; {\n                println!(\u0026#34;Data Test: {}\u0026#34;, response_data);\n\n                if let Ok(message) = core::str::from_utf8(\u0026amp;response_data) {\n                    println!(\u0026#34;DATA OK: {}\u0026#34;, message);\n                }\n\n                // clean buffer\n                response_data.fill(0);\n            }\n            Err(_e) =\u0026gt; {\n                // debug!(\u0026#34;Read UART Error\u0026#34;);\n            }\n        }\n    }\n}\n\n// define what happens in an Out Of Memory (OOM) condition\n#[alloc_error_handler]\nfn alloc_error(_layout: core::alloc::Layout) -\u0026gt; ! {\n    loop {}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐoạn code này dùng \u003ccode\u003etimeout\u003c/code\u003e với \u003ccode\u003eread_until_idle\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eVới \u003ccode\u003eread_until_idle\u003c/code\u003e là để tự detect các ký tự xuống dòng như \u003ccode\u003e\\r\\n\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eKết quả test thành công:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/UART_Read_Write_Result.png\"\n  alt=\"Read_Write\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/read_write_uart_stm32fx/",
      "date_published": "14086-14-09T817:1414:00+07:00",
      "date_modified": "14086-14-09T817:1414:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d646756b3915b7869f9ba136ff457d3e000f4774",
      "title": "Dump_Firmware_NOR_Flash",
      "summary": "",
      "content_text": "Đây là video Youtube nói về việc Dump Firmware thiết bị: Extracting Firmware from Embedded Devices (SPI NOR Flash) ⚡\nMột video hay, thú vị, giải thích và hướng dẫn cơ bản về Flash Memory\nLoại NOR Flash này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như tracking. Còn NAND Flash thì mình thấy trong các thiết bị như Camera hành trình. Loại eMMC Flash thì mình thấy trong máy tính nhúng (như Pi). NOR Flash Trong video thì hướng dẫn và giải thích cơ bản về NOR Flash, cũng như cách dump firmware từ nó. Loại flash này dùng giao thức SPI: Làm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC. Nếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự. Dump Firmware Trong video tác giả sử dụng phần cứng HydraBus Đây là một dự án mã nguồn mở về phần cứng (hardware open-source): hydrabus project. Tài liệu về Cách sử dụng Hydrabus: Getting Started with HydraBus Dựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware: flashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c \u0026#34;MX25L6406E/MX25L6408E Note Để hiểu rõ hơn thì cần xem lại video nhiều lần. Ngoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash hydra_spiflash_nor_dump Một số hình ảnh khác về cách dùng cũng như công cụ bổ trợ: ",
      "content_html": "\u003cp\u003eĐây là video Youtube nói về việc \u003cstrong\u003eDump Firmware\u003c/strong\u003e thiết bị: \u003ca href=\"https://www.youtube.com/watch?v=nruUuDalNR0\u0026amp;list=WL\u0026amp;index=7\"\u003eExtracting Firmware from Embedded Devices (SPI NOR Flash) ⚡\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMột video hay, thú vị, giải thích và hướng dẫn cơ bản về \u003cstrong\u003eFlash Memory\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLoại \u003cstrong\u003eNOR Flash\u003c/strong\u003e này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như \u003cstrong\u003etracking\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCòn \u003cstrong\u003eNAND Flash\u003c/strong\u003e thì mình thấy trong các thiết bị như \u003cstrong\u003eCamera hành trình\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLoại \u003cstrong\u003eeMMC Flash\u003c/strong\u003e thì mình thấy trong \u003cstrong\u003emáy tính nhúng\u003c/strong\u003e (như Pi).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nor-flash\"\u003eNOR Flash\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video thì hướng dẫn và giải thích cơ bản về \u003cstrong\u003eNOR Flash\u003c/strong\u003e, cũng như cách \u003cstrong\u003edump firmware\u003c/strong\u003e từ nó.\u003c/li\u003e\n\u003cli\u003eLoại flash này dùng giao thức \u003cstrong\u003eSPI\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_3.png\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLàm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC.\u003c/li\u003e\n\u003cli\u003eNếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_4.png\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"dump-firmware\"\u003eDump Firmware\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video tác giả sử dụng phần cứng \u003ca href=\"https://hydrabus.com/hydrabus-1-0-specifications/?v=e14da64a5617\"\u003eHydraBus\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/HydraFW_Default_PinAssignment.jpg\"\n  alt=\"HydraBus\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là \u003cstrong\u003emột dự án mã nguồn mở về phần cứng\u003c/strong\u003e (hardware open-source): \u003ca href=\"https://github.com/hydrabus/hydrabus\"\u003ehydrabus project\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eTài liệu về Cách sử dụng Hydrabus: \u003ca href=\"https://github.com/hydrabus/hydrafw/wiki/Getting-Started-with-HydraBus\"\u003eGetting Started with HydraBus\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eflashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c \u0026#34;MX25L6406E/MX25L6408E\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"note\"\u003eNote\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐể hiểu rõ hơn thì cần xem lại video nhiều lần.\u003c/li\u003e\n\u003cli\u003eNgoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash \u003ca href=\"https://github.com/hydrabus/hydrafw/tree/master/contrib/hydra_spiflash_nor_dump\"\u003e\u003ccode\u003ehydra_spiflash_nor_dump\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-số-hình-ảnh-khác-về-cách-dùng-cũng-như-công-cụ-bổ-trợ\"\u003eMột số hình ảnh khác về cách dùng cũng như công cụ bổ trợ:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_5.png\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_6.png\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_7.png\"\n  alt=\"Hinh_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_8.png\"\n  alt=\"Hinh_8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/dump_firmware_nor_flash/",
      "date_published": "12086-12-09T844:1212:00+07:00",
      "date_modified": "12086-12-09T844:1212:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e9b5355ef4d97f5d9b1f18a012a87fb12e896428",
      "title": "Shared_Access_Embassy",
      "summary": "",
      "content_text": "Như bài viết về Lifetime_Embassy mình bị vướng chỗ ownership UART.\nSau khi thăm hỏi ChatGPT và đọc lại các tài liệu cũng như xem sample code thì biết rằng: Rust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời \u0026ndash;\u0026gt; Gây lỗi cho chương trình.\nĐể giải quyết vấn đề này thì cần share quyền truy cập (Managing Shared Access).\nCách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột quyền sở hữu (ownership) hoặc mượn (borrow)\nVà để làm được điều này mình sẽ cần dùng đến Mutex, RefCell hoặc Arc. Arc\u0026lt;Mutex\u0026lt;Uart\u0026gt;\u0026gt; Tham khảo sample code về việc sử dụng Arc. Link\nvấn đề tiếp theo Xui một cái nữa là Arc không được khuyến nghị sử dụng trong embedded. và trong các example code có trong framwork embassy, mình cũng không thấy ví dụ nào về dùng Arc. Tiếp tục hỏi chatGPT về cách Shared Access trong framwork embassy, cuối cùng cũng đã có kết quả. Code sample Đây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được. Đoạn code này dùng: Mutex, NoopRawMutex và RefCell. use embassy_executor::Spawner; use embassy_stm32::usart::Uart; use embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1}; use embassy_stm32::gpio::{Output, Level, Speed}; use embassy_time::{Timer, Duration}; use embassy_sync::blocking_mutex::raw::NoopRawMutex; use embassy_sync::mutex::Mutex; use core::cell::RefCell; use core::future::Future; use core::sync::atomic::{AtomicBool, Ordering}; #[embassy_executor::task] pub async fn test_command( uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, message: \u0026amp;\u0026#39;static str, ) { let mut count = 0; loop { count += 1; { let uart = uart.lock().await; let mut uart = uart.borrow_mut(); uart.write(message.as_bytes()).await.unwrap(); uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap(); } if count == 10 { break; } Timer::after(Duration::from_millis(1000)).await; } } #[embassy_executor::task] pub async fn main_task_rfid( rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, mut power_pin_cr95hf: Output\u0026lt;\u0026#39;static, PA1\u0026gt;, ) { dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await; } async fn dbg_print( uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, message: \u0026amp;str, ) { let uart = uart.lock().await; let mut uart = uart.borrow_mut(); uart.write(message.as_bytes()).await.unwrap(); uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap(); } #[embassy_executor::main] async fn main(spawner: Spawner) { let p = embassy_stm32::Peripherals::take().unwrap(); let usart_rfid = Uart::new( p.USART2, p.PA3, p.PA2, IrqsUART2, p.DMA1_CH7, p.DMA1_CH6, config_rfid, ) .unwrap(); let usart_debug = Uart::new( p.USART1, p.PA10, p.PA9, IrqsUART1, p.DMA1_CH4, p.DMA1_CH5, config_debug, ) .unwrap(); // Convert usart_rfid and usart_debug to \u0026#39;static lifetimes let usart_rfid_static = Box::leak(Box::new(usart_rfid)); let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug)))); // Create the ctr_rfid object let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low); let ctr_rfid_static = Box::leak(Box::new(ctr_rfid)); // Async task for test command spawner .spawn(test_command(usart_debug_static, \u0026#34;Test\u0026#34;)) .unwrap(); // Async task for RFID spawner .spawn(main_task_rfid( usart_rfid_static, usart_debug_static, ctr_rfid_static, )) .unwrap(); } Đã khắc phục và chạy code được thành công. ",
      "content_html": "\u003cp\u003eNhư bài viết về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/lifetime_embassy/\"\u003eLifetime_Embassy\u003c/a\u003e mình bị vướng chỗ ownership UART.\u003c/p\u003e\n\u003cp\u003eSau khi thăm hỏi \u003cstrong\u003eChatGPT\u003c/strong\u003e và đọc lại các tài liệu cũng như xem sample code thì biết rằng:\n\u003cstrong\u003eRust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời \u0026ndash;\u0026gt; Gây lỗi cho chương trình\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐể giải quyết vấn đề này thì cần share quyền truy cập (\u003cstrong\u003eManaging Shared Access\u003c/strong\u003e).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột \u003cstrong\u003equyền sở hữu\u003c/strong\u003e (\u003cem\u003eownership\u003c/em\u003e) hoặc \u003cstrong\u003emượn\u003c/strong\u003e (\u003cem\u003eborrow\u003c/em\u003e)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eVà để làm được điều này mình sẽ cần dùng đến \u003cstrong\u003eMutex\u003c/strong\u003e, \u003cstrong\u003eRefCell\u003c/strong\u003e hoặc \u003cstrong\u003eArc\u003c/strong\u003e. \u003ccode\u003eArc\u0026lt;Mutex\u0026lt;Uart\u0026gt;\u0026gt;\u003c/code\u003e\nTham khảo sample code về việc sử dụng Arc. \u003ca href=\"https://rust-classes.com/chapter_6_3\"\u003eLink\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"vấn-đề-tiếp-theo\"\u003evấn đề tiếp theo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXui một cái nữa là \u003cstrong\u003eArc\u003c/strong\u003e không được khuyến nghị sử dụng trong \u003cstrong\u003eembedded\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003evà trong các example code có trong \u003cstrong\u003eframwork embassy\u003c/strong\u003e, mình cũng không thấy ví dụ nào về dùng \u003cstrong\u003eArc\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTiếp tục hỏi chatGPT về cách \u003cstrong\u003eShared Access trong framwork embassy\u003c/strong\u003e, cuối cùng cũng đã có kết quả.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"code-sample\"\u003eCode sample\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được.\u003c/li\u003e\n\u003cli\u003eĐoạn code này dùng: \u003cstrong\u003eMutex\u003c/strong\u003e, \u003cstrong\u003eNoopRawMutex\u003c/strong\u003e và \u003cstrong\u003eRefCell\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse embassy_executor::Spawner;\nuse embassy_stm32::usart::Uart;\nuse embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1};\nuse embassy_stm32::gpio::{Output, Level, Speed};\nuse embassy_time::{Timer, Duration};\nuse embassy_sync::blocking_mutex::raw::NoopRawMutex;\nuse embassy_sync::mutex::Mutex;\nuse core::cell::RefCell;\nuse core::future::Future;\nuse core::sync::atomic::{AtomicBool, Ordering};\n\n#[embassy_executor::task]\npub async fn test_command(\n    uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    message: \u0026amp;\u0026#39;static str,\n) {\n    let mut count = 0;\n    loop {\n        count += 1;\n\n        {\n            let uart = uart.lock().await;\n            let mut uart = uart.borrow_mut();\n            uart.write(message.as_bytes()).await.unwrap();\n            uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap();\n        }\n\n        if count == 10 {\n            break;\n        }\n\n        Timer::after(Duration::from_millis(1000)).await;\n    }\n}\n\n#[embassy_executor::task]\npub async fn main_task_rfid(\n    rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    mut power_pin_cr95hf: Output\u0026lt;\u0026#39;static, PA1\u0026gt;,\n) {\n    dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await;\n}\n\nasync fn dbg_print(\n    uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    message: \u0026amp;str,\n) {\n    let uart = uart.lock().await;\n    let mut uart = uart.borrow_mut();\n    uart.write(message.as_bytes()).await.unwrap();\n    uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap();\n}\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let p = embassy_stm32::Peripherals::take().unwrap();\n\n    let usart_rfid = Uart::new(\n        p.USART2,\n        p.PA3,\n        p.PA2,\n        IrqsUART2,\n        p.DMA1_CH7,\n        p.DMA1_CH6,\n        config_rfid,\n    )\n    .unwrap();\n\n    let usart_debug = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        IrqsUART1,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        config_debug,\n    )\n    .unwrap();\n\n    // Convert usart_rfid and usart_debug to \u0026#39;static lifetimes\n    let usart_rfid_static = Box::leak(Box::new(usart_rfid));\n    let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug))));\n\n\n    // Create the ctr_rfid object\n    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);\n    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));\n\n    // Async task for test command\n    spawner\n        .spawn(test_command(usart_debug_static, \u0026#34;Test\u0026#34;))\n        .unwrap();\n\n    // Async task for RFID\n    spawner\n        .spawn(main_task_rfid(\n            usart_rfid_static,\n            usart_debug_static,\n            ctr_rfid_static,\n        ))\n        .unwrap();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"đã-khắc-phục-và-chạy-code-được-thành-công\"\u003e\u003cstrong\u003eĐã khắc phục và chạy code được thành công\u003c/strong\u003e.\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Result_Shared_Access_UART.png\"\n  alt=\"Result_Shared_Access_UART\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/shared_access_embassy/",
      "date_published": "10086-10-09T818:1010:00+07:00",
      "date_modified": "10086-10-09T818:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a16b4dd5414090a88aec578f8ac2b21db34beb7",
      "title": "Lifetime_Embassy",
      "summary": "",
      "content_text": "Trong quá trình code Rust cho RFID, khi sử dụng đến phần UART và dùng đến #[embassy_executor::task] thì bị báo lỗi về Lifetime\nLỗi lifetime về uart. Hiều nôm na thì rust đang báo là thời gian sống (thời gian tồn tại, hay vòng đời) của UART quá ngắn để thực hiện các tiến trình trong task.\nXem thêm video Rust Lifetimes Finally Explained!\nĐể khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: 'static, 'a, 'b,\u0026hellip;\nVà để khắc phục triệt để mình phải sử dụng thêm Box\nGiới thiệu sơ về Box All values in Rust are stack allocated by default. Values can be boxed (allocated on the heap) by creating a Box. A box is a smart pointer to a heap allocated value of type T. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.\nĐể chuyển giá trị của Box thành một con trỏ với lifetime là 'static. Mình sẽ dùng đến cấu trúc Box::leak.\nCode mô tả: #[embassy_executor::task] pub async fn main_task_rfid( rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, power_pin_cr95hf: \u0026amp;\u0026#39;static mut Output\u0026lt;\u0026#39;_, PA1\u0026gt;, ) { // Use debug_uart here dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await; } #[embassy_executor::main] async fn main(spawner: Spawner) { let p = embassy_stm32::Peripherals::take().unwrap(); let mut usart_debug = Uart::new( p.USART1, p.PA10, p.PA9, IrqsUART1, p.DMA1_CH4, p.DMA1_CH5, config_debug, ).unwrap(); dbg_print(\u0026amp;mut usart_debug, \u0026#34;RFID CR95\u0026#34;).await; //------------------ RFID Task --------------------- let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low); // Convert references to \u0026#39;static by leaking the values let usart_rfid_static = Box::leak(Box::new(usart_rfid)); let usart_debug_static = Box::leak(Box::new(usart_debug)); let ctr_rfid_static = Box::leak(Box::new(ctr_rfid)); // Async task RFID spawner .spawn(task_rfid::main_task_rfid( usart_rfid_static, usart_debug_static, ctr_rfid_static, )) .unwrap(); Khi đã sử dụng usart_debug cho Box::leak (và được dùng cho task RFID) thì mình không còn dùng được usart_debug sau nữa.\nVì lúc này bị dính đến ownership.\n",
      "content_html": "\u003cp\u003eTrong quá trình code Rust cho RFID, khi sử dụng đến phần \u003cstrong\u003eUART\u003c/strong\u003e và dùng đến \u003ccode\u003e#[embassy_executor::task]\u003c/code\u003e thì bị báo lỗi về \u003cstrong\u003eLifetime\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLỗi lifetime về uart. Hiều nôm na thì rust đang báo là \u003cstrong\u003ethời gian sống\u003c/strong\u003e (thời gian tồn tại, hay \u003cstrong\u003evòng đời\u003c/strong\u003e) của \u003cstrong\u003eUART\u003c/strong\u003e quá ngắn để thực hiện các tiến trình trong task.\u003c/p\u003e\n\u003cp\u003eXem thêm video \u003ca href=\"https://www.youtube.com/watch?v=juIINGuZyBc\"\u003eRust Lifetimes Finally Explained!\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eĐể khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: \u003ccode\u003e'static\u003c/code\u003e, \u003ccode\u003e'a\u003c/code\u003e, \u003ccode\u003e'b\u003c/code\u003e,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eVà để khắc phục triệt để mình phải sử dụng thêm \u003ca href=\"https://doc.rust-lang.org/rust-by-example/std/box.html\"\u003eBox\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"giới-thiệu-sơ-về-box\"\u003eGiới thiệu sơ về Box\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAll values in Rust are stack allocated by default. Values can be \u003cem\u003eboxed\u003c/em\u003e (allocated on the heap) by creating a Box\u003cT\u003e.\nA \u003cstrong\u003ebox is a smart pointer\u003c/strong\u003e to a \u003cstrong\u003eheap allocated value of type T\u003c/strong\u003e.\nWhen a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Box_Rust.png\"\n  alt=\"Box\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐể chuyển giá trị của Box thành một con trỏ với lifetime là \u003ccode\u003e'static\u003c/code\u003e. Mình sẽ dùng đến cấu trúc \u003ccode\u003eBox::leak\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"code-mô-tả\"\u003eCode mô tả:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#[embassy_executor::task]\npub async fn main_task_rfid(\n    rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n    power_pin_cr95hf: \u0026amp;\u0026#39;static mut Output\u0026lt;\u0026#39;_, PA1\u0026gt;,\n) {\n    // Use debug_uart here\n    dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await;\n}\n\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let p = embassy_stm32::Peripherals::take().unwrap();\n\n    let mut usart_debug = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        IrqsUART1,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        config_debug,\n    ).unwrap();\n\n    dbg_print(\u0026amp;mut usart_debug, \u0026#34;RFID CR95\u0026#34;).await;\n\n    //------------------ RFID Task ---------------------\n    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);\n\n    // Convert references to \u0026#39;static by leaking the values\n    let usart_rfid_static = Box::leak(Box::new(usart_rfid));\n    let usart_debug_static = Box::leak(Box::new(usart_debug));\n    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));\n\n    // Async task RFID\n    spawner\n        .spawn(task_rfid::main_task_rfid(\n            usart_rfid_static,\n            usart_debug_static,\n            ctr_rfid_static,\n        ))\n        .unwrap();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eKhi đã sử dụng \u003ccode\u003eusart_debug\u003c/code\u003e cho \u003cstrong\u003eBox::leak\u003c/strong\u003e (và được dùng cho \u003cstrong\u003etask RFID\u003c/strong\u003e) thì mình không còn dùng được \u003ccode\u003eusart_debug\u003c/code\u003e sau nữa.\u003c/p\u003e\n\u003cp\u003eVì lúc này bị dính đến \u003cstrong\u003eownership\u003c/strong\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/lifetime_embassy/",
      "date_published": "9086-09-09T88:99:00+07:00",
      "date_modified": "9086-09-09T88:99:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7345b57aedfb01ea55a4c03e7a63fddfa26356b3",
      "title": "Results_Rust",
      "summary": "",
      "content_text": "Một trong các ưu điểm của ngôn ngữ bậc cao là việc Handle Error.\nVà trong Rust thì chính là cách sử dụng Result.\nMình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.\nVideo Youtube: A Simpler Way to See Results Result vs Option Nói cách dễ hiểu thì:\nOption dùng khi mình chỉ muốn biểu đạt có giá trị hoặc không có giá trị. Result dùng khi mình muốn biểu đạt là có giá trị đúng và biết được thông tin lỗi. Ví dụ về việc trả về một giá trị và handle-error Ví dụ về việc trả về hai giá trị và handle-error Nếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code. Tuy nhiên nếu dùng thêm operator thì cách biểu đạt sẽ đơn giản hơn. ",
      "content_html": "\u003cp\u003eMột trong các ưu điểm của ngôn ngữ bậc cao là việc \u003cstrong\u003eHandle Error\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eVà trong Rust thì chính là cách sử dụng \u003cstrong\u003eResult\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.\u003c/p\u003e\n\u003ch3 id=\"video-youtube-a-simpler-way-to-see-resultshttpswwwyoutubecomwatchvs5s2ed5t-dc\"\u003eVideo Youtube: \u003ca href=\"https://www.youtube.com/watch?v=s5S2Ed5T-dc\"\u003eA Simpler Way to See Results\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"result-vs-optionhttpsdhghomongithubioeasy_rustchapter_31html\"\u003e\u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_31.html\"\u003eResult vs Option\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eNói cách dễ hiểu thì:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOption\u003c/strong\u003e dùng khi mình chỉ muốn biểu đạt \u003cstrong\u003ecó giá trị\u003c/strong\u003e hoặc \u003cstrong\u003ekhông có giá trị\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eResult\u003c/strong\u003e dùng khi mình muốn biểu đạt là có \u003cstrong\u003egiá trị đúng\u003c/strong\u003e và biết được \u003cstrong\u003ethông tin lỗi\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_3.png\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ví-dụ-về-việc-trả-về-một-giá-trị-và-handle-error\"\u003eVí dụ về việc trả về \u003cstrong\u003emột giá trị\u003c/strong\u003e và handle-error\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_4.png\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ví-dụ-về-việc-trả-về-hai-giá-trị-và-handle-error\"\u003eVí dụ về việc trả về \u003cstrong\u003ehai giá trị\u003c/strong\u003e và handle-error\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code.\u003c/li\u003e\n\u003cli\u003eTuy nhiên nếu dùng thêm \u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_33.html\"\u003eoperator\u003c/a\u003e thì cách biểu đạt sẽ đơn giản hơn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_5.png\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_6.png\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust-lang/results_rust/",
      "date_published": "8086-08-09T87:88:00+07:00",
      "date_modified": "8086-08-09T87:88:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "372a4f104501fddb17ccf0cebf9ae4ae0fb586fa",
      "title": "UART_Embassy",
      "summary": "",
      "content_text": "Giới thiệu về Embassy Trong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này. Embassy một framework lập trình theo kiểu bất đồng bộ (async), dễ tiếp cận hơn việc setup một RTOS cho MCU. Async Embassy Dựa trên một file tài liệu mà mình tình cờ có được async-embedded thì Async là một cách tiếp cận về việc Xử lý đồng thời (Concurrency). Hơn nữa dựa trên Github Embassy thì framework này hỗ trợ kha khá dòng chip: Dòng nRF: embassy_nrf Dòng STM32: embassy-stm32 Dòng RP2040: embassy_rp Dòng ESP32: esp-rs Nhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust. UART Trong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.\nRead Trong STM32 phần Read UART có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng. blocking_read read read_until_idle Func blocking_read Function này sẽ mình đọc đầy đủ dữ liệu. Ban đầu mình có test thử giữa blocking_read với read, thì mình đọc được dữ liệu với blocking_read, còn với read thì không. Func read Mình sẽ thường dùng function read này kết hợp với timeout. Tức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra. Nhờ cách này mà mình tránh được việc bị treo chương trình. Đây là một đoạn code mẫu: // health_check_cr95hf // True: CR95HF OK // Flase: CR95HF not reponse -\u0026gt; Maybe lost connect with CR95HF async fn health_check_cr95hf( rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, ) -\u0026gt; bool { let echo_command_code: \u0026amp;[u8]; echo_command_code = cr95hf::cr95hf_echo_command(); dbg_print(debug_uart, \u0026#34;Health Check CR95HF\u0026#34;).await; // Buffer data reponse from CR95HF let mut response_code = [0u8; 1]; let _size_data: usize = 1; for _i in 1..3 { // Send command rfid_uart.blocking_write(\u0026amp;echo_command_code).unwrap(); // Read reponse from CR95HF match with_timeout( Duration::from_millis(30), rfid_uart.read(\u0026amp;mut response_code), ) .await { // match rfid_uart.blocking_read(\u0026amp;mut response_code) { Ok(_size_data) =\u0026gt; { // let _ = debug_uart.blocking_write(\u0026amp;response_code); // Data reponse from CR95 OK if response_code == echo_command_code { return true; } else { return false; } } Err(_e) =\u0026gt; { dbg_print(debug_uart, \u0026#34;Read UART Error - Func health_check_cr95hf\u0026#34;).await; // delay 10ms Timer::after(Duration::from_millis(10)).await; continue; } } } return false; } Func read_until_idle Để hiểu hơn về IDLE UART, mình đã tham khảo tài liệu: https://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette https://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/ Tức là với func này, nó sẽ chia ra thành từng block để đọc dữ liệu. Dưới đây là đoạn code với chức năng là: gửi command sau đó đọc 4 bytes dữ liệu, tuy nhiên chỉ lấy 2 bytes đầu để xử lý dữ liệu // no_tag_cr95hf: Check no_tag // Return true: if not detectd tag card async fn no_tag_cr95hf( rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, ) -\u0026gt; bool { // First: Setup Protocol ISO15693 setup_protocol_iso15693(rfid_uart).await; // Second: Read data and check errors code // Define the initial byte array let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00]; for _i in 1..3 { // Send command rfid_uart.blocking_write(\u0026amp;sendrecv_command).unwrap(); // Buffer data reponse from CR95HF let mut response_data = [0u8; 4]; let _size_data: usize = 2; // Read reponse from CR95HF match rfid_uart.read_until_idle(\u0026amp;mut response_data).await { Ok(_size_data) =\u0026gt; { // let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data.clone()); let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data); // let _ = debug_uart.blocking_write(\u0026amp;response_data); // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes()); if is_no_tag == true { dbg_print(debug_uart, \u0026#34;NO TAG CARD\u0026#34;).await; return true; } else { return false; } } Err(_e) =\u0026gt; { // delay 10ms Timer::after(Duration::from_millis(10)).await; } } } return false; } ",
      "content_html": "\u003ch2 id=\"giới-thiệu-về-embassyhttpsembassydev\"\u003eGiới thiệu về \u003ca href=\"https://embassy.dev/\"\u003eEmbassy\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEmbassy\u003c/strong\u003e một framework lập trình theo kiểu \u003cstrong\u003ebất đồng bộ (async)\u003c/strong\u003e, dễ tiếp cận hơn việc setup một \u003cstrong\u003eRTOS\u003c/strong\u003e cho MCU.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Concurrency_Parallelism.jpg\"\n  alt=\"Concurrency_Parallelism\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"async-embassy\"\u003eAsync Embassy\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa trên một file tài liệu mà mình tình cờ có được \u003ca href=\"/docs/embassy/B4-async-embedded.pdf\"\u003easync-embedded\u003c/a\u003e thì \u003cstrong\u003eAsync\u003c/strong\u003e là một cách tiếp cận về việc \u003cstrong\u003eXử lý đồng thời (Concurrency)\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHơn nữa dựa trên \u003ca href=\"https://github.com/embassy-rs/embassy\"\u003eGithub Embassy\u003c/a\u003e thì framework này hỗ trợ kha khá dòng chip:\n\u003cul\u003e\n\u003cli\u003eDòng nRF: \u003ca href=\"https://docs.embassy.dev/embassy-nrf/git/nrf51/index.html\"\u003eembassy_nrf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng STM32: \u003ca href=\"https://docs.embassy.dev/embassy-stm32/git/stm32f730i8/index.html\"\u003eembassy-stm32\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng RP2040: \u003ca href=\"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html\"\u003eembassy_rp\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng ESP32: \u003ca href=\"https://github.com/esp-rs\"\u003eesp-rs\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eNhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"uart\"\u003eUART\u003c/h1\u003e\n\u003cp\u003eTrong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.\u003c/p\u003e\n\u003ch2 id=\"read\"\u003eRead\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong STM32 phần \u003cstrong\u003eRead UART\u003c/strong\u003e có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng.\n\u003cul\u003e\n\u003cli\u003eblocking_read\u003c/li\u003e\n\u003cli\u003eread\u003c/li\u003e\n\u003cli\u003eread_until_idle\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"func-blocking_read\"\u003eFunc \u003ccode\u003eblocking_read\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFunction này sẽ mình đọc đầy đủ dữ liệu.\u003c/li\u003e\n\u003cli\u003eBan đầu mình có test thử giữa \u003ccode\u003eblocking_read\u003c/code\u003e với \u003ccode\u003eread\u003c/code\u003e, thì mình \u003cstrong\u003eđọc\u003c/strong\u003e được dữ liệu với \u003ccode\u003eblocking_read\u003c/code\u003e, còn với \u003ccode\u003eread\u003c/code\u003e thì không.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"func-read\"\u003eFunc \u003ccode\u003eread\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình sẽ thường dùng function \u003cstrong\u003eread\u003c/strong\u003e này kết hợp với \u003cstrong\u003etimeout\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra.\u003c/li\u003e\n\u003cli\u003eNhờ cách này mà mình tránh được việc bị \u003cstrong\u003etreo\u003c/strong\u003e chương trình.\u003c/li\u003e\n\u003cli\u003eĐây là một đoạn code mẫu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// health_check_cr95hf\n// True: CR95HF OK\n// Flase: CR95HF not reponse -\u0026gt; Maybe lost connect with CR95HF\nasync fn health_check_cr95hf(\n    rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n) -\u0026gt; bool {\n    let echo_command_code: \u0026amp;[u8];\n    echo_command_code = cr95hf::cr95hf_echo_command();\n    dbg_print(debug_uart, \u0026#34;Health Check CR95HF\u0026#34;).await;\n\n    // Buffer data reponse from CR95HF\n    let mut response_code = [0u8; 1];\n    let _size_data: usize = 1;\n\n    for _i in 1..3 {\n        // Send command\n        rfid_uart.blocking_write(\u0026amp;echo_command_code).unwrap();\n\n        // Read reponse from CR95HF\n        match with_timeout(\n            Duration::from_millis(30),\n            rfid_uart.read(\u0026amp;mut response_code),\n        )\n        .await\n        {\n            // match rfid_uart.blocking_read(\u0026amp;mut response_code) {\n            Ok(_size_data) =\u0026gt; {\n                // let _ = debug_uart.blocking_write(\u0026amp;response_code);\n                // Data reponse from CR95 OK\n                if response_code == echo_command_code {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Err(_e) =\u0026gt; {\n                dbg_print(debug_uart, \u0026#34;Read UART Error - Func health_check_cr95hf\u0026#34;).await;\n                // delay 10ms\n                Timer::after(Duration::from_millis(10)).await;\n                continue;\n            }\n        }\n    }\n\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"func-read_until_idle\"\u003eFunc \u003ccode\u003eread_until_idle\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐể hiểu hơn về \u003cstrong\u003eIDLE UART\u003c/strong\u003e, mình đã tham khảo tài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette\nhttps://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTức là với func này, nó sẽ chia ra thành từng \u003cstrong\u003eblock\u003c/strong\u003e để đọc dữ liệu.\u003c/li\u003e\n\u003cli\u003eDưới đây là đoạn code với chức năng là: gửi command sau đó đọc \u003cstrong\u003e4 bytes\u003c/strong\u003e dữ liệu, tuy nhiên chỉ lấy \u003cstrong\u003e2 bytes\u003c/strong\u003e đầu để xử lý dữ liệu\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// no_tag_cr95hf: Check no_tag\n// Return true: if not detectd tag card\nasync fn no_tag_cr95hf(\n    rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n) -\u0026gt; bool {\n    // First: Setup Protocol ISO15693\n    setup_protocol_iso15693(rfid_uart).await;\n\n    // Second: Read data and check errors code\n    // Define the initial byte array\n    let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00];\n\n    for _i in 1..3 {\n        // Send command\n        rfid_uart.blocking_write(\u0026amp;sendrecv_command).unwrap();\n\n        // Buffer data reponse from CR95HF\n        let mut response_data = [0u8; 4];\n        let _size_data: usize = 2;\n\n        // Read reponse from CR95HF\n        match rfid_uart.read_until_idle(\u0026amp;mut response_data).await {\n            Ok(_size_data) =\u0026gt; {\n                // let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data.clone());\n                let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data);\n                // let _ = debug_uart.blocking_write(\u0026amp;response_data);\n                // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes());\n                if is_no_tag == true {\n                    dbg_print(debug_uart, \u0026#34;NO TAG CARD\u0026#34;).await;\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Err(_e) =\u0026gt; {\n                // delay 10ms\n                Timer::after(Duration::from_millis(10)).await;\n            }\n        }\n    }\n\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/software/uart_embassy/",
      "date_published": "7086-07-09T823:77:00+07:00",
      "date_modified": "7086-07-09T823:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "85f09ce2f3cf711d085e9963d1cd2f835cfcf5d6",
      "title": "IoT_Security_JD",
      "summary": "",
      "content_text": " Bữa lang thang trên diễn đàn CISSP trên facebook, mình thấy một JD về Security cho IoT. Mình thấy JD này đầy đủ và cụ thể:\nVNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị UAV, drone, IoT, satellite,\u0026hellip; Nếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn: Có kỹ năng dịch ngược phần mềm (Reverse Engineering) và tìm kiếm lỗ hổng từ file thực thi đó. Thông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware. Thông thạo kỹ năng khai thác lỗ hổng phần mềm, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v\u0026hellip;. Có kỹ năng Source code review + Pentest blackbox các các thiết bị IoT Đam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới Bạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm: Kiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v\u0026hellip; trước khi hòa mạng vào hệ thống mạng băng rộng VNPT Nghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …) Nghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, … Nghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile VCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT: Gia nhập VCI, bạn sẽ đóng vai chính cho các dự án Làm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh Chế độ đãi ngộ hấp dẫn và review lương theo năng lực Chúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân Nếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé! Hồ sơ ứng viên xin gửi về địa chỉ email: security@vnpt.vn Reverse Đây là kỹ năng mà mình cần rèn luyện và trau dồi.\nDịch ngược Phần cứng Việc bóc tách chip nhớ thì sẽ có 2 mục tiêu chính: Thứ 1: Đọc các dữ liệu được lưu trữ không Flash Thứ 2: Dump Firmware Mình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại. Việc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị. Khai thác lỗ hổng Khi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn. Trong JD có các thuật ngữ mà mình không hiểu, ngoại trừ command injection. Cái này phức tạp vãi chưởng luôn. Pentest blackbox Các thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là Pentest Web. Hoặc có thể là lấy thông tin từ Debug UART, tìm kiếm IP Gateway Server, FTP Server,\u0026hellip; =\u0026gt; Pentest Web. Kiểm định, đánh giá an toàn bảo mật Các giao thức truyền thông IoT thì mình biết, nhưng mà để đánh giá ATTT thì mình chưa rõ. Không lẻ lấy theo tiêu chuẩn NIS2 Nhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.\nBiết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là điều kiện thực hành.\nMình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.\nVì trong IoT còn có những mảng nhỏ khác như:\nDesign (vẽ Schematic, PCB) Code nhúng Firmware cho MCU Code nhúng cho Linux Cũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]\n",
      "content_html": "\u003cp\u003e\u003cimg\n  src=\"/image/IoT/IoT_Security.jpg\"\n  alt=\"IoT_Security\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eBữa lang thang trên diễn đàn \u003cstrong\u003eCISSP trên facebook\u003c/strong\u003e, mình thấy một \u003cstrong\u003eJD về Security cho IoT\u003c/strong\u003e. Mình thấy JD này đầy đủ và cụ thể:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eVNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị \u003cstrong\u003eUAV, drone, IoT, satellite,\u0026hellip;\u003c/strong\u003e \u003c/br\u003e\nNếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn: \u003c/br\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCó kỹ năng \u003cstrong\u003edịch ngược phần mềm (Reverse Engineering)\u003c/strong\u003e và tìm kiếm lỗ hổng từ file thực thi đó. \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eThông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware. \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eThông thạo kỹ năng \u003cstrong\u003ekhai thác lỗ hổng phần mềm\u003c/strong\u003e, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v\u0026hellip;. \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eCó kỹ năng \u003cstrong\u003eSource code review + Pentest blackbox\u003c/strong\u003e các các thiết bị IoT \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eĐam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới \u003c/br\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm: \u003c/br\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v\u0026hellip; trước khi hòa mạng vào hệ thống mạng băng rộng VNPT \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eNghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …) \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eNghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, … \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eNghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile \u003c/br\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT: \u003c/br\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGia nhập VCI, bạn sẽ đóng vai chính cho các dự án \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eLàm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eChế độ đãi ngộ hấp dẫn và review lương theo năng lực \u003c/br\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eChúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân \u003c/br\u003e\nNếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé! \u003c/br\u003e\nHồ sơ ứng viên xin gửi về địa chỉ email: \u003ca href=\"mailto:security@vnpt.vn\"\u003esecurity@vnpt.vn\u003c/a\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"reverse\"\u003eReverse\u003c/h2\u003e\n\u003cp\u003eĐây là kỹ năng mà mình cần rèn luyện và trau dồi.\u003c/p\u003e\n\u003ch3 id=\"dịch-ngược-phần-cứng\"\u003eDịch ngược Phần cứng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eViệc \u003cstrong\u003ebóc tách chip nhớ\u003c/strong\u003e thì sẽ có 2 mục tiêu chính:\n\u003cul\u003e\n\u003cli\u003eThứ 1: Đọc các dữ liệu được lưu trữ không Flash\u003c/li\u003e\n\u003cli\u003eThứ 2: Dump Firmware\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại.\u003c/li\u003e\n\u003cli\u003eViệc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"khai-thác-lỗ-hổng\"\u003eKhai thác lỗ hổng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn.\u003c/li\u003e\n\u003cli\u003eTrong JD có các thuật ngữ mà mình không hiểu, ngoại trừ \u003cstrong\u003ecommand injection\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCái này phức tạp vãi chưởng luôn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pentest-blackbox\"\u003ePentest blackbox\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là \u003cstrong\u003ePentest Web\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHoặc có thể là lấy thông tin từ \u003cstrong\u003eDebug UART\u003c/strong\u003e, tìm kiếm IP Gateway Server, FTP Server,\u0026hellip; =\u0026gt; Pentest Web.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kiểm-định-đánh-giá-an-toàn-bảo-mật\"\u003eKiểm định, đánh giá an toàn bảo mật\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác giao thức truyền thông IoT thì mình biết, nhưng mà để \u003cstrong\u003eđánh giá ATTT\u003c/strong\u003e thì mình chưa rõ.\u003c/li\u003e\n\u003cli\u003eKhông lẻ lấy theo tiêu chuẩn \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/nis2/\"\u003eNIS2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eNhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.\u003c/p\u003e\n\u003cp\u003eBiết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là \u003cstrong\u003eđiều kiện thực hành\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.\u003c/p\u003e\n\u003cp\u003eVì trong IoT còn có những mảng nhỏ khác như:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDesign (vẽ Schematic, PCB)\nCode nhúng Firmware cho MCU\nCode nhúng cho Linux\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/iot_security_jd/",
      "date_published": "4086-04-09T84:44:00+07:00",
      "date_modified": "4086-04-09T84:44:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "588a7f7dd0c3320660bf06f7cbd7a404d2ae850d",
      "title": "Docklight",
      "summary": "",
      "content_text": " Bữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn. Gửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết. Sang tuần mới có board mạch hoàn chỉnh. Lúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để giả lập data Serial.\nCông cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án Công lạnh.\nTool giả lập data cho Serial Mục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code. Những thông tin, data, command id,\u0026hellip; tất cả mình đã có hết. Lúc này mình sẽ dùng Docklight để giả lập data (tương tự như cách CR95 phản hồi command từ MCU). Docklight Đây là công cụ có bản quyền, phải trả phí. Tuy nhiên để dùng free thì mình cần tải phiên bản Docklight 2.2 trở xuống. Download Docklight 2.2 Download Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016) Và đây là Key number để kích hoạt: KEY NUMBER 010111323344556 ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eBữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn.\u003c/li\u003e\n\u003cli\u003eGửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết.\u003c/li\u003e\n\u003cli\u003eSang tuần mới có board mạch hoàn chỉnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để \u003cstrong\u003egiả lập data Serial\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCông cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án \u003cstrong\u003eCông lạnh\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"tool-giả-lập-data-cho-serial\"\u003eTool giả lập data cho Serial\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code.\u003c/li\u003e\n\u003cli\u003eNhững thông tin, data, command id,\u0026hellip; tất cả mình đã có hết.\u003c/li\u003e\n\u003cli\u003eLúc này mình sẽ dùng \u003cstrong\u003eDocklight\u003c/strong\u003e để \u003cstrong\u003egiả lập data\u003c/strong\u003e (tương tự như cách CR95 phản hồi command từ MCU).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"docklight\"\u003eDocklight\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là công cụ có bản quyền, phải trả phí.\u003c/li\u003e\n\u003cli\u003eTuy nhiên để dùng \u003cstrong\u003efree\u003c/strong\u003e thì mình cần tải phiên bản \u003cstrong\u003eDocklight 2.2\u003c/strong\u003e trở xuống.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://docklight.de/downloads/\"\u003eDocklight 2.2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDownload Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eVà đây là \u003cstrong\u003eKey number\u003c/strong\u003e để kích hoạt:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eKEY NUMBER\n010111323344556\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://docklight.de/wp-content/uploads/2018/09/app3_docklight_screenshot_simulator_based_on_log_data.png\"\n  alt=\"docklight\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/docklight/",
      "date_published": "3086-03-09T824:33:00+07:00",
      "date_modified": "3086-03-09T824:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "bbc6371e5a3df28e5b52599641e63196f8c43b5b",
      "title": "ParamSpider",
      "summary": "",
      "content_text": "Bữa có coi video trên Youtube có tựa đề: 5 Hacking Tools I Can\u0026rsquo;t Live Without\nTrong đó có đề cập đến các công cụ dành cho việc Pentest Web:\n1. DevTools 2. BURP Suite 3. Containers 4. FFUF 5. ParamSpider Mấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.\nGithub ParamSpider Dựa vào thông tin trên github công cụ giống như Wayback Machine Tuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian. Công cụ này cũng ổn áp \u0026ldquo;phết\u0026rdquo;. ",
      "content_html": "\u003cp\u003eBữa có coi video trên Youtube có tựa đề: \u003ca href=\"https://www.youtube.com/watch?v=JHRzVEvpHSM\u0026amp;list=WL\u0026amp;index=2\"\u003e5 Hacking Tools I Can\u0026rsquo;t Live Without\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTrong đó có đề cập đến các công cụ dành cho việc Pentest Web:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. DevTools\n2. BURP Suite\n3. Containers\n4. FFUF\n5. ParamSpider\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.\u003c/p\u003e\n\u003ch3 id=\"github-paramspiderhttpsgithubcomdevanshbathamparamspider\"\u003e\u003ca href=\"https://github.com/devanshbatham/ParamSpider\"\u003eGithub ParamSpider\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa vào thông tin trên github công cụ giống như \u003ca href=\"https://web.archive.org/\"\u003eWayback Machine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian.\u003c/li\u003e\n\u003cli\u003eCông cụ này cũng ổn áp \u0026ldquo;phết\u0026rdquo;.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://raw.githubusercontent.com/devanshbatham/ParamSpider/master/static/paramspider.png\"\n  alt=\"paramspider\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/paramspider/",
      "date_published": "3086-03-09T824:33:00+07:00",
      "date_modified": "3086-03-09T824:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a0a7c8213b1aec2b91bd5b2214fd070ecf7037c",
      "title": "Research_CR95",
      "summary": "",
      "content_text": "Giới thiệu: CR95 là dòng chip dùng để đọc RFID và NFC. Các thiết bị Giám sát hành trình theo QCVN31 đều phải có bộ RFID, để đọc thẻ tài xế. Công ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại IC CR95 (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này). Yêu cầu: Nghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART. Dùng ngôn ngữ lập trình Rust để viết Firmware. Research Sau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là SPI. Mình cần xem lại datasheet của CR95. Về phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware. May mắn thay Lúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART. Source code anh này được viết bằng C, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một board phần cứng CR95 khác Sau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là: Echo: 0x55 Info: 0x0100 Set Protocol: 0x02020109 SendRecv: 0x0403022000 Tới đây thì mình bó tay, không hiều làm sao mà có thể đọc được thông tin ID, tên tài xế, giấy phép lái xe của thẻ RFID Và mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,\u0026hellip; Nhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp. Đọc tín hiệu xung Khi gần như bế tắc thì anh Sơn đã gợi ý là đọc tín hiệu xung. Và mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng board logic analyzer Board này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại phần mềm hỗ trợ cho board này lại cực xịn (đánh giá cá nhân). Từ hình 1 và hình 2 là mình biết rằng những lệnh command ban đầu của mình đã đúng. Tiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế: Cuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi SendRecv thì nó chỉ đọc được số lượng byte nhất định, nên để đọc được hết thông tin thì mình cần gửi: 0x0403022000 0x0403022001 0x0403022002 0x0403022003 0x0403022004 . . . . . . Cứ thế gửi cho đến khi đọc hết thông tin. Nhiệm vụ tiếp theo Bây giờ đã rõ hết cấu trúc bản tin. Nhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết. Parse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh. Suy nghĩ: Lúc trước mình có xem một video về các công cụ hardware hacking dành cho việc Firmware Reverse, thì Logic Analyzer là một trong các công cụ đó. Mình thấy một Hardware Engineer công việc cũng giống như một IoT Hacker, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế. Chỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,\u0026hellip; Mình có thể mường tưởng ra cách Trung Quốc họ copy: Mua sản phẩm Kiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng) Dịch ngược bằng cách: bắt tín hiệu xung, dump firmware. Đến bây giờ mình mới có thể hiểu. =]] ",
      "content_html": "\u003ch3 id=\"giới-thiệu\"\u003eGiới thiệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCR95\u003c/strong\u003e là dòng chip dùng để đọc \u003cstrong\u003eRFID\u003c/strong\u003e và \u003cstrong\u003eNFC\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCác thiết bị Giám sát hành trình theo \u003cstrong\u003eQCVN31\u003c/strong\u003e đều phải có bộ RFID, để đọc thẻ tài xế.\u003c/li\u003e\n\u003cli\u003eCông ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại \u003cstrong\u003eIC CR95\u003c/strong\u003e (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"yêu-cầu\"\u003eYêu cầu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART.\u003c/li\u003e\n\u003cli\u003eDùng ngôn ngữ lập trình Rust để viết Firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"research\"\u003eResearch\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là \u003cstrong\u003eSPI\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình cần xem lại \u003ca href=\"https://www.st.com/resource/en/datasheet/cr95hf.pdf\"\u003edatasheet của CR95\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eVề phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"may-mắn-thay\"\u003eMay mắn thay\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSource code\u003c/strong\u003e anh này được viết \u003cstrong\u003ebằng C\u003c/strong\u003e, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một \u003ca href=\"http://www.tme.vn/product.aspx?id=2095#page=pro_info\"\u003eboard phần cứng CR95 khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/CR95HF-BRD.jpg\"\n  alt=\"CR95HF-BRD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eEcho: 0x55\nInfo: 0x0100\nSet Protocol: 0x02020109\nSendRecv: 0x0403022000\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTới đây thì mình \u003cstrong\u003ebó tay\u003c/strong\u003e, không hiều làm sao mà có thể đọc được \u003cstrong\u003ethông tin ID, tên tài xế, giấy phép lái xe\u003c/strong\u003e của thẻ RFID\u003c/li\u003e\n\u003cli\u003eVà mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eNhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"đọc-tín-hiệu-xung\"\u003eĐọc tín hiệu xung\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi gần như bế tắc thì anh Sơn đã gợi ý là \u003cstrong\u003eđọc tín hiệu xung\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng \u003ca href=\"https://hshop.vn/products/mach-usb-saleae-8ch-24mhz-logic-analyzer\"\u003eboard logic analyzer\u003c/a\u003e\n\u003cimg\n  src=\"https://product.hstatic.net/1000069225/product/c583f4e0-da4c-4abe-9e29-16844f44de69_1_201_a_9a3822254fa44d8e9e2fb043ec157eaf_1024x1024.jpg\"\n  alt=\"logic analyzer\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/li\u003e\n\u003cli\u003eBoard này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại \u003ca href=\"https://www.saleae.com/pages/downloads\"\u003ephần mềm hỗ trợ\u003c/a\u003e cho board này lại cực xịn (đánh giá cá nhân).\u003c/li\u003e\n\u003cli\u003eTừ \u003cstrong\u003ehình 1\u003c/strong\u003e và \u003cstrong\u003ehình 2\u003c/strong\u003e là mình biết rằng những lệnh command ban đầu của mình đã đúng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_1.png\"\n  alt=\"CR95-Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_2.png\"\n  alt=\"CR95-Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_3.png\"\n  alt=\"CR95-Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi \u003cstrong\u003eSendRecv\u003c/strong\u003e thì nó chỉ đọc được số lượng \u003cstrong\u003ebyte\u003c/strong\u003e nhất định, nên để đọc được hết thông tin thì mình cần gửi:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e0x0403022000\n0x0403022001\n0x0403022002\n0x0403022003\n0x0403022004\n.\n.\n.\n.\n.\n.\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCứ thế gửi cho đến khi đọc hết thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nhiệm-vụ-tiếp-theo\"\u003eNhiệm vụ tiếp theo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBây giờ đã rõ hết cấu trúc bản tin.\u003c/li\u003e\n\u003cli\u003eNhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết.\u003c/li\u003e\n\u003cli\u003eParse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"suy-nghĩ\"\u003eSuy nghĩ:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước mình có xem một video về các công cụ hardware hacking dành cho việc \u003cstrong\u003eFirmware Reverse\u003c/strong\u003e, thì \u003cstrong\u003eLogic Analyzer\u003c/strong\u003e là một trong các công cụ đó.\u003c/li\u003e\n\u003cli\u003eMình thấy một \u003cstrong\u003eHardware Engineer\u003c/strong\u003e công việc cũng giống như một \u003cstrong\u003eIoT Hacker\u003c/strong\u003e, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế.\u003c/li\u003e\n\u003cli\u003eChỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eMình có thể mường tưởng ra cách Trung Quốc họ copy:\n\u003cul\u003e\n\u003cli\u003eMua sản phẩm\u003c/li\u003e\n\u003cli\u003eKiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng)\u003c/li\u003e\n\u003cli\u003eDịch ngược bằng cách: bắt tín hiệu xung, dump firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐến bây giờ mình mới có thể hiểu. =]]\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/research_cr95/",
      "date_published": "28076-28-09T712:2828:00+07:00",
      "date_modified": "28076-28-09T712:2828:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "3773da73191fa8a6069587b66c683bd684be80dd",
      "title": "Tails_OS",
      "summary": "",
      "content_text": "Ẩn danh - Anonymous Mình có đọc hết cuốn Nghệ Thuật Ẩn Mình, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay. Tựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.\nDùng sóng di động (nói chung là dùng sim4G) Sử dụng VPN, Proxy. Sử dụng Tor Browser Hôm nay khi xem video trên Youtube, thì mình biết đến Tails\nHow To Access the DARK WEB in 2024 (3 Levels) Tails Linux USB with Persistence (Be invisible online in 7 minutes) Tails OS Tails tương tự như việc mình chạy một hệ điều hành song song vậy (và ở đây là trên USB). Bản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như Tor Browser. Như mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,\u0026hellip; Ngay cả khi mình tắt máy, thì những thông tin đó vẫn được lưu trữ trên RAM. Và đây là lúc Tails phát huy ưu điểm nổi bật chính là không lưu trữ bất kỳ thứ gì sau khi tắt máy. Tức là những thao tác trên máy, thông tin hoặc vô tình bị dính malware đều sẽ biến mất hết khi mình rút USB. HAY THẬT Suy nghĩ về Ẩn danh Nói ẩn danh cho vui vậy thôi, chứ nhà nước mà muốn mò ra thì mò cái một. Đơn giản là vì nhà mạng nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là vấn đề thời gian. Do đó nếu muốn ẩn danh thật sự thì tốt nhất đừng làm gì liên quan đến Chính phủ. =]] Mình thì không có nhu cầu vào Dark Web, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên Tails OS vẫn là một biện pháp hay ho khi mình muốn làm gì đó mà không muốn người khác biết. ",
      "content_html": "\u003ch3 id=\"ẩn-danh---anonymous\"\u003eẨn danh - Anonymous\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMình có đọc hết cuốn \u003ca href=\"https://tiki.vn/nghe-thuat-an-minh-p8845822.html\"\u003eNghệ Thuật Ẩn Mình\u003c/a\u003e, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay.\n\u003cimg\n  src=\"https://salt.tikicdn.com/cache/750x750/ts/product/47/4b/45/6386ab1926fd23aad2b93d8f83429769.jpg.webp\"\n  alt=\"Nghệ Thuật Ẩn Mình\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDùng sóng di động (nói chung là \u003cstrong\u003edùng sim4G\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003eSử dụng VPN, Proxy.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003ca href=\"https://www.torproject.org/download/\"\u003eTor Browser\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHôm nay khi xem video trên Youtube, thì mình biết đến \u003ca href=\"https://tails.net/\"\u003eTails\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=U2-JPqrALsA\u0026amp;list=WL\u0026amp;index=2\"\u003eHow To Access the DARK WEB in 2024 (3 Levels)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=gO9fTnMxwYw\"\u003eTails Linux USB with Persistence (Be invisible online in 7 minutes)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tails-os\"\u003eTails OS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTails\u003c/strong\u003e tương tự như việc mình chạy một \u003cstrong\u003ehệ điều hành\u003c/strong\u003e song song vậy (và ở đây là trên USB).\u003c/li\u003e\n\u003cli\u003eBản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như \u003cstrong\u003eTor Browser\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhư mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eNgay cả khi mình tắt máy, thì những thông tin đó vẫn được \u003cstrong\u003elưu trữ trên RAM\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà đây là lúc \u003cstrong\u003eTails\u003c/strong\u003e phát huy ưu điểm nổi bật chính là \u003cstrong\u003ekhông lưu trữ bất kỳ thứ gì sau khi tắt máy\u003c/strong\u003e. Tức là những thao tác trên máy, thông tin hoặc vô tình \u003cstrong\u003ebị dính malware\u003c/strong\u003e đều sẽ biến mất hết khi mình rút USB.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHAY THẬT\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"suy-nghĩ-về-ẩn-danh\"\u003eSuy nghĩ về Ẩn danh\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNói \u003cstrong\u003eẩn danh\u003c/strong\u003e cho vui vậy thôi, chứ nhà nước mà muốn \u003cstrong\u003emò\u003c/strong\u003e ra thì mò cái một. Đơn giản là vì \u003cstrong\u003enhà mạng\u003c/strong\u003e nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là \u003cstrong\u003evấn đề thời gian\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDo đó nếu muốn \u003cstrong\u003eẩn danh thật sự\u003c/strong\u003e thì tốt nhất đừng làm gì liên quan đến \u003cstrong\u003eChính phủ\u003c/strong\u003e. =]]\u003c/li\u003e\n\u003cli\u003eMình thì không có nhu cầu vào \u003cstrong\u003eDark Web\u003c/strong\u003e, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên \u003cstrong\u003eTails OS\u003c/strong\u003e vẫn là một biện pháp hay ho khi mình \u003cstrong\u003emuốn làm gì đó mà không muốn người khác biết\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Google_vs_DuckDuckGo.jpg\"\n  alt=\"Search\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/tails_os/",
      "date_published": "21076-21-09T734:2121:00+07:00",
      "date_modified": "21076-21-09T734:2121:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7966a7585a1eca2b3277bf71ec1d0a822315c7b7",
      "title": "Suy_nghi_ve_Hardware_Hacking",
      "summary": "",
      "content_text": "Sau khi mình đã đọc hết cuốn Vùng tối. Những hacker đời đầu chính là các nhà vật lý, những người kỹ sư, kỹ thuật điện tử.\nKhi thế giới vẫn còn điện tử tương tự, các điệp viên đã dùng các kỹ thuật để chặn, bắt tín hiệu.\nĐể rồi khi thế giới chuyển sang điện tử số, sự ra đời của internet. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,\u0026hellip;\nDạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.\nCũng như trong Show Ryan: What Does a Former Black Hat Hacker Carry Everyday? có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể thu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu. Mình nhớ kỹ thuật này gọi là Relay Atack\nLà một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự quá hay và ghê gớm.\nNgười làm ra những thiết bị này đúng là tay chơi về phần cứng, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.\nLà hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.\nMình cần rèn luyện kỹ năng, và ghi nhớ Hack to learn and not Learn to Hack.\nMột bài viết khác về Hardware hacking - Tấn công HID Tổng hợp các tài liệu về IoT Hacking: https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/ https://v33ru.github.io/IoTSecurity101/ https://github.com/nebgnahz/awesome-iot-hacks https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme https://www.iotpentestingguide.com/ https://p.ost2.fyi/courses IoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.\nCó lẻ vậy.\nTổng hợp các ý hay trong cuốn Vùng tối Nền tảng của Tác chiến Thông tin: Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.\nCNE (Computer Network Exploitation) - Khai thác Mạng máy tính: Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.\n",
      "content_html": "\u003cp\u003eSau khi mình đã đọc hết cuốn \u003ca href=\"https://tiki.vn/khoa-hoc-kham-pha-vung-toi-lich-su-bi-an-cua-chien-tranh-mang-p251393388.html\"\u003eVùng tối\u003c/a\u003e. Những \u003cstrong\u003ehacker đời đầu\u003c/strong\u003e chính là các \u003cstrong\u003enhà vật lý\u003c/strong\u003e, những người \u003cstrong\u003ekỹ sư, kỹ thuật điện tử\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://salt.tikicdn.com/cache/540x540/ts/product/46/60/43/e4ff35baeeaf8bb049e0c864e6132c6b.jpg\"\n  alt=\"Vùng tối - Book\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eKhi thế giới vẫn còn \u003cstrong\u003eđiện tử tương tự\u003c/strong\u003e, các điệp viên đã dùng các kỹ thuật để \u003cstrong\u003echặn, bắt tín hiệu\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐể rồi khi thế giới chuyển sang \u003cstrong\u003eđiện tử số\u003c/strong\u003e, sự ra đời của \u003cstrong\u003einternet\u003c/strong\u003e. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eDạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.\u003c/p\u003e\n\u003cp\u003eCũng như trong \u003ca href=\"https://www.youtube.com/watch?v=7MIoFxwawc0\u0026amp;list=WL\u0026amp;index=4\u0026amp;t=1s\"\u003eShow Ryan: What Does a Former Black Hat Hacker Carry Everyday?\u003c/a\u003e có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể \u003cstrong\u003ethu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu\u003c/strong\u003e. Mình nhớ kỹ thuật này gọi là \u003cstrong\u003eRelay Atack\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLà một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự \u003cstrong\u003equá hay và ghê gớm\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNgười làm ra những thiết bị này đúng là \u003cstrong\u003etay chơi về phần cứng\u003c/strong\u003e, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.\u003c/p\u003e\n\u003cp\u003eLà hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.\u003c/p\u003e\n\u003cp\u003eMình cần rèn luyện kỹ năng, và ghi nhớ \u003cstrong\u003eHack to learn and not Learn to Hack\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"một-bài-viết-khác-về-hardware-hacking---tấn-công-hidhttpswhitehatvnthreadstan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao18012\"\u003e\u003ca href=\"https://whitehat.vn/threads/tan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao.18012/\"\u003eMột bài viết khác về Hardware hacking - Tấn công HID\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-tài-liệu-về-iot-hacking\"\u003eTổng hợp các tài liệu về IoT Hacking:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/\"\u003ehttps://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://v33ru.github.io/IoTSecurity101/\"\u003ehttps://v33ru.github.io/IoTSecurity101/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/nebgnahz/awesome-iot-hacks\"\u003ehttps://github.com/nebgnahz/awesome-iot-hacks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme\"\u003ehttps://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.iotpentestingguide.com/\"\u003ehttps://www.iotpentestingguide.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://p.ost2.fyi/courses\"\u003ehttps://p.ost2.fyi/courses\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.\u003c/p\u003e\n\u003cp\u003eCó lẻ vậy.\u003c/p\u003e\n\u003ch3 id=\"tổng-hợp-các-ý-hay-trong-cuốn-vùng-tối\"\u003eTổng hợp các ý hay trong cuốn \u003cstrong\u003eVùng tối\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eNền tảng của Tác chiến Thông tin:\u003c/strong\u003e Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCNE (Computer Network Exploitation) - Khai thác Mạng máy tính:\u003c/strong\u003e Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_0.jpg\"\n  alt=\"Hình 0\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/suy_nghi_ve_hardware_hacking/",
      "date_published": "10076-10-09T734:1010:00+07:00",
      "date_modified": "10076-10-09T734:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c4bdccacc5a8e26c6238ec72e87ccc4b188451b2",
      "title": "Goc_nhin_ve_Ngoai_ngu",
      "summary": "",
      "content_text": "Một góc nhìn cá nhân về Ngoại ngữ Là một người thiên về Khoa học Kỹ thuật thì với mình, Ngoại ngữ là một công cụ. Mình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là một cái gì đó. Tại sao mình có suy nghĩ Ngoại ngữ là một công cụ Thú thật thì mình là một đứa ngu ngốc về ngoại ngữ (cụ thể là Anh văn). Chả biết là do mình yếu Anh văn \u0026ndash;\u0026gt; Không coi trọng, hay là vì Không coi trọng \u0026ndash;\u0026gt; Yếu Anh văn ??? Nhưng có một điều chắc chắn là mình biết anh văn quan trọng, nhưng chưa phải là yếu tố quyết định. Mục tiêu của mình đối với Anh văn chỉ đơn giản, đó là cầu nối với kiến thức của nhân loại. Anh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì. Tại sao lại thế? Mình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có sự yêu thích và đam mê nhất định thì mới theo được. Mình cũng vậy, khi có sự yêu thích sẽ dẫn đến nhu cầu tìm hiểu, học hỏi cái mới. Và đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào: Search keyword bằng tiếng anh. Đọc hiểu tài liệu tiếng anh. Đó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân). Một tình huống hài hước khác. Có những lúc đi hội thảo, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh. Có những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày. Nhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu: Ông này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.\nSuy nghĩ khác Nếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì Trời đất, họ sẽ thăng tiến kinh lắm. Chưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là leader, Manager,\u0026hellip; Lương sẽ khủng lắm đây. Mà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.\nNgười ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân.\n",
      "content_html": "\u003ch2 id=\"một-góc-nhìn-cá-nhân-về-ngoại-ngữ\"\u003eMột \u003cstrong\u003egóc nhìn cá nhân\u003c/strong\u003e về Ngoại ngữ\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLà một người thiên về Khoa học Kỹ thuật thì với mình, \u003cstrong\u003eNgoại ngữ là một công cụ\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là \u003cstrong\u003emột cái gì đó\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-mình-có-suy-nghĩ-ngoại-ngữ-là-một-công-cụ\"\u003eTại sao mình có suy nghĩ \u003cstrong\u003eNgoại ngữ là một công cụ\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThú thật thì mình là một đứa \u003cstrong\u003engu ngốc\u003c/strong\u003e về ngoại ngữ (cụ thể là \u003cstrong\u003eAnh văn\u003c/strong\u003e).\u003c/li\u003e\n\u003cli\u003eChả biết là do mình \u003cstrong\u003eyếu Anh văn \u0026ndash;\u0026gt; Không coi trọng\u003c/strong\u003e, hay là vì \u003cstrong\u003eKhông coi trọng \u0026ndash;\u0026gt; Yếu Anh văn\u003c/strong\u003e ???\u003c/li\u003e\n\u003cli\u003eNhưng có một điều chắc chắn là mình biết \u003cstrong\u003eanh văn quan trọng\u003c/strong\u003e, nhưng chưa phải là \u003cstrong\u003eyếu tố quyết định\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMục tiêu của mình đối với Anh văn chỉ đơn giản, đó là \u003cstrong\u003ecầu nối với kiến thức của nhân loại\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eAnh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-lại-thế\"\u003eTại sao lại thế?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có \u003cstrong\u003esự yêu thích và đam mê nhất định\u003c/strong\u003e thì mới theo được.\u003c/li\u003e\n\u003cli\u003eMình cũng vậy, khi có sự yêu thích sẽ dẫn đến \u003cstrong\u003enhu cầu tìm hiểu, học hỏi cái mới\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào:\n\u003cul\u003e\n\u003cli\u003eSearch keyword bằng tiếng anh.\u003c/li\u003e\n\u003cli\u003eĐọc hiểu tài liệu tiếng anh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-tình-huống-hài-hước-khác\"\u003eMột tình huống hài hước khác.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó những lúc đi \u003cstrong\u003ehội thảo\u003c/strong\u003e, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh.\u003c/li\u003e\n\u003cli\u003eCó những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày.\u003c/li\u003e\n\u003cli\u003eNhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eÔng này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"suy-nghĩ-khác\"\u003eSuy nghĩ khác\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì \u003cstrong\u003eTrời đất, họ sẽ thăng tiến kinh lắm\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eChưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là \u003cstrong\u003eleader\u003c/strong\u003e, \u003cstrong\u003eManager\u003c/strong\u003e,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eLương sẽ khủng lắm đây.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNgười ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân\u003c/strong\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/goc_nhin_ve_ngoai_ngu/",
      "date_published": "7076-07-09T73:77:00+07:00",
      "date_modified": "7076-07-09T73:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4fa8cc860c52b268dc6a3adcde7305e9415db5bb",
      "title": "Tools",
      "summary": "",
      "content_text": "Tool: Git-Dumper Trong quá trình recon một trang web, mà mình thấy có đường dẫn .git Thì có thể dùng tool git-dumper này để lấy thông tin. Tool Web Check Đây là một công cụ có thể sử dụng online, hoặc build ở local. Công cụ này giúp mình recon những thông số cơ bản của một trang web. Tài liệu: 1. https://github.com/lissy93/web-check 2. https://web-check.xyz/about#api-documentation Caido Công cụ này có chức năng tương tự như Burp-Suite, nhưng mà là ở giao diện Web. Tham khảo Youtube: How to Hack Web Apps with Caido Tài liệu: Docs Github Project Cuckoo Sandbox https://cuckoosandbox.org/download https://cuckoo.sh/docs/ https://cuckoo.sh/docs/installation/host/requirements.html https://cuckoosandbox.org/blog/207-interim-release Bunkerweb - WAF https://github.com/bunkerity/bunkerweb https://www.bunkerweb.io/ https://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview https://demo.bunkerweb.io/ https://www.youtube.com/@bunkerity4183/videos Duplicati Youtube: Backup in Linux Servers - Docker Volumes, and Databases Theo như video, thì ở đây sử dụng một open-source tên là duplicati Documents của Duplicati Cài đặt Duplicati bằng Docker linuxserver/duplicati duplicati-tutorial Script thực hiện việc auto-backup Tham khảo khác Nettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management Github Project: Nettacker Documents: https://owasp.org/www-project-nettacker/ Note: Nhìn chung mình thấy tool này khá giống với tool reNgine, hoặc một số công cụ auto-scan khác. AESCrypt: Công cụ mã hóa file Đây là một phần mềm mã nguồn mở, hỗ trợ mã hóa file. Video giới thiệu về công cụ này: AESCrypt - Mã hoá file Một bài viết khác Hardware hacking tools ",
      "content_html": "\u003ch3 id=\"tool-git-dumperhttpsgithubcomarthaudgit-dumper\"\u003e\u003ca href=\"https://github.com/arthaud/git-dumper\"\u003eTool: Git-Dumper\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình \u003cstrong\u003erecon\u003c/strong\u003e một trang web, mà mình thấy có đường dẫn \u003ccode\u003e.git\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThì có thể dùng tool \u003cstrong\u003egit-dumper\u003c/strong\u003e này để lấy thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tool-web-checkhttpsweb-checkxyz\"\u003e\u003ca href=\"https://web-check.xyz/\"\u003eTool Web Check\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ có thể sử dụng online, hoặc build ở local.\u003c/li\u003e\n\u003cli\u003eCông cụ này giúp mình recon những thông số cơ bản của một trang web.\u003c/li\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. https://github.com/lissy93/web-check\n2. https://web-check.xyz/about#api-documentation\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"caidohttpscaidoio\"\u003e\u003ca href=\"https://caido.io/\"\u003eCaido\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này có chức năng tương tự như \u003cstrong\u003eBurp-Suite\u003c/strong\u003e, nhưng mà là ở \u003cstrong\u003egiao diện Web\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=5Di0VVK9JiQ\u0026amp;list=WL\u0026amp;index=2\"\u003eTham khảo Youtube: How to Hack Web Apps with Caido\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.caido.io/\"\u003eDocs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/caido\"\u003eGithub Project\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"cuckoo-sandbox\"\u003eCuckoo Sandbox\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://cuckoosandbox.org/download\nhttps://cuckoo.sh/docs/\nhttps://cuckoo.sh/docs/installation/host/requirements.html\nhttps://cuckoosandbox.org/blog/207-interim-release\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"bunkerweb---waf\"\u003eBunkerweb - WAF\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/bunkerity/bunkerweb\"\u003ehttps://github.com/bunkerity/bunkerweb\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.bunkerweb.io/\"\u003ehttps://www.bunkerweb.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview\"\u003ehttps://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://demo.bunkerweb.io/\"\u003ehttps://demo.bunkerweb.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/@bunkerity4183/videos\"\u003ehttps://www.youtube.com/@bunkerity4183/videos\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"duplicati\"\u003eDuplicati\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=JoA6Bezgk1c\u0026amp;list=WL\u0026amp;index=107\"\u003eYoutube: Backup in Linux Servers - Docker Volumes, and Databases\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTheo như video, thì ở đây sử dụng một open-source tên là \u003ca href=\"https://www.duplicati.com/download\"\u003eduplicati\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://duplicati.readthedocs.io/en/latest/01-introduction/\"\u003eDocuments của Duplicati\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"cài-đặt-duplicati-bằng-docker\"\u003eCài đặt Duplicati bằng Docker\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.linuxserver.io/images/docker-duplicati\"\u003elinuxserver/duplicati\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/christianlempa/videos/tree/main/duplicati-tutorial\"\u003eduplicati-tutorial\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"script-thực-hiện-việc-auto-backuphttpsgithubcomchristianlempascriptstreemaindb-container-backup\"\u003e\u003ca href=\"https://github.com/ChristianLempa/scripts/tree/main/db-container-backup\"\u003eScript thực hiện việc auto-backup\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=wvsi3QilNQ8\"\u003eTham khảo khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nettacker-automated-penetration-testing-framework---open-source-vulnerability-scanner---vulnerability-management\"\u003eNettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGithub Project: \u003ca href=\"https://github.com/OWASP/Nettacker\"\u003eNettacker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocuments: \u003ca href=\"https://owasp.org/www-project-nettacker/\"\u003ehttps://owasp.org/www-project-nettacker/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Nhìn chung mình thấy tool này khá giống với tool \u003cstrong\u003ereNgine\u003c/strong\u003e, hoặc một số công cụ auto-scan khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"aescrypthttpswwwaescryptcom-công-cụ-mã-hóa-file\"\u003e\u003ca href=\"https://www.aescrypt.com/\"\u003eAESCrypt\u003c/a\u003e: Công cụ mã hóa file\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một phần mềm \u003cstrong\u003emã nguồn mở\u003c/strong\u003e, hỗ trợ mã hóa file.\u003c/li\u003e\n\u003cli\u003eVideo giới thiệu về công cụ này: \u003ca href=\"https://www.youtube.com/watch?v=zA4dDlslDXo\"\u003eAESCrypt - Mã hoá file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://services.udel.edu/TDClient/32/Portal/KB/ArticleDet?ID=366\"\u003eMột bài viết khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hardware-hacking-tools\"\u003eHardware hacking tools\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Hardware_Hacking.jpg\"\n  alt=\"Hardware Hacking Tools\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/tools/",
      "date_published": "6076-06-09T736:66:00+07:00",
      "date_modified": "6076-06-09T736:66:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "101ddf258848dd5a99a97fc806696d3b87397047",
      "title": "RedTeam",
      "summary": "",
      "content_text": "5 free red teaming resources to get you started Red Team Notes Red Teaming Handbook Red Team Tools Red Teaming Toolkit ",
      "content_html": "\u003ch3 id=\"5-free-red-teaming-resources-to-get-you-startedhttpswwwhelpnetsecuritycom20240416free-red-teaming-resources\"\u003e\u003ca href=\"https://www.helpnetsecurity.com/2024/04/16/free-red-teaming-resources/\"\u003e5 free red teaming resources to get you started\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dmcxblue.gitbook.io/red-team-notes-2-0\"\u003eRed Team Notes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://assets.publishing.service.gov.uk/media/61702155e90e07197867eb93/20210625-Red_Teaming_Handbook.pdf\"\u003eRed Teaming Handbook\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/A-poc/RedTeam-Tools\"\u003eRed Team Tools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/infosecn1nja/Red-Teaming-Toolkit\"\u003eRed Teaming Toolkit\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/redteam/",
      "date_published": "15066-15-09T65:1515:00+07:00",
      "date_modified": "15066-15-09T65:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4f09e909e9a87e6f4fa1e981ddc482695a0ed92a",
      "title": "TheHive",
      "summary": "",
      "content_text": " Theo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình: Phát hiện Báo cáo Xử lý Công cụ TheHive là nằm trong giai đoạn 2. Ví dụ dễ hiểu như sau: Khi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này. Nếu không xử lý được, hoặc mức độ phức tạp cao thì tạo Ticket mô tả và cung cấp đầy đủ thông tin. (Giai đoạn này là bước sử dụng TheHive). Người có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý. TheHive TheHive cũng có chức năng như JIRA, tuy nhiên TheHive là open-source. Documents: - https://thehive-project.org/ - http://docs.thehive-project.org/cortex/ - https://github.com/thehive-project/Cortex/ - https://blog.thehive-project.org/ - https://docs.thehive-project.org/ - https://github.com/TheHive-Project/Cortex Tham khảo TheHive với Graylog - https://blog.reconinfosec.com/integrating-graylog-with-thehive - https://github.com/ReconInfoSec/graylog2thehive ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eTheo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình:\n\u003cul\u003e\n\u003cli\u003ePhát hiện\u003c/li\u003e\n\u003cli\u003eBáo cáo\u003c/li\u003e\n\u003cli\u003eXử lý\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCông cụ \u003cstrong\u003eTheHive\u003c/strong\u003e là nằm trong giai đoạn 2.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ví-dụ-dễ-hiểu-như-sau\"\u003eVí dụ dễ hiểu như sau:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này.\u003c/li\u003e\n\u003cli\u003eNếu không xử lý được, hoặc mức độ phức tạp cao thì tạo \u003cstrong\u003eTicket\u003c/strong\u003e mô tả và cung cấp đầy đủ thông tin.\n(Giai đoạn này là bước sử dụng \u003cstrong\u003eTheHive\u003c/strong\u003e).\u003c/li\u003e\n\u003cli\u003eNgười có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"thehive\"\u003eTheHive\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTheHive cũng có chức năng như \u003cstrong\u003eJIRA\u003c/strong\u003e, tuy nhiên TheHive là \u003cstrong\u003eopen-source\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDocuments:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- https://thehive-project.org/\n- http://docs.thehive-project.org/cortex/\n- https://github.com/thehive-project/Cortex/\n- https://blog.thehive-project.org/\n- https://docs.thehive-project.org/\n- https://github.com/TheHive-Project/Cortex\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tham-khảo-thehive-với-graylog\"\u003eTham khảo TheHive với Graylog\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- https://blog.reconinfosec.com/integrating-graylog-with-thehive\n- https://github.com/ReconInfoSec/graylog2thehive\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/thehive/",
      "date_published": "15066-15-09T64:1515:00+07:00",
      "date_modified": "15066-15-09T64:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d301d9e6e4aeff77c37f37bb07966a98039f0832",
      "title": "OSINT",
      "summary": "",
      "content_text": "OSINT - Open Source Intelligence Bước đầu tiên trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là thu thập các thông tin giá trị về mục tiêu. Thu thập thông tin thì có 2 dạng là: Passive Reconnaissance - Thu thập thông tin thụ động Active Reconnaissance - Thu thập thông tin chủ động Trong đó việc thu thập thông tin thụ động thường được gọi là OSINT. Bất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí. Others Documents https://www.hackers-arise.com/osint Top 10 công cụ OSINT tốt nhất 2020 Một số công cụ theo OSINT Framework mà mình biết: VirusTotal Shodan Wayback Machine ANY.RUN ",
      "content_html": "\u003ch3 id=\"osint---open-source-intelligencehttpsanonyvietcomosint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet\"\u003e\u003ca href=\"https://anonyviet.com/osint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet/\"\u003eOSINT - Open Source Intelligence\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBước đầu tiên\u003c/strong\u003e trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là \u003cstrong\u003ethu thập các thông tin\u003c/strong\u003e giá trị về mục tiêu.\u003c/li\u003e\n\u003cli\u003eThu thập thông tin thì có 2 dạng là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePassive Reconnaissance - Thu thập thông tin thụ động\nActive Reconnaissance - Thu thập thông tin chủ động\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTrong đó việc \u003cstrong\u003ethu thập thông tin thụ động\u003c/strong\u003e thường được gọi là \u003cstrong\u003eOSINT\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eBất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"others-documents\"\u003eOthers Documents\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.hackers-arise.com/osint\"\u003ehttps://www.hackers-arise.com/osint\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://anonyviet.com/cac-tool-osint-truy-vet-toi-pham-tren-internet/\"\u003eTop 10 công cụ OSINT tốt nhất 2020\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-số-công-cụ-theo-osint-frameworkhttpsosintframeworkcom-mà-mình-biết\"\u003eMột số công cụ theo \u003ca href=\"https://osintframework.com/\"\u003eOSINT Framework\u003c/a\u003e mà mình biết:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.virustotal.com/gui/home/upload\"\u003eVirusTotal\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.shodan.io/\"\u003eShodan\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://archive.org/web/\"\u003eWayback Machine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://any.run/\"\u003eANY.RUN\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/osint/",
      "date_published": "15066-15-09T62:1515:00+07:00",
      "date_modified": "15066-15-09T62:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c63929f0d793b4d6bd0bdcf6149015836543e3ec",
      "title": "ESD",
      "summary": "",
      "content_text": "ESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện Là dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.\nĐây là một video nói về cách chống tĩnh điện, dựa trên các linh kiện:\nTVS - Transient Voltage Suppressor MOV - Metal Oxide Varistor GDT - Gas Discharge Tube TVS Diode Một video giải thích cách hoạt động của TVS Diode\nTrong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.\nMột ví dụ về linh kiện TVS, Semtech SMF05C.TCT\nMOV Linh kiện Bourns MOV-10D470KKTR GDT Linh kiện Bourns GDT25-47-S1-RP ",
      "content_html": "\u003ch2 id=\"esd-electrostatic-sensitive-devices---sự-phóng-tĩnh-điện\"\u003eESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLà dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eĐây là một \u003ca href=\"https://www.youtube.com/watch?v=MzxBBXpgwrE\"\u003evideo\u003c/a\u003e nói về cách \u003cstrong\u003echống tĩnh điện\u003c/strong\u003e, dựa trên các linh kiện:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eTVS - Transient Voltage Suppressor\nMOV - Metal Oxide Varistor\nGDT - Gas Discharge Tube\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tvs-diode\"\u003eTVS Diode\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=oKACLpBYhxU\"\u003eMột video giải thích cách hoạt động của TVS Diode\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMột ví dụ về linh kiện TVS, \u003ca href=\"https://www.mouser.vn/ProductDetail/Semtech/SMF05C.TCT?qs=rBWM4%252BvDhIcdGOAFdL4XAA%3D%3D\u0026amp;_gl=1*109bc2w*_ga*ODE4NDU2NjY3LjE3MTM3NzI5OTI.*_ga_15W4STQT4T*MTcxMzc3Mjk5Mi4xLjAuMTcxMzc3Mjk5My41OS4wLjA.\"\u003eSemtech SMF05C.TCT\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mov\"\u003eMOV\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLinh kiện \u003ca href=\"https://www.mouser.vn/ProductDetail/Bourns/MOV-10D470KKTR?qs=ST9lo4GX8V0v1uLdRAW6Kg%3D%3D\u0026amp;_gl=1*17bo42l*_ga*MTY3MzQ3NTE2Ni4xNzEzNzcyOTg0*_ga_15W4STQT4T*MTcxMzc3Mjk4My4xLjEuMTcxMzc3Mjk5MC41My4wLjA.\"\u003eBourns MOV-10D470KKTR\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"gdt\"\u003eGDT\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLinh kiện \u003ca href=\"https://www.mouser.vn/ProductDetail/Bourns/GDT25-47-S1-RP?qs=2MMvu9PpTS3BszAgeO7ppQ%3D%3D\"\u003eBourns GDT25-47-S1-RP\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/ESD_Electronics.png\"\n  alt=\"ESD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/esd/",
      "date_published": "25056-25-09T559:2525:00+07:00",
      "date_modified": "25056-25-09T559:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "fd7800093460ca577e6a1fdff2b8aa97568c6540",
      "title": "DFLab_VNCERT",
      "summary": "",
      "content_text": "Bài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC)) Bài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích log. Trong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân: Hayabusa Hayabusa là một công cụ xử lý nhanh Windows Event Log, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v\u0026hellip;\nGoAccess GoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.\nGet Started GoAccess\nHow to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04\n",
      "content_html": "\u003ch2 id=\"bài-viết---công-cụ-điều-tra-nhật-ký-sự-kiện-của-digital-forensics-lab---cục-an-toàn-thông-tin-vncertcchttpsdfirlabvndocstoolslog\"\u003e\u003ca href=\"https://df.irlab.vn/docs/tools/log/\"\u003eBài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC))\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eBài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích \u003cstrong\u003elog\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTrong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hayabusahttpsgithubcomyamato-securityhayabusa\"\u003e\u003ca href=\"https://github.com/Yamato-Security/hayabusa\"\u003eHayabusa\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHayabusa là một công cụ xử lý nhanh \u003cstrong\u003eWindows Event Log\u003c/strong\u003e, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v\u0026hellip;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"goaccesshttpsgithubcomallinurlgoaccess\"\u003e\u003ca href=\"https://github.com/allinurl/goaccess\"\u003eGoAccess\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://goaccess.io/get-started\"\u003eGet Started GoAccess\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=PbKpdHeuG2A\"\u003eHow to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/dflab_vncert/",
      "date_published": "25056-25-09T556:2525:00+07:00",
      "date_modified": "25056-25-09T556:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8ab10c1348d533258955d2c165104e8fc6b6fb36",
      "title": "Firewall_CheckList",
      "summary": "",
      "content_text": "Có thể coi Firewall Checklist là phương pháp để mình Pentest Network Dùng các công cụ để test hạ tầng Network: Nmap Ettercap Firewalk Wireshark Check version của Firewall + CVE, tìm các cách khắc phục. Dựa vào file Firewall_Checklist để áp dụng cách đặt rule. Documents Firewall_Checklist ",
      "content_html": "\u003ch3 id=\"có-thể-coi-firewall-checklist-là-phương-pháp-để-mình-pentest-network\"\u003eCó thể coi \u003ccode\u003eFirewall Checklist\u003c/code\u003e là phương pháp để mình Pentest Network\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng các công cụ để test hạ tầng Network:\n\u003cul\u003e\n\u003cli\u003eNmap\u003c/li\u003e\n\u003cli\u003eEttercap\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kali.org/tools/firewalk/\"\u003eFirewalk\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eWireshark\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCheck version của Firewall + CVE, tìm các cách khắc phục.\u003c/li\u003e\n\u003cli\u003eDựa vào file \u003cstrong\u003eFirewall_Checklist\u003c/strong\u003e để áp dụng cách đặt rule.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"documents-firewall_checklistdocsfirewallchecklistpdf\"\u003e\u003ca href=\"/docs/FirewallChecklist.pdf\"\u003eDocuments Firewall_Checklist\u003c/a\u003e\u003c/h3\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Firewall_Cheatsheet.jpg\"\n  alt=\"Firewall Checklist\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/firewall_checklist/",
      "date_published": "25056-25-09T548:2525:00+07:00",
      "date_modified": "25056-25-09T548:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a8e9a70dc4d226a2d6960103dadfbaf851de55b7",
      "title": "NIS2",
      "summary": "",
      "content_text": "Bài viết: Tuân thủ NIS2 cho các mạng công nghiệp NIS2 Compliance for Industries White Paper Tổng hợp các thông tin cần biết trong bài viết: Các phần tử kết nối mạng OT cần được chứng nhận an toàn:\nCác tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì. Vì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên. Đánh giá và xếp loại ưu tiên các rủi ro mạng OT:\nNhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ. NIS2 yêu cầu bạn có khả năng \u0026ldquo;nhìn xuyên thấu\u0026rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh. Triển khai Zero-trust:\nHầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2. Lưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn. ISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có. Đây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng. Triển khai Zero-trust remote access:\nThay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop\u0026hellip;) Hãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập. Phát hiện và báo cáo sự cố: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.\n",
      "content_html": "\u003ch2 id=\"bài-viết-tuân-thủ-nis2-cho-các-mạng-công-nghiệphttpswhitehatvnthreadstuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua17872\"\u003e\u003ca href=\"https://whitehat.vn/threads/tuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua.17872/\"\u003eBài viết: Tuân thủ NIS2 cho các mạng công nghiệp\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"nis2-compliance-for-industries-white-paperhttpswwwciscocomcenusproductscollateralsecurityindustrial-securitynetwork-info-security-wppdf\"\u003e\u003ca href=\"https://www.cisco.com/c/en/us/products/collateral/security/industrial-security/network-info-security-wp.pdf\"\u003eNIS2 Compliance for Industries White Paper\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-thông-tin-cần-biết-trong-bài-viết\"\u003eTổng hợp các thông tin cần biết trong bài viết:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCác phần tử kết nối mạng OT cần được chứng nhận an toàn\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCác tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì.\u003c/li\u003e\n\u003cli\u003eVì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eĐánh giá và xếp loại ưu tiên các rủi ro mạng OT\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ.\u003c/li\u003e\n\u003cli\u003eNIS2 yêu cầu bạn có khả năng \u0026ldquo;nhìn xuyên thấu\u0026rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTriển khai Zero-trust\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2.\u003c/li\u003e\n\u003cli\u003eLưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn.\u003c/li\u003e\n\u003cli\u003eISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có.\u003c/li\u003e\n\u003cli\u003eĐây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTriển khai Zero-trust remote access\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop\u0026hellip;)\u003c/li\u003e\n\u003cli\u003eHãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePhát hiện và báo cáo sự cố\u003c/strong\u003e: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OT.jfif\"\n  alt=\"OT\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/nis2/",
      "date_published": "25056-25-09T543:2525:00+07:00",
      "date_modified": "25056-25-09T543:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4cce4220308fd2f1f01e3e19db45c5f96e482829",
      "title": "Raspberry OpenAuto",
      "summary": "",
      "content_text": "OpenAuto Link\nSource\nTheo như mình hiểu thì OpenAuto, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.\nHình như CrankShaft cũng từ open source của OpenAuto mà ra.\nTham khảo\nVideo tham khảo https://www.youtube.com/watch?v=RgbHXTHUnQw https://www.youtube.com/watch?v=ko-udLtaPk8 ",
      "content_html": "\u003ch3 id=\"openauto\"\u003eOpenAuto\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://bluewavestudio.io/#features\"\u003eLink\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"9https://bluewavestudio.io/community/showthread.php?tid=2774\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTheo như mình hiểu thì \u003cstrong\u003eOpenAuto\u003c/strong\u003e, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHình như \u003cstrong\u003eCrankShaft\u003c/strong\u003e cũng từ open source của \u003cstrong\u003eOpenAuto\u003c/strong\u003e mà ra.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/f1xpl/openauto/wiki\"\u003eTham khảo\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"video-tham-khao\"\u003eVideo tham khảo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=RgbHXTHUnQw\"\u003ehttps://www.youtube.com/watch?v=RgbHXTHUnQw\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=ko-udLtaPk8\"\u003ehttps://www.youtube.com/watch?v=ko-udLtaPk8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/raspberry-openauto/",
      "date_published": "1046-01-09T457:11:00+07:00",
      "date_modified": "1046-01-09T457:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "0bf57abd5b47956c7b4a48e0064a549fbeba3877",
      "title": "Pi400 Keyboard",
      "summary": "",
      "content_text": "Sử dụng Raspberry Pi400 như một bàn phím thông thường. https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/ https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard https://github.com/Gadgetoid/pi400kb/tree/main ",
      "content_html": "\u003ch3 id=\"sử-dụng-raspberry-pi400-như-một-bàn-phím-thông-thường\"\u003eSử dụng Raspberry Pi400 như một bàn phím thông thường.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/\"\u003ehttps://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard\"\u003ehttps://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Gadgetoid/pi400kb/tree/main\"\u003ehttps://github.com/Gadgetoid/pi400kb/tree/main\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.cytron.io/image/landing/RPI%20400/photo_2020-10-31_11-28-37.jpg\"\n  alt=\"Pi400\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/pi400-keyboard/",
      "date_published": "1046-01-09T453:11:00+07:00",
      "date_modified": "1046-01-09T453:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1467c592c4f59f946735e658ee5827f9a222c791",
      "title": "PiKVM",
      "summary": "",
      "content_text": "PiKVM Theo tài liệu thì KVM (Keyboard-Video-Mouse), tức là PiKVM là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP. Tức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần: Màn hình để xuất hình ảnh. Chuột và bàn phím để điều khiển. Với PiKVM nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua WebUI. PiKVM lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa. Thông thường nếu chỉ dùng Anydesk, TeamViewer,\u0026hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất. Vậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của PiKVM. Tham khảo video https://www.youtube.com/watch?v=2HqbQdZUEmY https://www.youtube.com/watch?v=PppcpSVYh0E https://www.youtube.com/watch?v=KrpHCsK7veA Documents https://docs.pikvm.org/ https://pikvm.org/ https://wiki.geekworm.com/PiKVM Note PiKVM có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image. Cần thêm module covert từ HDMI - CSI ",
      "content_html": "\u003ch3 id=\"pikvmhttpsgithubcompikvmpikvm\"\u003e\u003ca href=\"https://github.com/pikvm/pikvm\"\u003ePiKVM\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo tài liệu thì \u003cstrong\u003eKVM (Keyboard-Video-Mouse)\u003c/strong\u003e, tức là \u003cstrong\u003ePiKVM\u003c/strong\u003e là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP.\u003c/li\u003e\n\u003cli\u003eTức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần:\n\u003cul\u003e\n\u003cli\u003eMàn hình để xuất hình ảnh.\u003c/li\u003e\n\u003cli\u003eChuột và bàn phím để điều khiển.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eVới \u003cstrong\u003ePiKVM\u003c/strong\u003e nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua \u003cstrong\u003eWebUI\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePiKVM\u003c/strong\u003e lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa.\u003c/li\u003e\n\u003cli\u003eThông thường nếu chỉ dùng Anydesk, TeamViewer,\u0026hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất.\u003c/li\u003e\n\u003cli\u003eVậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của \u003cstrong\u003ePiKVM\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tham-khảo-video\"\u003eTham khảo video\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=2HqbQdZUEmY\"\u003ehttps://www.youtube.com/watch?v=2HqbQdZUEmY\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=PppcpSVYh0E\"\u003ehttps://www.youtube.com/watch?v=PppcpSVYh0E\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=KrpHCsK7veA\"\u003ehttps://www.youtube.com/watch?v=KrpHCsK7veA\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"documents\"\u003eDocuments\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.pikvm.org/\"\u003ehttps://docs.pikvm.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pikvm.org/\"\u003ehttps://pikvm.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://wiki.geekworm.com/PiKVM\"\u003ehttps://wiki.geekworm.com/PiKVM\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePiKVM\u003c/strong\u003e có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.waveshare.com/wiki/HDMI_to_CSI_Adapter\"\u003eCần thêm module covert từ HDMI - CSI\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/pikvm/",
      "date_published": "1046-01-09T449:11:00+07:00",
      "date_modified": "1046-01-09T449:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "571f7a701d03049f4c4b93851c869e0c14023691",
      "title": "UNIHIKER",
      "summary": "",
      "content_text": "Documents Getting Started with UNIHIKER Dfrobot Sản phẩm ",
      "content_html": "\u003ch3 id=\"documents\"\u003eDocuments\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.unihiker.com/wiki/get-started\"\u003eGetting Started with UNIHIKER\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.dfrobot.com/product-2691.html\"\u003eDfrobot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sản-phẩmhttpswwwproevnunihiker-iot-python-programming-single-board-computer-with-touchscreen\"\u003e\u003ca href=\"https://www.proe.vn/unihiker-iot-python-programming-single-board-computer-with-touchscreen\"\u003eSản phẩm\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://cdn.mos.cms.futurecdn.net/KRLwXFfy86ybfwUdzxmaFm-1200-80.jpg\"\n  alt=\"SP\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/unihiker/",
      "date_published": "1046-01-09T434:11:00+07:00",
      "date_modified": "1046-01-09T434:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    }
    
  ]
}