{
  "version": "https://jsonfeed.org/version/1",
  "title": "VinhLin",
  "home_page_url": "https://vinhlin.github.io/",
  "feed_url": "https://vinhlin.github.io/feed.json",
  "description": "Technology Blog",
  "favicon": "https://vinhlin.github.io//assets/favicon.ico",
  "expired": false,
  "author": {
    "name": "VinhLD",
    "url": "https://vinhlin.github.io/"
  },
  "items": [
    
    

    
    {
      "id": "afef4961bf5cabcf54173cd8303e7abbfd2bf1ec",
      "title": "NFC_PWA",
      "summary": "",
      "content_text": "Một số bài viết về việc sử dụng Web PWA để đánh cắp thông tin: https://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa https://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/ https://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info Github project: nfcgate https://github.com/nfcgate/nfcgate/tree/v2/doc https://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md https://github.com/nfcgate/nfcgate/tree/v2/doc/mode Ghi chú theo cách hiểu của bản thân Lúc trước mình có tìm hiểu qua về Web PWA (lúc đó có nghiên cứu về bluetooth trên di động). Với các ứng dụng web PWA thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động. Đầu tiên đầu tiên là dẫn dụ (có thể qua phishing) cài đặt một ứng dụng (có chứa malware) bằng đường link Web PWA. Dùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native. Lúc này hacker dùng nfcgate để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch. Khi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân. Như trong Video Youtube ",
      "content_html": "\u003ch3 id=\"một-số-bài-viết-về-việc-sử-dụng-web-pwa-để-đánh-cắp-thông-tin\"\u003eMột số bài viết về việc sử dụng Web PWA để đánh cắp thông tin:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa\nhttps://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/\nhttps://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"github-project-nfcgatehttpsgithubcomnfcgatenfcgate\"\u003eGithub project: \u003ca href=\"https://github.com/nfcgate/nfcgate\"\u003enfcgate\u003c/a\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/nfcgate/nfcgate/tree/v2/doc\nhttps://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md\nhttps://github.com/nfcgate/nfcgate/tree/v2/doc/mode\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"ghi-chú-theo-cách-hiểu-của-bản-thân\"\u003eGhi chú theo cách hiểu của bản thân\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước mình có tìm hiểu qua về \u003cstrong\u003eWeb PWA\u003c/strong\u003e (lúc đó có nghiên cứu về \u003cem\u003ebluetooth\u003c/em\u003e trên di động).\u003c/li\u003e\n\u003cli\u003eVới các ứng dụng web \u003ccode\u003ePWA\u003c/code\u003e thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/NFC_PWA/entire-process.webp\"\n  alt=\"entire-process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐầu tiên đầu tiên là dẫn dụ \u003cem\u003e(có thể qua phishing)\u003c/em\u003e cài đặt một ứng dụng (có chứa malware) bằng đường link \u003cstrong\u003eWeb PWA\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native.\u003c/li\u003e\n\u003cli\u003eLúc này hacker dùng \u003cstrong\u003enfcgate\u003c/strong\u003e để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/NFC_PWA/nfc-replay.webp\"\n  alt=\"nfc-replay\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân.\u003c/li\u003e\n\u003cli\u003eNhư trong \u003ca href=\"https://youtu.be/q69--5rdlmI\"\u003eVideo Youtube\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/nfc_pwa/",
      "date_published": "27086-27-09T847:2727:00+07:00",
      "date_modified": "27086-27-09T847:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8952986493d99062e799e181787175b42c8ffafe",
      "title": "Kien_truc_may_tinh",
      "summary": "",
      "content_text": "Kiển trúc Máy tính Kiến trúc máy tính - Von-Neumann Được chia làm 3 phần chính: CPU Memory IO Cả 3 thành phần này đều giao tiếp với nhau thông qua bus (gọi là data bus) kiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing) Sự khác biệt giữa kiến trúc Harvard vs Von-Neumann đó chính là sự bố trí giữa CPU - Memory.\nKiến trúc chip x86 Architecture Thường thấy trong các sản phẩm máy tính desktop hoặc laptop. Phổ biến là dòng chip của Intel. RISC Architectures MIPS Architecture: KIẾN TRÚC BỘ LỆNH ARM Architecture: Tài liệu ARMarch Một bài viết so sánh giữa ARM vs x86 Data Bus Có 2 kiểu truyền dữ liệu là:\nNối tiếp (Serial) Song song (Parallel) Song song Dùng cho display (truyền hình ảnh), PCI, printer,\u0026hellip; Nối tiếp: Dùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,\u0026hellip; Giao tiếp nối tiếp thì chia làm 2 loại là: Giao tiếp bất đồng bộ: UART, RS232, RS485 Giao tiếp đồng bộ: SPI ",
      "content_html": "\u003ch2 id=\"kiển-trúc-máy-tính\"\u003eKiển trúc Máy tính\u003c/h2\u003e\n\u003ch3 id=\"kiến-trúc-máy-tính---von-neumannhttpswwwdigikeycomenmakerblogs2024von-neumann-architecture\"\u003e\u003ca href=\"https://www.digikey.com/en/maker/blogs/2024/von-neumann-architecture\"\u003eKiến trúc máy tính - Von-Neumann\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐược chia làm 3 phần chính:\n\u003cul\u003e\n\u003cli\u003eCPU\u003c/li\u003e\n\u003cli\u003eMemory\u003c/li\u003e\n\u003cli\u003eIO\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCả 3 thành phần này đều giao tiếp với nhau thông qua \u003cstrong\u003ebus\u003c/strong\u003e (gọi là \u003ccode\u003edata bus\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kiến-trúc-harvard-sử-dụng-rộng-rãi-trong-các-bộ-vi-điều-khiển-và-dsp-digital-signal-processing\"\u003ekiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing)\u003c/h3\u003e\n\u003cp\u003eSự khác biệt giữa kiến trúc \u003cstrong\u003eHarvard\u003c/strong\u003e vs \u003cstrong\u003eVon-Neumann\u003c/strong\u003e đó chính là sự bố trí giữa \u003cstrong\u003eCPU - Memory\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"kiến-trúc-chiphttpsinc42comglossarychip-architecture\"\u003e\u003ca href=\"https://inc42.com/glossary/chip-architecture/\"\u003eKiến trúc chip\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"x86-architecture\"\u003ex86 Architecture\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThường thấy trong các sản phẩm máy tính desktop hoặc laptop.\u003c/li\u003e\n\u003cli\u003ePhổ biến là dòng chip của \u003cstrong\u003eIntel\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"risc-architectures\"\u003eRISC Architectures\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMIPS Architecture: \u003ca href=\"https://www.cit.ctu.edu.vn/~dtnghi/cod/ch3.pdf\"\u003eKIẾN TRÚC BỘ LỆNH\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eARM Architecture:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.csie.ntu.edu.tw/~cyy/courses/assembly/12fall/lectures/handouts/lec08_ARMarch.pdf\"\u003eTài liệu ARMarch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.candtsolution.com/news_events-detail/what-is-the-difference-between-arm-and-x86/\"\u003eMột bài viết so sánh giữa ARM vs x86\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"data-bushttpswwwdigikeycomenmakertutorials2023what-is-serial-communication-and-how-does-it-compare-to-paralleltextwhats20the20difference20between20serialdata20that20can20be20transferred\"\u003e\u003ca href=\"https://www.digikey.com/en/maker/tutorials/2023/what-is-serial-communication-and-how-does-it-compare-to-parallel#:~:text=What's%20the%20Difference%20Between%20Serial,data%20that%20can%20be%20transferred\"\u003eData Bus\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCó 2 kiểu truyền dữ liệu là:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eNối tiếp (Serial)\nSong song (Parallel)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Communicate.jpg\"\n  alt=\"Communicate\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"song-song\"\u003eSong song\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng cho display (truyền hình ảnh), PCI, printer,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nối-tiếp\"\u003eNối tiếp:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eGiao tiếp nối tiếp thì chia làm 2 loại là:\n\u003cul\u003e\n\u003cli\u003eGiao tiếp bất đồng bộ: UART, RS232, RS485\u003c/li\u003e\n\u003cli\u003eGiao tiếp đồng bộ: SPI\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/kien_truc_may_tinh/",
      "date_published": "27086-27-09T811:2727:00+07:00",
      "date_modified": "27086-27-09T811:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "377c454df8e403d4adbd6e21b260c4d8c1a7686c",
      "title": "Radxa_X4",
      "summary": "",
      "content_text": "Thông tin: https://www.youtube.com/watch?v=F2atAHDOaIA https://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040 https://github.com/geerlingguy/sbc-reviews/issues/48 https://radxa.com/products/x/x4/ Giải thích theo cách hiểu cá nhân: Cụm từ x86 with a side of Arm trong trường hợp của Radxa X4 SBC (Single Board Computer) mô tả việc tích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.\nĐiều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.\nGiải thích cụ thể:\nIntel N100 và Kiến trúc x86: Intel N100 đây là một bộ vi xử lý x86 của Intel, thuộc dòng Alder Lake-N, sử dụng kiến trúc x86-64. X86 được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó. Ứng dụng: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ. Raspberry Pi RP2040 và Kiến trúc ARM: RP2040: Đây là một bộ vi điều khiển dựa trên kiến trúc ARM Cortex-M0+ do Raspberry Pi Foundation phát triển. Đây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực. Ứng dụng: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng. Tại sao sử dụng cả x86 và ARM trên cùng một bo mạch? Sử dụng tối ưu tài nguyên: x86: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. ARM: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. Tăng tính linh hoạt và hiệu suất:\nSự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính Đồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn. Điều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng. Tính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.\nKết luận: Radxa X4 SBC mô tả việc kết hợp cả hai kiến trúc trong một thiết bị Sử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực. Đây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống. ",
      "content_html": "\u003ch3 id=\"thông-tin\"\u003eThông tin:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=F2atAHDOaIA\nhttps://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040\nhttps://github.com/geerlingguy/sbc-reviews/issues/48\nhttps://radxa.com/products/x/x4/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://radxa.com/x/x4/banner_radxa_x4.webp\"\n  alt=\"radxa_x4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch1 id=\"giải-thích-theo-cách-hiểu-cá-nhân\"\u003eGiải thích theo cách hiểu cá nhân:\u003c/h1\u003e\n\u003cp\u003eCụm từ \u003cstrong\u003ex86 with a side of Arm\u003c/strong\u003e trong trường hợp của \u003ccode\u003eRadxa X4 SBC (Single Board Computer)\u003c/code\u003e mô tả việc \u003cstrong\u003etích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch\u003c/strong\u003e, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.\u003c/p\u003e\n\u003cp\u003eĐiều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.\u003c/p\u003e\n\u003cp\u003eGiải thích cụ thể:\u003c/p\u003e\n\u003ch3 id=\"intel-n100-và-kiến-trúc-x86\"\u003eIntel N100 và Kiến trúc x86:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eIntel N100\u003c/strong\u003e đây là một bộ \u003cstrong\u003evi xử lý x86\u003c/strong\u003e của Intel, thuộc dòng Alder Lake-N, sử dụng \u003ccode\u003ekiến trúc x86-64\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eX86\u003c/strong\u003e được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó.\u003c/li\u003e\n\u003cli\u003e\u003cmark\u003eỨng dụng\u003c/mark\u003e: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raspberry-pi-rp2040-và-kiến-trúc-arm\"\u003eRaspberry Pi RP2040 và Kiến trúc ARM:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRP2040\u003c/strong\u003e: Đây là một bộ \u003cstrong\u003evi điều khiển\u003c/strong\u003e dựa trên \u003ccode\u003ekiến trúc ARM Cortex-M0+\u003c/code\u003e do Raspberry Pi Foundation phát triển.\u003c/li\u003e\n\u003cli\u003eĐây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực.\u003c/li\u003e\n\u003cli\u003e\u003cmark\u003eỨng dụng\u003c/mark\u003e: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tại-sao-sử-dụng-cả-x86-và-arm-trên-cùng-một-bo-mạch\"\u003eTại sao sử dụng cả x86 và ARM trên cùng một bo mạch?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSử dụng tối ưu tài nguyên:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ex86\u003c/strong\u003e: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. \u003cbr\u003e\n\u003cstrong\u003eARM\u003c/strong\u003e: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. \u003cbr\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTăng tính linh hoạt và hiệu suất:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính\u003c/li\u003e\n\u003cli\u003eĐồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn.\u003c/li\u003e\n\u003cli\u003eĐiều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kết-luận\"\u003eKết luận:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRadxa X4 SBC mô tả việc \u003cstrong\u003ekết hợp cả hai kiến trúc trong một thiết bị\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eSử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực.\u003c/li\u003e\n\u003cli\u003eĐây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/radxa_x4/",
      "date_published": "27086-27-09T839:2727:00+07:00",
      "date_modified": "27086-27-09T839:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "34c808d0a63f277e04fb23a5f76cc83d0a3e024b",
      "title": "News",
      "summary": "",
      "content_text": "Changelog Ngày Mô tả 10/4/2024 Khởi tạo bài viết 26/8/2024 Cập nhật một số trang blog và youtube về chủ đề Hardware Hacking Đây là danh sách các kênh mà mình cập nhật tin tức. Cũng như bổ sung kiến thức. Danh sách các kênh tài liệu và Youtube để cập nhật kiến thức. Các trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm: NCSC VN Whitehat Còn trang của nước ngoài thì gồm (trong đó có telegram): Cyber Security News Telegram: Cyber Threat Intelligence Kênh youtube: Mình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới. Các kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System. Ngày 26/8/2024 Một số trang blog và kênh Youtube về Hardware Hacking\nNCC Group Matt Brown: IoT Pentester \u0026amp; Hardware Security Researcher Blog Youtube Channel: Matt Brown hextree.io: Một nền tảng học tập về hacking. Youtube Channel: LiveOverflow IoT Pentesting Guide IoTSecurity101 GameHacking.GG Trò chơi để luyện tập về reverse và hacking game. Github Hướng dẫn synacktiv Publications Advisories Resources ",
      "content_html": "\u003ch3 id=\"changelog\"\u003eChangelog\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e10/4/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e26/8/2024\u003c/td\u003e\n\u003ctd\u003eCập nhật một số trang blog và youtube về chủ đề Hardware Hacking\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là danh sách các kênh mà mình cập nhật tin tức.\u003c/li\u003e\n\u003cli\u003eCũng như bổ sung kiến thức.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"danh-sách-các-kênh-tài-liệu-và-youtube-để-cập-nhật-kiến-thức\"\u003eDanh sách các kênh tài liệu và Youtube để cập nhật kiến thức.\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ncsc-vnhttpstinnhiemmangvnnoi-bat\"\u003e\u003ca href=\"https://tinnhiemmang.vn/noi-bat\"\u003eNCSC VN\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"whitehathttpswhitehatvn\"\u003e\u003ca href=\"https://whitehat.vn/\"\u003eWhitehat\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCòn trang của nước ngoài thì gồm (trong đó có telegram):\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"cyber-security-newshttpscybersecuritynewscom\"\u003e\u003ca href=\"https://cybersecuritynews.com/\"\u003eCyber Security News\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"telegram-cyber-threat-intelligencehttpstmectinow\"\u003e\u003ca href=\"https://t.me/ctinow\"\u003eTelegram: Cyber Threat Intelligence\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"kênh-youtube\"\u003eKênh youtube:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới.\u003c/li\u003e\n\u003cli\u003eCác kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Top_Youtube_Channel_Hacking.jpg\"\n  alt=\"Youtube\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"ngày-2682024\"\u003eNgày 26/8/2024\u003c/h2\u003e\n\u003cp\u003eMột số trang blog và kênh Youtube về Hardware Hacking\u003c/p\u003e\n\u003ch3 id=\"ncc-grouphttpsresearchnccgroupcomcategoryhardware-embedded-systems\"\u003e\u003ca href=\"https://research.nccgroup.com/category/hardware-embedded-systems/\"\u003eNCC Group\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"matt-brown-iot-pentester--hardware-security-researcher\"\u003eMatt Brown: IoT Pentester \u0026amp; Hardware Security Researcher\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://brownfinesecurity.com/blog/\"\u003eBlog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eYoutube Channel: \u003ca href=\"https://www.youtube.com/@mattbrwn\"\u003eMatt Brown\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hextreeiohttpsapphextreeio-một-nền-tảng-học-tập-về-hacking\"\u003e\u003ca href=\"https://app.hextree.io/\"\u003ehextree.io\u003c/a\u003e: Một nền tảng học tập về hacking.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eYoutube Channel: \u003ca href=\"https://www.youtube.com/@LiveOverflow\"\u003eLiveOverflow\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"iot-pentesting-guidehttpswwwiotpentestingguidecom\"\u003e\u003ca href=\"https://www.iotpentestingguide.com/\"\u003eIoT Pentesting Guide\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"iotsecurity101httpsv33rugithubioiotsecurity101\"\u003e\u003ca href=\"https://v33ru.github.io/IoTSecurity101/\"\u003eIoTSecurity101\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"gamehackinggghttpsgamehackinggg\"\u003e\u003ca href=\"https://gamehacking.gg/\"\u003eGameHacking.GG\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrò chơi để luyện tập về \u003cstrong\u003ereverse\u003c/strong\u003e và hacking game.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jhllc/Unity-Game\"\u003eGithub Hướng dẫn\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"synacktivhttpswwwsynacktivcomenour-publications\"\u003e\u003ca href=\"https://www.synacktiv.com/en/our-publications\"\u003esynacktiv\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/publications\"\u003ePublications\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/advisories\"\u003eAdvisories\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/ressources\"\u003eResources\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/news/",
      "date_published": "26086-26-09T827:2626:00+07:00",
      "date_modified": "26086-26-09T827:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "261aa46d7ac1d848e6c22e49147fd08d6ad6071f",
      "title": "Protect_Camera",
      "summary": "",
      "content_text": "Lướt lát trên Internet, vô tình lụm được các bức ảnh (được cắt ra trên một seminar nào đó) nói về các cách bảo vệ Camera.\nSau khi đọc xong thì mình thấy các nội dung trong đây không chỉ dành riêng cho camera, mà có thể áp dụng tư duy và kỹ thuật này cả vào red-team và blue-team.\nKỹ thuật cho Red-Team Phishing Attacks Đây là kỹ thuật rất phổ biến và hay được dùng. Đính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web fake. Để rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này. Sử dụng phần mềm độc hại Hacker tạo ra các con malware, sau đó nhúng nó vào các file như file ảnh, pdf,\u0026hellip; Khi nạn nhân nhấp vào thì sẽ có các tiến trình chạy ẩn bên trong máy. Ví dụ như tạo ra backdoor kết nối về máy chủ C2 của hacker. Câu hỏi là làm sao dẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm Để làm được điều này thì một trong những kỹ thuật cần dùng là Phishing Attacks.\nKhai thác lỗ hổng phần mềm Phần mềm ở đây mang nghĩa cũng hơi rộng. Có thể là web, moblie hoặc một ứng dụng desktop. Chỉ cần phần mềm đó có lỗ hổng và mình khai thác (ví dụ như Reverse Shell hoặc RAT) được thì cũng làm được khá nhiều trò. Fake WIFI Cách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker. Hacker sẽ fake một free wifi, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet. Hoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,\u0026hellip; Tư duy Blue-Team Sử dụng Password mạnh mẽ Ít nhất 8 ký tự, có cả số lẫn chữ. Trong có phải bao gồm ít nhất phải có một ký tự đặc biệt, và một ký tự chữ in hoa. Sử dụng 2FA Xác thực OTP (One Time Password). Có thể dùng app GG Authen để xác thực 2 bước. Phân quyền Cận thận với những app cài đặt với quyền Admin. Phân quyền lại cho user, được phép và không được phép làm điều gì. Kiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng không thể leo thang đặc quyền được. Bảo vệ vật lý Hiểu nôm na là sử dụng công cụ vật lý để xác thực. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng. Ví dụ như sản phẩm FIDO2® Touch 1 của công ty VinCSS Công cụ khác Hãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng. Sử dụng Firewall (cả phần cứng và phần mềm) để bảo vệ hạ tầng và ứng dụng của bạn. Sử dụng VPN để bảo vệ thông tin của bạn. Sử dụng các công cụ diệt virus để bảo vệ máy tính của bạn. Và đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack (vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu). Human - Con người Dù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là con người Lỗ hổng này nằm trong tư duy, nhận thức về An toàn và Bảo mật thông tin. ",
      "content_html": "\u003cp\u003eLướt lát trên Internet, vô tình \u003cstrong\u003elụm\u003c/strong\u003e được các bức ảnh \u003cem\u003e(được cắt ra trên một seminar nào đó)\u003c/em\u003e nói về các cách bảo vệ Camera.\u003c/p\u003e\n\u003cp\u003eSau khi đọc xong thì mình thấy các nội dung trong đây \u003cstrong\u003ekhông chỉ dành riêng cho camera\u003c/strong\u003e, mà có thể áp dụng \u003cstrong\u003etư duy và kỹ thuật\u003c/strong\u003e này cả vào red-team và blue-team.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/1.jpg\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"kỹ-thuật-cho-red-team\"\u003eKỹ thuật cho Red-Team\u003c/h2\u003e\n\u003ch3 id=\"phishing-attacks\"\u003ePhishing Attacks\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/2.jpg\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là kỹ thuật rất phổ biến và hay được dùng.\u003c/li\u003e\n\u003cli\u003eĐính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web \u003cstrong\u003efake\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐể rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-phần-mềm-độc-hại\"\u003eSử dụng phần mềm độc hại\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/3.jpg\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHacker tạo ra các con \u003cstrong\u003emalware\u003c/strong\u003e, sau đó \u003cstrong\u003enhúng\u003c/strong\u003e nó vào các file như file ảnh, pdf,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eKhi nạn nhân nhấp vào thì sẽ có các \u003cstrong\u003etiến trình chạy ẩn\u003c/strong\u003e bên trong máy.\u003c/li\u003e\n\u003cli\u003eVí dụ như tạo ra \u003cstrong\u003ebackdoor\u003c/strong\u003e kết nối về \u003cstrong\u003emáy chủ C2\u003c/strong\u003e của hacker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/4.jpg\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCâu hỏi là làm sao \u003cstrong\u003edẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm\u003c/strong\u003e \u003cbr\u003e\nĐể làm được điều này thì một trong những kỹ thuật cần dùng là \u003cmark\u003ePhishing Attacks\u003c/mark\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"khai-thác-lỗ-hổng-phần-mềm\"\u003eKhai thác lỗ hổng phần mềm\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/5.jpg\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePhần mềm\u003c/strong\u003e ở đây mang nghĩa cũng hơi rộng. Có thể là \u003ccode\u003eweb\u003c/code\u003e, \u003ccode\u003emoblie\u003c/code\u003e hoặc một ứng dụng \u003ccode\u003edesktop\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eChỉ cần phần mềm đó có \u003cstrong\u003elỗ hổng\u003c/strong\u003e và mình khai thác (ví dụ như \u003cmark\u003eReverse Shell\u003c/mark\u003e hoặc \u003cstrong\u003eRAT\u003c/strong\u003e) được thì cũng làm được khá nhiều trò.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"fake-wifi\"\u003eFake WIFI\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/6.jpg\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker.\u003c/li\u003e\n\u003cli\u003eHacker sẽ fake một \u003cstrong\u003efree wifi\u003c/strong\u003e, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet.\u003c/li\u003e\n\u003cli\u003eHoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tư-duy-blue-team\"\u003eTư duy Blue-Team\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/7.jpg\"\n  alt=\"Hinh_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"sử-dụng-password-mạnh-mẽ\"\u003eSử dụng Password mạnh mẽ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eÍt nhất \u003cstrong\u003e8 ký tự\u003c/strong\u003e, có cả số lẫn chữ.\u003c/li\u003e\n\u003cli\u003eTrong có phải bao gồm ít nhất phải có một \u003cstrong\u003eký tự đặc biệt\u003c/strong\u003e, và một ký tự \u003cstrong\u003echữ in hoa\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-2fa\"\u003eSử dụng 2FA\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXác thực \u003cstrong\u003eOTP\u003c/strong\u003e (One Time Password).\u003c/li\u003e\n\u003cli\u003eCó thể dùng app \u003cstrong\u003eGG Authen\u003c/strong\u003e để xác thực 2 bước.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"phân-quyền\"\u003ePhân quyền\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCận thận với những app cài đặt với quyền Admin\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003ePhân quyền lại cho \u003cstrong\u003euser\u003c/strong\u003e, được phép và không được phép làm điều gì.\u003c/li\u003e\n\u003cli\u003eKiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng \u003cstrong\u003ekhông thể leo thang đặc quyền\u003c/strong\u003e được.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bảo-vệ-vật-lý\"\u003eBảo vệ vật lý\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiểu nôm na là sử dụng \u003cstrong\u003ecông cụ vật lý để xác thực\u003c/strong\u003e. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng.\u003c/li\u003e\n\u003cli\u003eVí dụ như sản phẩm \u003ca href=\"https://vincss.net/vi/product/khoa-xac-thuc-manh-vincss-fido2-touch-1-ket-noi-usb-type-a-ho-tro-xac-thuc-an-toan-khong-mat-khau-chuan-uaf-u2f-fido2-hang-chinh-hang/\"\u003eFIDO2® Touch 1\u003c/a\u003e của công ty \u003cstrong\u003eVinCSS\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-khác\"\u003eCông cụ khác\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/10.jpg\"\n  alt=\"Hinh_10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003cstrong\u003eFirewall\u003c/strong\u003e \u003cem\u003e(cả phần cứng và phần mềm)\u003c/em\u003e để bảo vệ hạ tầng và ứng dụng của bạn.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003cstrong\u003eVPN\u003c/strong\u003e để bảo vệ thông tin của bạn.\u003c/li\u003e\n\u003cli\u003eSử dụng các công cụ \u003cstrong\u003ediệt virus\u003c/strong\u003e để bảo vệ máy tính của bạn.\u003c/li\u003e\n\u003cli\u003eVà đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack \u003cem\u003e(vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"human---con-người\"\u003eHuman - Con người\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là \u003cstrong\u003econ người\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eLỗ hổng này nằm trong \u003cstrong\u003etư duy\u003c/strong\u003e, \u003cstrong\u003enhận thức\u003c/strong\u003e về An toàn và Bảo mật thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/8.jpg\"\n  alt=\"Hinh_8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/protect_camera/",
      "date_published": "18086-18-09T87:1818:00+07:00",
      "date_modified": "18086-18-09T87:1818:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1d6e1d9d82c5e034cbee811a39d8ea0cdf4dfb8b",
      "title": "Rust Lang",
      "summary": "",
      "content_text": " Ngày Mô tả 1/4/2024 Khởi tạo bài viết 17/8/2024 Cập nhật bài viết, thêm thông tin về Rust-lang Hạn chế Năm 2023 xảy ra nhiều dramma của Rust Found Rust là ngôn ngữ khó học, code khó. 5 things I wish I knew before learning Rust Why do developers hate Rust? Cộng đồng DEV chưa quá đông như Golang. Top Programming Languages 2023 Lợi ích Rust là ngôn ngữ low level, được sử dụng cho nhiều mục đích khác nhau: Dùng để code nhúng. Dùng để code phía Server. Có thể dùng để code OS - như Rust for Linux Rust chú trọng vào sự an toàn - memory safety. Cộng đồng Rust vẫn đang phát triển. Dựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang Rust Roadmap Tài liệu về Rust Rust IDE - RustRover\nThe Embedded Rust Book\nStandard library developers Guide\nBlog Rust\nRust By Example\nRust Tiếng Việt\nYoutube - Crust of Rust\nYoutube - Let\u0026rsquo;s Get Rusty\nRust Cheatsheet\nWriting an OS in Rust\nCập nhật 17/8/2024 Youtube: Where is Rust being used? Tổng hợp Rust is for Robotics Project ros2_rust Project CleanIt Doc: Offline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard nostd-wifi-lamp esp32c3-no-std-async-mqtt-demo Framework cho MQTT cho Rust: rumqtt rust-mqtt Framework NATS for Rust: nats.rs Có thể sử dụng NATS cho ThingsBoard. Sample code từ ChatGPT: use nats::asynk::Connection; use serde::{Deserialize, Serialize}; use serde_json::json; use tokio::time::{sleep, Duration}; #[derive(Debug, Serialize, Deserialize)] struct TelemetryData { device_id: String, temperature: f64, humidity: f64, timestamp: u64, } #[tokio::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { // Connect to the NATS server let nc: Connection = nats::asynk::connect(\u0026#34;demo.nats.io\u0026#34;).await?; // Subscribe to a subject where ThingsBoard publishes telemetry data let subscription = nc.subscribe(\u0026#34;thingsboard.telemetry\u0026#34;).await?; // Process incoming messages while let Some(msg) = subscription.next().await { // Parse the telemetry data (assumed to be JSON) let telemetry: TelemetryData = serde_json::from_slice(\u0026amp;msg.data).expect(\u0026#34;Failed to parse telemetry data\u0026#34;); println!(\u0026#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}\u0026#34;, telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp); // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject let response_subject = format!(\u0026#34;thingsboard.ack.{}\u0026#34;, telemetry.device_id); let ack_message = json!({ \u0026#34;device_id\u0026#34;: telemetry.device_id, \u0026#34;status\u0026#34;: \u0026#34;acknowledged\u0026#34;, \u0026#34;timestamp\u0026#34;: telemetry.timestamp }); nc.publish(\u0026amp;response_subject, ack_message.to_string().as_bytes()).await?; } Ok(()) } ",
      "content_html": "\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust_Embedded.png\"\n  alt=\"Rust_Embedded\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1/4/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/8/2024\u003c/td\u003e\n\u003ctd\u003eCập nhật bài viết, thêm thông tin về Rust-lang\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"hạn-chế\"\u003eHạn chế\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://users.rust-lang.org/t/why-is-there-so-much-mismanagement-in-the-rust-foundation-and-core-team/94822\"\u003eNăm 2023 xảy ra nhiều dramma của Rust Found\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eRust là ngôn ngữ \u003cstrong\u003ekhó học, code khó\u003c/strong\u003e.\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=EYCBm0xAWow\u0026amp;list=LL\u0026amp;index=3\"\u003e5 things I wish I knew before learning Rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=fknamfNtKk0\"\u003eWhy do developers hate Rust?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCộng đồng \u003cstrong\u003eDEV\u003c/strong\u003e chưa quá đông như Golang. \u003ca href=\"https://spectrum.ieee.org/the-top-programming-languages-2023\"\u003eTop Programming Languages 2023\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"lợi-ích\"\u003eLợi ích\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRust là ngôn ngữ \u003cstrong\u003elow level\u003c/strong\u003e, được sử dụng cho nhiều mục đích khác nhau:\n\u003cul\u003e\n\u003cli\u003eDùng để code nhúng.\u003c/li\u003e\n\u003cli\u003eDùng để code phía Server.\u003c/li\u003e\n\u003cli\u003eCó thể dùng để code OS - như \u003ca href=\"https://rust-for-linux.com/\"\u003eRust for Linux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRust chú trọng vào sự an toàn - \u003cstrong\u003ememory safety\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCộng đồng Rust vẫn đang phát triển. \u003ca href=\"https://pypl.github.io/PYPL.html\"\u003eDựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"rust-roadmaphttpsroadmapshrust\"\u003e\u003ca href=\"https://roadmap.sh/rust\"\u003eRust Roadmap\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tài-liệu-về-rust\"\u003eTài liệu về Rust\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/help/rust/getting-started.html\"\u003eRust IDE - RustRover\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://docs.rust-embedded.org/book/\"\u003eThe Embedded Rust Book\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://std-dev-guide.rust-lang.org/\"\u003eStandard library developers Guide\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://blog.rust-lang.org/\"\u003eBlog Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/rust-by-example/index.html\"\u003eRust By Example\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://rust-tieng-viet.github.io/getting-started/first-project.html\"\u003eRust Tiếng Việt\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=rAl-9HwD858\u0026amp;list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa\u0026amp;index=3\"\u003eYoutube - Crust of Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/@letsgetrusty\"\u003eYoutube - Let\u0026rsquo;s Get Rusty\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://docs.google.com/document/d/1kQidzAlbqapu-WZTuw4Djik0uTqMZYyiMXTM9F21Dz4/edit?lid=75778#heading=h.gjdgxs\"\u003eRust Cheatsheet\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://os.phil-opp.com/\"\u003eWriting an OS in Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"cập-nhật-1782024\"\u003eCập nhật 17/8/2024\u003c/h1\u003e\n\u003ch3 id=\"youtube-where-is-rust-being-usedhttpswwwyoutubecomwatchv42fhqwq6sva\"\u003eYoutube: \u003ca href=\"https://www.youtube.com/watch?v=42FhQWQ6SVA\"\u003eWhere is Rust being used?\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"tổng-hợp-rust-is-for-roboticshttpsroboticsrs\"\u003eTổng hợp \u003ca href=\"https://robotics.rs/\"\u003eRust is for Robotics\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProject \u003ca href=\"https://github.com/ros2-rust/ros2_rust\"\u003eros2_rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eProject \u003ca href=\"https://github.com/Sollimann/CleanIt\"\u003eCleanIt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"doc-offline-first-smart-energy-monitor-with-rust-esp32-and-thingsboardhttpsmoslehiancomposts20223-ofmon\"\u003eDoc: \u003ca href=\"https://moslehian.com/posts/2022/3-ofmon/\"\u003eOffline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Nereuxofficial/nostd-wifi-lamp\"\u003enostd-wifi-lamp\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/JurajSadel/esp32c3-no-std-async-mqtt-demo\"\u003eesp32c3-no-std-async-mqtt-demo\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"framework-cho-mqtt-cho-rust-rumqtthttpsgithubcombytebeamiorumqtt\"\u003eFramework cho MQTT cho Rust: \u003ca href=\"https://github.com/bytebeamio/rumqtt\"\u003erumqtt\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/obabec/rust-mqtt\"\u003erust-mqtt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"framework-nats-for-rust-natsrshttpsgithubcomnats-ionatsrs\"\u003eFramework NATS for Rust: \u003ca href=\"https://github.com/nats-io/nats.rs\"\u003enats.rs\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó thể sử dụng NATS cho ThingsBoard.\u003c/li\u003e\n\u003cli\u003eSample code từ ChatGPT:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse nats::asynk::Connection;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse tokio::time::{sleep, Duration};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct TelemetryData {\n    device_id: String,\n    temperature: f64,\n    humidity: f64,\n    timestamp: u64,\n}\n\n#[tokio::main]\nasync fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; {\n    // Connect to the NATS server\n    let nc: Connection = nats::asynk::connect(\u0026#34;demo.nats.io\u0026#34;).await?;\n\n    // Subscribe to a subject where ThingsBoard publishes telemetry data\n    let subscription = nc.subscribe(\u0026#34;thingsboard.telemetry\u0026#34;).await?;\n\n    // Process incoming messages\n    while let Some(msg) = subscription.next().await {\n        // Parse the telemetry data (assumed to be JSON)\n        let telemetry: TelemetryData = serde_json::from_slice(\u0026amp;msg.data).expect(\u0026#34;Failed to parse telemetry data\u0026#34;);\n\n        println!(\u0026#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}\u0026#34;,\n                 telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp);\n\n        // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject\n        let response_subject = format!(\u0026#34;thingsboard.ack.{}\u0026#34;, telemetry.device_id);\n        let ack_message = json!({\n            \u0026#34;device_id\u0026#34;: telemetry.device_id,\n            \u0026#34;status\u0026#34;: \u0026#34;acknowledged\u0026#34;,\n            \u0026#34;timestamp\u0026#34;: telemetry.timestamp\n        });\n\n        nc.publish(\u0026amp;response_subject, ack_message.to_string().as_bytes()).await?;\n    }\n\n    Ok(())\n}\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/software/rust-lang/",
      "date_published": "17086-17-09T814:1717:00+07:00",
      "date_modified": "17086-17-09T814:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "20ccc7228320b7e728440959d1e27bbe5951a067",
      "title": "RE_Tool_BinaryNinjaFree",
      "summary": "",
      "content_text": "Một bài viết về RE (Reverse Engineering)\nCông cụ IDA - The Interactive Disassembler Công cụ này có bản free và hỗ trợ cài đặt trên nhiều nền tảng. Mình tải và cài đặt bản free cho Windows. Tuy nhiên thì: Với bản free thì mình chỉ có thể dùng cho các file PE format. Là dạng các file .exe trên windows. Với bản free thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng. Công cụ Online - Decompiler Explorer Phần mềm Binary Ninja Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.\nVideo youtube tham khảo: How to Crack Software (Reverse Engineering) Learning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting An Intro to Binary Ninja (Free) for Malware Analysis Binary Ninja: 4.1 Feature Stream! Community provided Binary Ninja plugins: community-plugins Download Free Đây là một công cụ mạnh mẽ, nhưng được sử dụng free. Nếu so sánh thì phần mềm này ăn đứt IDA về tính năng của bản free: Supports x86, x86_64, and ARMv7 architectures. Hỗ trợ Disassemble (phân tích), Pseudo C (dịch ngược), HLIL. Mình đã tải và cài thử trên Windows, sau đó thử mở một file ELF (file code rust-tracking) Mình có thể dùng với Strings, Hex Editor,\u0026hellip; Công cụ quá mạnh mẽ. ",
      "content_html": "\u003cp\u003eMột bài viết về \u003ca href=\"https://whitehat.vn/threads/re1-gioi-thieu-ve-reverse-engineering.875/\"\u003eRE (Reverse Engineering)\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"công-cụ-ida---the-interactive-disassemblerhttpswhitehatvnthreadsre3-huong-dan-su-dung-ida913\"\u003e\u003ca href=\"https://whitehat.vn/threads/re3-huong-dan-su-dung-ida.913/\"\u003eCông cụ IDA - The Interactive Disassembler\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này có \u003ca href=\"https://hex-rays.com/ida-free/#download\"\u003ebản free\u003c/a\u003e và hỗ trợ cài đặt trên nhiều nền tảng.\u003c/li\u003e\n\u003cli\u003eMình tải và cài đặt bản free cho Windows. Tuy nhiên thì:\n\u003cul\u003e\n\u003cli\u003eVới bản free thì mình chỉ có thể dùng cho các file \u003cstrong\u003ePE format\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLà dạng các file \u003ccode\u003e.exe\u003c/code\u003e trên windows.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eVới bản \u003cem\u003efree\u003c/em\u003e thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-online---decompiler-explorerhttpsdogboltorg\"\u003eCông cụ Online - \u003ca href=\"https://dogbolt.org/\"\u003eDecompiler Explorer\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"phần-mềm-binary-ninjahttpsbinaryninja\"\u003ePhần mềm \u003ca href=\"https://binary.ninja/\"\u003eBinary Ninja\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eBinary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"video-youtube-tham-khảo\"\u003eVideo youtube tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=FBwRTWEzGN0\u0026amp;list=WL\u0026amp;index=11\"\u003eHow to Crack Software (Reverse Engineering)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=tCcLhsTdFEw\"\u003eLearning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=-RaOeooSmug\"\u003eAn Intro to Binary Ninja (Free) for Malware Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=IdNFMIQ9roQ\"\u003eBinary Ninja: 4.1 Feature Stream!\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"community-provided-binary-ninja-plugins-community-pluginshttpsgithubcomvector35community-plugins\"\u003eCommunity provided Binary Ninja plugins: \u003ca href=\"https://github.com/Vector35/community-plugins\"\u003ecommunity-plugins\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"download-freehttpsbinaryninjafree\"\u003e\u003ca href=\"https://binary.ninja/free/\"\u003eDownload Free\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ mạnh mẽ, nhưng được sử dụng \u003cstrong\u003efree\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNếu so sánh thì phần mềm này \u003cstrong\u003eăn đứt IDA\u003c/strong\u003e về tính năng của bản free:\n\u003cul\u003e\n\u003cli\u003eSupports x86, x86_64, and ARMv7 architectures.\u003c/li\u003e\n\u003cli\u003eHỗ trợ \u003cstrong\u003eDisassemble\u003c/strong\u003e (phân tích), \u003cstrong\u003ePseudo C\u003c/strong\u003e (dịch ngược), \u003cstrong\u003eHLIL\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMình đã tải và cài thử trên Windows, sau đó thử mở một \u003cstrong\u003efile ELF\u003c/strong\u003e (file code rust-tracking)\u003c/li\u003e\n\u003cli\u003eMình có thể dùng với \u003cstrong\u003eStrings\u003c/strong\u003e, \u003cstrong\u003eHex Editor\u003c/strong\u003e,\u0026hellip;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCông cụ quá mạnh mẽ\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Binary_Ninja_Free.png\"\n  alt=\"Binary_Ninja_Free\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/re_tool_binaryninjafree/",
      "date_published": "16086-16-09T87:1616:00+07:00",
      "date_modified": "16086-16-09T87:1616:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8858de0373b9ed077f6a2e9fc778bc7ae286a217",
      "title": "Read_Write_UART_STM32Fx",
      "summary": "",
      "content_text": "Code Test Read Write Data trên UART của chip STM32F103 #![no_std] #![no_main] #![feature(type_alias_impl_trait)] #![feature(alloc_error_handler)] //------------------------- Define Macro Alloc ------------------------------------ extern crate alloc; use alloc_cortex_m::CortexMHeap; // this is the allocator the application will use #[global_allocator] static ALLOCATOR: CortexMHeap = CortexMHeap::empty(); const HEAP_SIZE: usize = 1024; // in bytes //----------------------------------------------------------------------------------- use defmt::*; use defmt_rtt as _; use embassy_executor::Spawner; use embassy_stm32::usart::{Config, Uart}; use embassy_stm32::{bind_interrupts, peripherals, usart}; use embassy_time::{with_timeout, Duration}; use panic_halt as _; bind_interrupts!(struct Irqs { USART1 =\u0026gt; usart::InterruptHandler\u0026lt;peripherals::USART1\u0026gt;; }); #[embassy_executor::main] async fn main(_spawner: Spawner) { // Initialize the allocator BEFORE you use it unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) } info!(\u0026#34;Test UART\u0026#34;); let p = embassy_stm32::init(Default::default()); let mut uart = Uart::new( p.USART1, p.PA10, p.PA9, Irqs, p.DMA1_CH4, p.DMA1_CH5, Config::default(), ) .unwrap(); uart.write(b\u0026#34;Start Test UART\\r\\n\u0026#34;).await.unwrap(); let mut response_data = [0u8; 25]; // Buffer for one byte at a time. loop { match with_timeout(Duration::from_millis(100), uart.read_until_idle(\u0026amp;mut response_data)).await { Ok(_) =\u0026gt; { println!(\u0026#34;Data Test: {}\u0026#34;, response_data); if let Ok(message) = core::str::from_utf8(\u0026amp;response_data) { println!(\u0026#34;DATA OK: {}\u0026#34;, message); } // clean buffer response_data.fill(0); } Err(_e) =\u0026gt; { // debug!(\u0026#34;Read UART Error\u0026#34;); } } } } // define what happens in an Out Of Memory (OOM) condition #[alloc_error_handler] fn alloc_error(_layout: core::alloc::Layout) -\u0026gt; ! { loop {} } Note Đoạn code này dùng timeout với read_until_idle. Với read_until_idle là để tự detect các ký tự xuống dòng như \\r\\n. Kết quả test thành công: ",
      "content_html": "\u003ch2 id=\"code-test-read-write-data-trên-uart-của-chip-stm32f103\"\u003eCode Test Read Write Data trên UART của chip STM32F103\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#![no_std]\n#![no_main]\n#![feature(type_alias_impl_trait)]\n#![feature(alloc_error_handler)]\n//------------------------- Define Macro Alloc ------------------------------------\nextern crate alloc;\nuse alloc_cortex_m::CortexMHeap;\n\n// this is the allocator the application will use\n#[global_allocator]\nstatic ALLOCATOR: CortexMHeap = CortexMHeap::empty();\n\nconst HEAP_SIZE: usize = 1024; // in bytes\n\n//-----------------------------------------------------------------------------------\nuse defmt::*;\nuse defmt_rtt as _;\nuse embassy_executor::Spawner;\nuse embassy_stm32::usart::{Config, Uart};\nuse embassy_stm32::{bind_interrupts, peripherals, usart};\nuse embassy_time::{with_timeout, Duration};\nuse panic_halt as _;\n\nbind_interrupts!(struct Irqs {\n    USART1 =\u0026gt; usart::InterruptHandler\u0026lt;peripherals::USART1\u0026gt;;\n});\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    // Initialize the allocator BEFORE you use it\n    unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) }\n\n    info!(\u0026#34;Test UART\u0026#34;);\n    let p = embassy_stm32::init(Default::default());\n\n    let mut uart = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        Irqs,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        Config::default(),\n    )\n    .unwrap();\n\n    uart.write(b\u0026#34;Start Test UART\\r\\n\u0026#34;).await.unwrap();\n    let mut response_data = [0u8; 25]; // Buffer for one byte at a time.\n\n    loop {\n        match with_timeout(Duration::from_millis(100), uart.read_until_idle(\u0026amp;mut response_data)).await {\n            Ok(_) =\u0026gt; {\n                println!(\u0026#34;Data Test: {}\u0026#34;, response_data);\n\n                if let Ok(message) = core::str::from_utf8(\u0026amp;response_data) {\n                    println!(\u0026#34;DATA OK: {}\u0026#34;, message);\n                }\n\n                // clean buffer\n                response_data.fill(0);\n            }\n            Err(_e) =\u0026gt; {\n                // debug!(\u0026#34;Read UART Error\u0026#34;);\n            }\n        }\n    }\n}\n\n// define what happens in an Out Of Memory (OOM) condition\n#[alloc_error_handler]\nfn alloc_error(_layout: core::alloc::Layout) -\u0026gt; ! {\n    loop {}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐoạn code này dùng \u003ccode\u003etimeout\u003c/code\u003e với \u003ccode\u003eread_until_idle\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eVới \u003ccode\u003eread_until_idle\u003c/code\u003e là để tự detect các ký tự xuống dòng như \u003ccode\u003e\\r\\n\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eKết quả test thành công:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/UART_Read_Write_Result.png\"\n  alt=\"Read_Write\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/read_write_uart_stm32fx/",
      "date_published": "14086-14-09T817:1414:00+07:00",
      "date_modified": "14086-14-09T817:1414:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d646756b3915b7869f9ba136ff457d3e000f4774",
      "title": "Dump_Firmware_NOR_Flash",
      "summary": "",
      "content_text": "Đây là video Youtube nói về việc Dump Firmware thiết bị: Extracting Firmware from Embedded Devices (SPI NOR Flash) ⚡\nMột video hay, thú vị, giải thích và hướng dẫn cơ bản về Flash Memory\nLoại NOR Flash này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như tracking. Còn NAND Flash thì mình thấy trong các thiết bị như Camera hành trình. Loại eMMC Flash thì mình thấy trong máy tính nhúng (như Pi). NOR Flash Trong video thì hướng dẫn và giải thích cơ bản về NOR Flash, cũng như cách dump firmware từ nó. Loại flash này dùng giao thức SPI: Làm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC. Nếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự. Dump Firmware Trong video tác giả sử dụng phần cứng HydraBus Đây là một dự án mã nguồn mở về phần cứng (hardware open-source): hydrabus project. Tài liệu về Cách sử dụng Hydrabus: Getting Started with HydraBus Dựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware: flashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c \u0026#34;MX25L6406E/MX25L6408E Note Để hiểu rõ hơn thì cần xem lại video nhiều lần. Ngoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash hydra_spiflash_nor_dump Một số hình ảnh khác về cách dùng cũng như công cụ bổ trợ: ",
      "content_html": "\u003cp\u003eĐây là video Youtube nói về việc \u003cstrong\u003eDump Firmware\u003c/strong\u003e thiết bị: \u003ca href=\"https://www.youtube.com/watch?v=nruUuDalNR0\u0026amp;list=WL\u0026amp;index=7\"\u003eExtracting Firmware from Embedded Devices (SPI NOR Flash) ⚡\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMột video hay, thú vị, giải thích và hướng dẫn cơ bản về \u003cstrong\u003eFlash Memory\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLoại \u003cstrong\u003eNOR Flash\u003c/strong\u003e này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như \u003cstrong\u003etracking\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCòn \u003cstrong\u003eNAND Flash\u003c/strong\u003e thì mình thấy trong các thiết bị như \u003cstrong\u003eCamera hành trình\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLoại \u003cstrong\u003eeMMC Flash\u003c/strong\u003e thì mình thấy trong \u003cstrong\u003emáy tính nhúng\u003c/strong\u003e (như Pi).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nor-flash\"\u003eNOR Flash\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video thì hướng dẫn và giải thích cơ bản về \u003cstrong\u003eNOR Flash\u003c/strong\u003e, cũng như cách \u003cstrong\u003edump firmware\u003c/strong\u003e từ nó.\u003c/li\u003e\n\u003cli\u003eLoại flash này dùng giao thức \u003cstrong\u003eSPI\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_3.png\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLàm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC.\u003c/li\u003e\n\u003cli\u003eNếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_4.png\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"dump-firmware\"\u003eDump Firmware\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video tác giả sử dụng phần cứng \u003ca href=\"https://hydrabus.com/hydrabus-1-0-specifications/?v=e14da64a5617\"\u003eHydraBus\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/HydraFW_Default_PinAssignment.jpg\"\n  alt=\"HydraBus\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là \u003cstrong\u003emột dự án mã nguồn mở về phần cứng\u003c/strong\u003e (hardware open-source): \u003ca href=\"https://github.com/hydrabus/hydrabus\"\u003ehydrabus project\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eTài liệu về Cách sử dụng Hydrabus: \u003ca href=\"https://github.com/hydrabus/hydrafw/wiki/Getting-Started-with-HydraBus\"\u003eGetting Started with HydraBus\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eflashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c \u0026#34;MX25L6406E/MX25L6408E\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"note\"\u003eNote\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐể hiểu rõ hơn thì cần xem lại video nhiều lần.\u003c/li\u003e\n\u003cli\u003eNgoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash \u003ca href=\"https://github.com/hydrabus/hydrafw/tree/master/contrib/hydra_spiflash_nor_dump\"\u003e\u003ccode\u003ehydra_spiflash_nor_dump\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-số-hình-ảnh-khác-về-cách-dùng-cũng-như-công-cụ-bổ-trợ\"\u003eMột số hình ảnh khác về cách dùng cũng như công cụ bổ trợ:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_5.png\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_6.png\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_7.png\"\n  alt=\"Hinh_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_8.png\"\n  alt=\"Hinh_8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/dump_firmware_nor_flash/",
      "date_published": "12086-12-09T844:1212:00+07:00",
      "date_modified": "12086-12-09T844:1212:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e9b5355ef4d97f5d9b1f18a012a87fb12e896428",
      "title": "Shared_Access_Embassy",
      "summary": "",
      "content_text": "Như bài viết về Lifetime_Embassy mình bị vướng chỗ ownership UART.\nSau khi thăm hỏi ChatGPT và đọc lại các tài liệu cũng như xem sample code thì biết rằng: Rust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời \u0026ndash;\u0026gt; Gây lỗi cho chương trình.\nĐể giải quyết vấn đề này thì cần share quyền truy cập (Managing Shared Access).\nCách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột quyền sở hữu (ownership) hoặc mượn (borrow)\nVà để làm được điều này mình sẽ cần dùng đến Mutex, RefCell hoặc Arc. Arc\u0026lt;Mutex\u0026lt;Uart\u0026gt;\u0026gt; Tham khảo sample code về việc sử dụng Arc. Link\nvấn đề tiếp theo Xui một cái nữa là Arc không được khuyến nghị sử dụng trong embedded. và trong các example code có trong framwork embassy, mình cũng không thấy ví dụ nào về dùng Arc. Tiếp tục hỏi chatGPT về cách Shared Access trong framwork embassy, cuối cùng cũng đã có kết quả. Code sample Đây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được. Đoạn code này dùng: Mutex, NoopRawMutex và RefCell. use embassy_executor::Spawner; use embassy_stm32::usart::Uart; use embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1}; use embassy_stm32::gpio::{Output, Level, Speed}; use embassy_time::{Timer, Duration}; use embassy_sync::blocking_mutex::raw::NoopRawMutex; use embassy_sync::mutex::Mutex; use core::cell::RefCell; use core::future::Future; use core::sync::atomic::{AtomicBool, Ordering}; #[embassy_executor::task] pub async fn test_command( uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, message: \u0026amp;\u0026#39;static str, ) { let mut count = 0; loop { count += 1; { let uart = uart.lock().await; let mut uart = uart.borrow_mut(); uart.write(message.as_bytes()).await.unwrap(); uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap(); } if count == 10 { break; } Timer::after(Duration::from_millis(1000)).await; } } #[embassy_executor::task] pub async fn main_task_rfid( rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, mut power_pin_cr95hf: Output\u0026lt;\u0026#39;static, PA1\u0026gt;, ) { dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await; } async fn dbg_print( uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, message: \u0026amp;str, ) { let uart = uart.lock().await; let mut uart = uart.borrow_mut(); uart.write(message.as_bytes()).await.unwrap(); uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap(); } #[embassy_executor::main] async fn main(spawner: Spawner) { let p = embassy_stm32::Peripherals::take().unwrap(); let usart_rfid = Uart::new( p.USART2, p.PA3, p.PA2, IrqsUART2, p.DMA1_CH7, p.DMA1_CH6, config_rfid, ) .unwrap(); let usart_debug = Uart::new( p.USART1, p.PA10, p.PA9, IrqsUART1, p.DMA1_CH4, p.DMA1_CH5, config_debug, ) .unwrap(); // Convert usart_rfid and usart_debug to \u0026#39;static lifetimes let usart_rfid_static = Box::leak(Box::new(usart_rfid)); let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug)))); // Create the ctr_rfid object let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low); let ctr_rfid_static = Box::leak(Box::new(ctr_rfid)); // Async task for test command spawner .spawn(test_command(usart_debug_static, \u0026#34;Test\u0026#34;)) .unwrap(); // Async task for RFID spawner .spawn(main_task_rfid( usart_rfid_static, usart_debug_static, ctr_rfid_static, )) .unwrap(); } Đã khắc phục và chạy code được thành công. ",
      "content_html": "\u003cp\u003eNhư bài viết về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/lifetime_embassy/\"\u003eLifetime_Embassy\u003c/a\u003e mình bị vướng chỗ ownership UART.\u003c/p\u003e\n\u003cp\u003eSau khi thăm hỏi \u003cstrong\u003eChatGPT\u003c/strong\u003e và đọc lại các tài liệu cũng như xem sample code thì biết rằng:\n\u003cstrong\u003eRust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời \u0026ndash;\u0026gt; Gây lỗi cho chương trình\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐể giải quyết vấn đề này thì cần share quyền truy cập (\u003cstrong\u003eManaging Shared Access\u003c/strong\u003e).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột \u003cstrong\u003equyền sở hữu\u003c/strong\u003e (\u003cem\u003eownership\u003c/em\u003e) hoặc \u003cstrong\u003emượn\u003c/strong\u003e (\u003cem\u003eborrow\u003c/em\u003e)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eVà để làm được điều này mình sẽ cần dùng đến \u003cstrong\u003eMutex\u003c/strong\u003e, \u003cstrong\u003eRefCell\u003c/strong\u003e hoặc \u003cstrong\u003eArc\u003c/strong\u003e. \u003ccode\u003eArc\u0026lt;Mutex\u0026lt;Uart\u0026gt;\u0026gt;\u003c/code\u003e\nTham khảo sample code về việc sử dụng Arc. \u003ca href=\"https://rust-classes.com/chapter_6_3\"\u003eLink\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"vấn-đề-tiếp-theo\"\u003evấn đề tiếp theo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXui một cái nữa là \u003cstrong\u003eArc\u003c/strong\u003e không được khuyến nghị sử dụng trong \u003cstrong\u003eembedded\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003evà trong các example code có trong \u003cstrong\u003eframwork embassy\u003c/strong\u003e, mình cũng không thấy ví dụ nào về dùng \u003cstrong\u003eArc\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTiếp tục hỏi chatGPT về cách \u003cstrong\u003eShared Access trong framwork embassy\u003c/strong\u003e, cuối cùng cũng đã có kết quả.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"code-sample\"\u003eCode sample\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được.\u003c/li\u003e\n\u003cli\u003eĐoạn code này dùng: \u003cstrong\u003eMutex\u003c/strong\u003e, \u003cstrong\u003eNoopRawMutex\u003c/strong\u003e và \u003cstrong\u003eRefCell\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse embassy_executor::Spawner;\nuse embassy_stm32::usart::Uart;\nuse embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1};\nuse embassy_stm32::gpio::{Output, Level, Speed};\nuse embassy_time::{Timer, Duration};\nuse embassy_sync::blocking_mutex::raw::NoopRawMutex;\nuse embassy_sync::mutex::Mutex;\nuse core::cell::RefCell;\nuse core::future::Future;\nuse core::sync::atomic::{AtomicBool, Ordering};\n\n#[embassy_executor::task]\npub async fn test_command(\n    uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    message: \u0026amp;\u0026#39;static str,\n) {\n    let mut count = 0;\n    loop {\n        count += 1;\n\n        {\n            let uart = uart.lock().await;\n            let mut uart = uart.borrow_mut();\n            uart.write(message.as_bytes()).await.unwrap();\n            uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap();\n        }\n\n        if count == 10 {\n            break;\n        }\n\n        Timer::after(Duration::from_millis(1000)).await;\n    }\n}\n\n#[embassy_executor::task]\npub async fn main_task_rfid(\n    rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    mut power_pin_cr95hf: Output\u0026lt;\u0026#39;static, PA1\u0026gt;,\n) {\n    dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await;\n}\n\nasync fn dbg_print(\n    uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    message: \u0026amp;str,\n) {\n    let uart = uart.lock().await;\n    let mut uart = uart.borrow_mut();\n    uart.write(message.as_bytes()).await.unwrap();\n    uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap();\n}\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let p = embassy_stm32::Peripherals::take().unwrap();\n\n    let usart_rfid = Uart::new(\n        p.USART2,\n        p.PA3,\n        p.PA2,\n        IrqsUART2,\n        p.DMA1_CH7,\n        p.DMA1_CH6,\n        config_rfid,\n    )\n    .unwrap();\n\n    let usart_debug = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        IrqsUART1,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        config_debug,\n    )\n    .unwrap();\n\n    // Convert usart_rfid and usart_debug to \u0026#39;static lifetimes\n    let usart_rfid_static = Box::leak(Box::new(usart_rfid));\n    let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug))));\n\n\n    // Create the ctr_rfid object\n    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);\n    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));\n\n    // Async task for test command\n    spawner\n        .spawn(test_command(usart_debug_static, \u0026#34;Test\u0026#34;))\n        .unwrap();\n\n    // Async task for RFID\n    spawner\n        .spawn(main_task_rfid(\n            usart_rfid_static,\n            usart_debug_static,\n            ctr_rfid_static,\n        ))\n        .unwrap();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"đã-khắc-phục-và-chạy-code-được-thành-công\"\u003e\u003cstrong\u003eĐã khắc phục và chạy code được thành công\u003c/strong\u003e.\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Result_Shared_Access_UART.png\"\n  alt=\"Result_Shared_Access_UART\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/shared_access_embassy/",
      "date_published": "10086-10-09T818:1010:00+07:00",
      "date_modified": "10086-10-09T818:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a16b4dd5414090a88aec578f8ac2b21db34beb7",
      "title": "Lifetime_Embassy",
      "summary": "",
      "content_text": "Trong quá trình code Rust cho RFID, khi sử dụng đến phần UART và dùng đến #[embassy_executor::task] thì bị báo lỗi về Lifetime\nLỗi lifetime về uart. Hiều nôm na thì rust đang báo là thời gian sống (thời gian tồn tại, hay vòng đời) của UART quá ngắn để thực hiện các tiến trình trong task.\nXem thêm video Rust Lifetimes Finally Explained!\nĐể khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: 'static, 'a, 'b,\u0026hellip;\nVà để khắc phục triệt để mình phải sử dụng thêm Box\nGiới thiệu sơ về Box All values in Rust are stack allocated by default. Values can be boxed (allocated on the heap) by creating a Box. A box is a smart pointer to a heap allocated value of type T. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.\nĐể chuyển giá trị của Box thành một con trỏ với lifetime là 'static. Mình sẽ dùng đến cấu trúc Box::leak.\nCode mô tả: #[embassy_executor::task] pub async fn main_task_rfid( rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, power_pin_cr95hf: \u0026amp;\u0026#39;static mut Output\u0026lt;\u0026#39;_, PA1\u0026gt;, ) { // Use debug_uart here dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await; } #[embassy_executor::main] async fn main(spawner: Spawner) { let p = embassy_stm32::Peripherals::take().unwrap(); let mut usart_debug = Uart::new( p.USART1, p.PA10, p.PA9, IrqsUART1, p.DMA1_CH4, p.DMA1_CH5, config_debug, ).unwrap(); dbg_print(\u0026amp;mut usart_debug, \u0026#34;RFID CR95\u0026#34;).await; //------------------ RFID Task --------------------- let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low); // Convert references to \u0026#39;static by leaking the values let usart_rfid_static = Box::leak(Box::new(usart_rfid)); let usart_debug_static = Box::leak(Box::new(usart_debug)); let ctr_rfid_static = Box::leak(Box::new(ctr_rfid)); // Async task RFID spawner .spawn(task_rfid::main_task_rfid( usart_rfid_static, usart_debug_static, ctr_rfid_static, )) .unwrap(); Khi đã sử dụng usart_debug cho Box::leak (và được dùng cho task RFID) thì mình không còn dùng được usart_debug sau nữa.\nVì lúc này bị dính đến ownership.\n",
      "content_html": "\u003cp\u003eTrong quá trình code Rust cho RFID, khi sử dụng đến phần \u003cstrong\u003eUART\u003c/strong\u003e và dùng đến \u003ccode\u003e#[embassy_executor::task]\u003c/code\u003e thì bị báo lỗi về \u003cstrong\u003eLifetime\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLỗi lifetime về uart. Hiều nôm na thì rust đang báo là \u003cstrong\u003ethời gian sống\u003c/strong\u003e (thời gian tồn tại, hay \u003cstrong\u003evòng đời\u003c/strong\u003e) của \u003cstrong\u003eUART\u003c/strong\u003e quá ngắn để thực hiện các tiến trình trong task.\u003c/p\u003e\n\u003cp\u003eXem thêm video \u003ca href=\"https://www.youtube.com/watch?v=juIINGuZyBc\"\u003eRust Lifetimes Finally Explained!\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eĐể khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: \u003ccode\u003e'static\u003c/code\u003e, \u003ccode\u003e'a\u003c/code\u003e, \u003ccode\u003e'b\u003c/code\u003e,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eVà để khắc phục triệt để mình phải sử dụng thêm \u003ca href=\"https://doc.rust-lang.org/rust-by-example/std/box.html\"\u003eBox\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"giới-thiệu-sơ-về-box\"\u003eGiới thiệu sơ về Box\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAll values in Rust are stack allocated by default. Values can be \u003cem\u003eboxed\u003c/em\u003e (allocated on the heap) by creating a Box\u003cT\u003e.\nA \u003cstrong\u003ebox is a smart pointer\u003c/strong\u003e to a \u003cstrong\u003eheap allocated value of type T\u003c/strong\u003e.\nWhen a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Box_Rust.png\"\n  alt=\"Box\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐể chuyển giá trị của Box thành một con trỏ với lifetime là \u003ccode\u003e'static\u003c/code\u003e. Mình sẽ dùng đến cấu trúc \u003ccode\u003eBox::leak\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"code-mô-tả\"\u003eCode mô tả:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#[embassy_executor::task]\npub async fn main_task_rfid(\n    rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n    power_pin_cr95hf: \u0026amp;\u0026#39;static mut Output\u0026lt;\u0026#39;_, PA1\u0026gt;,\n) {\n    // Use debug_uart here\n    dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await;\n}\n\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let p = embassy_stm32::Peripherals::take().unwrap();\n\n    let mut usart_debug = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        IrqsUART1,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        config_debug,\n    ).unwrap();\n\n    dbg_print(\u0026amp;mut usart_debug, \u0026#34;RFID CR95\u0026#34;).await;\n\n    //------------------ RFID Task ---------------------\n    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);\n\n    // Convert references to \u0026#39;static by leaking the values\n    let usart_rfid_static = Box::leak(Box::new(usart_rfid));\n    let usart_debug_static = Box::leak(Box::new(usart_debug));\n    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));\n\n    // Async task RFID\n    spawner\n        .spawn(task_rfid::main_task_rfid(\n            usart_rfid_static,\n            usart_debug_static,\n            ctr_rfid_static,\n        ))\n        .unwrap();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eKhi đã sử dụng \u003ccode\u003eusart_debug\u003c/code\u003e cho \u003cstrong\u003eBox::leak\u003c/strong\u003e (và được dùng cho \u003cstrong\u003etask RFID\u003c/strong\u003e) thì mình không còn dùng được \u003ccode\u003eusart_debug\u003c/code\u003e sau nữa.\u003c/p\u003e\n\u003cp\u003eVì lúc này bị dính đến \u003cstrong\u003eownership\u003c/strong\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/lifetime_embassy/",
      "date_published": "9086-09-09T88:99:00+07:00",
      "date_modified": "9086-09-09T88:99:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7345b57aedfb01ea55a4c03e7a63fddfa26356b3",
      "title": "Results_Rust",
      "summary": "",
      "content_text": "Một trong các ưu điểm của ngôn ngữ bậc cao là việc Handle Error.\nVà trong Rust thì chính là cách sử dụng Result.\nMình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.\nVideo Youtube: A Simpler Way to See Results Result vs Option Nói cách dễ hiểu thì:\nOption dùng khi mình chỉ muốn biểu đạt có giá trị hoặc không có giá trị. Result dùng khi mình muốn biểu đạt là có giá trị đúng và biết được thông tin lỗi. Ví dụ về việc trả về một giá trị và handle-error Ví dụ về việc trả về hai giá trị và handle-error Nếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code. Tuy nhiên nếu dùng thêm operator thì cách biểu đạt sẽ đơn giản hơn. ",
      "content_html": "\u003cp\u003eMột trong các ưu điểm của ngôn ngữ bậc cao là việc \u003cstrong\u003eHandle Error\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eVà trong Rust thì chính là cách sử dụng \u003cstrong\u003eResult\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.\u003c/p\u003e\n\u003ch3 id=\"video-youtube-a-simpler-way-to-see-resultshttpswwwyoutubecomwatchvs5s2ed5t-dc\"\u003eVideo Youtube: \u003ca href=\"https://www.youtube.com/watch?v=s5S2Ed5T-dc\"\u003eA Simpler Way to See Results\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"result-vs-optionhttpsdhghomongithubioeasy_rustchapter_31html\"\u003e\u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_31.html\"\u003eResult vs Option\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eNói cách dễ hiểu thì:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOption\u003c/strong\u003e dùng khi mình chỉ muốn biểu đạt \u003cstrong\u003ecó giá trị\u003c/strong\u003e hoặc \u003cstrong\u003ekhông có giá trị\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eResult\u003c/strong\u003e dùng khi mình muốn biểu đạt là có \u003cstrong\u003egiá trị đúng\u003c/strong\u003e và biết được \u003cstrong\u003ethông tin lỗi\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_3.png\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ví-dụ-về-việc-trả-về-một-giá-trị-và-handle-error\"\u003eVí dụ về việc trả về \u003cstrong\u003emột giá trị\u003c/strong\u003e và handle-error\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_4.png\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ví-dụ-về-việc-trả-về-hai-giá-trị-và-handle-error\"\u003eVí dụ về việc trả về \u003cstrong\u003ehai giá trị\u003c/strong\u003e và handle-error\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code.\u003c/li\u003e\n\u003cli\u003eTuy nhiên nếu dùng thêm \u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_33.html\"\u003eoperator\u003c/a\u003e thì cách biểu đạt sẽ đơn giản hơn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_5.png\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_6.png\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust-lang/results_rust/",
      "date_published": "8086-08-09T87:88:00+07:00",
      "date_modified": "8086-08-09T87:88:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "372a4f104501fddb17ccf0cebf9ae4ae0fb586fa",
      "title": "UART_Embassy",
      "summary": "",
      "content_text": "Giới thiệu về Embassy Trong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này. Embassy một framework lập trình theo kiểu bất đồng bộ (async), dễ tiếp cận hơn việc setup một RTOS cho MCU. Async Embassy Dựa trên một file tài liệu mà mình tình cờ có được async-embedded thì Async là một cách tiếp cận về việc Xử lý đồng thời (Concurrency). Hơn nữa dựa trên Github Embassy thì framework này hỗ trợ kha khá dòng chip: Dòng nRF: embassy_nrf Dòng STM32: embassy-stm32 Dòng RP2040: embassy_rp Dòng ESP32: esp-rs Nhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust. UART Trong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.\nRead Trong STM32 phần Read UART có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng. blocking_read read read_until_idle Func blocking_read Function này sẽ mình đọc đầy đủ dữ liệu. Ban đầu mình có test thử giữa blocking_read với read, thì mình đọc được dữ liệu với blocking_read, còn với read thì không. Func read Mình sẽ thường dùng function read này kết hợp với timeout. Tức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra. Nhờ cách này mà mình tránh được việc bị treo chương trình. Đây là một đoạn code mẫu: // health_check_cr95hf // True: CR95HF OK // Flase: CR95HF not reponse -\u0026gt; Maybe lost connect with CR95HF async fn health_check_cr95hf( rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, ) -\u0026gt; bool { let echo_command_code: \u0026amp;[u8]; echo_command_code = cr95hf::cr95hf_echo_command(); dbg_print(debug_uart, \u0026#34;Health Check CR95HF\u0026#34;).await; // Buffer data reponse from CR95HF let mut response_code = [0u8; 1]; let _size_data: usize = 1; for _i in 1..3 { // Send command rfid_uart.blocking_write(\u0026amp;echo_command_code).unwrap(); // Read reponse from CR95HF match with_timeout( Duration::from_millis(30), rfid_uart.read(\u0026amp;mut response_code), ) .await { // match rfid_uart.blocking_read(\u0026amp;mut response_code) { Ok(_size_data) =\u0026gt; { // let _ = debug_uart.blocking_write(\u0026amp;response_code); // Data reponse from CR95 OK if response_code == echo_command_code { return true; } else { return false; } } Err(_e) =\u0026gt; { dbg_print(debug_uart, \u0026#34;Read UART Error - Func health_check_cr95hf\u0026#34;).await; // delay 10ms Timer::after(Duration::from_millis(10)).await; continue; } } } return false; } Func read_until_idle Để hiểu hơn về IDLE UART, mình đã tham khảo tài liệu: https://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette https://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/ Tức là với func này, nó sẽ chia ra thành từng block để đọc dữ liệu. Dưới đây là đoạn code với chức năng là: gửi command sau đó đọc 4 bytes dữ liệu, tuy nhiên chỉ lấy 2 bytes đầu để xử lý dữ liệu // no_tag_cr95hf: Check no_tag // Return true: if not detectd tag card async fn no_tag_cr95hf( rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, ) -\u0026gt; bool { // First: Setup Protocol ISO15693 setup_protocol_iso15693(rfid_uart).await; // Second: Read data and check errors code // Define the initial byte array let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00]; for _i in 1..3 { // Send command rfid_uart.blocking_write(\u0026amp;sendrecv_command).unwrap(); // Buffer data reponse from CR95HF let mut response_data = [0u8; 4]; let _size_data: usize = 2; // Read reponse from CR95HF match rfid_uart.read_until_idle(\u0026amp;mut response_data).await { Ok(_size_data) =\u0026gt; { // let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data.clone()); let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data); // let _ = debug_uart.blocking_write(\u0026amp;response_data); // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes()); if is_no_tag == true { dbg_print(debug_uart, \u0026#34;NO TAG CARD\u0026#34;).await; return true; } else { return false; } } Err(_e) =\u0026gt; { // delay 10ms Timer::after(Duration::from_millis(10)).await; } } } return false; } ",
      "content_html": "\u003ch2 id=\"giới-thiệu-về-embassyhttpsembassydev\"\u003eGiới thiệu về \u003ca href=\"https://embassy.dev/\"\u003eEmbassy\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEmbassy\u003c/strong\u003e một framework lập trình theo kiểu \u003cstrong\u003ebất đồng bộ (async)\u003c/strong\u003e, dễ tiếp cận hơn việc setup một \u003cstrong\u003eRTOS\u003c/strong\u003e cho MCU.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Concurrency_Parallelism.jpg\"\n  alt=\"Concurrency_Parallelism\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"async-embassy\"\u003eAsync Embassy\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa trên một file tài liệu mà mình tình cờ có được \u003ca href=\"/docs/embassy/B4-async-embedded.pdf\"\u003easync-embedded\u003c/a\u003e thì \u003cstrong\u003eAsync\u003c/strong\u003e là một cách tiếp cận về việc \u003cstrong\u003eXử lý đồng thời (Concurrency)\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHơn nữa dựa trên \u003ca href=\"https://github.com/embassy-rs/embassy\"\u003eGithub Embassy\u003c/a\u003e thì framework này hỗ trợ kha khá dòng chip:\n\u003cul\u003e\n\u003cli\u003eDòng nRF: \u003ca href=\"https://docs.embassy.dev/embassy-nrf/git/nrf51/index.html\"\u003eembassy_nrf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng STM32: \u003ca href=\"https://docs.embassy.dev/embassy-stm32/git/stm32f730i8/index.html\"\u003eembassy-stm32\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng RP2040: \u003ca href=\"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html\"\u003eembassy_rp\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng ESP32: \u003ca href=\"https://github.com/esp-rs\"\u003eesp-rs\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eNhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"uart\"\u003eUART\u003c/h1\u003e\n\u003cp\u003eTrong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.\u003c/p\u003e\n\u003ch2 id=\"read\"\u003eRead\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong STM32 phần \u003cstrong\u003eRead UART\u003c/strong\u003e có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng.\n\u003cul\u003e\n\u003cli\u003eblocking_read\u003c/li\u003e\n\u003cli\u003eread\u003c/li\u003e\n\u003cli\u003eread_until_idle\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"func-blocking_read\"\u003eFunc \u003ccode\u003eblocking_read\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFunction này sẽ mình đọc đầy đủ dữ liệu.\u003c/li\u003e\n\u003cli\u003eBan đầu mình có test thử giữa \u003ccode\u003eblocking_read\u003c/code\u003e với \u003ccode\u003eread\u003c/code\u003e, thì mình \u003cstrong\u003eđọc\u003c/strong\u003e được dữ liệu với \u003ccode\u003eblocking_read\u003c/code\u003e, còn với \u003ccode\u003eread\u003c/code\u003e thì không.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"func-read\"\u003eFunc \u003ccode\u003eread\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình sẽ thường dùng function \u003cstrong\u003eread\u003c/strong\u003e này kết hợp với \u003cstrong\u003etimeout\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra.\u003c/li\u003e\n\u003cli\u003eNhờ cách này mà mình tránh được việc bị \u003cstrong\u003etreo\u003c/strong\u003e chương trình.\u003c/li\u003e\n\u003cli\u003eĐây là một đoạn code mẫu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// health_check_cr95hf\n// True: CR95HF OK\n// Flase: CR95HF not reponse -\u0026gt; Maybe lost connect with CR95HF\nasync fn health_check_cr95hf(\n    rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n) -\u0026gt; bool {\n    let echo_command_code: \u0026amp;[u8];\n    echo_command_code = cr95hf::cr95hf_echo_command();\n    dbg_print(debug_uart, \u0026#34;Health Check CR95HF\u0026#34;).await;\n\n    // Buffer data reponse from CR95HF\n    let mut response_code = [0u8; 1];\n    let _size_data: usize = 1;\n\n    for _i in 1..3 {\n        // Send command\n        rfid_uart.blocking_write(\u0026amp;echo_command_code).unwrap();\n\n        // Read reponse from CR95HF\n        match with_timeout(\n            Duration::from_millis(30),\n            rfid_uart.read(\u0026amp;mut response_code),\n        )\n        .await\n        {\n            // match rfid_uart.blocking_read(\u0026amp;mut response_code) {\n            Ok(_size_data) =\u0026gt; {\n                // let _ = debug_uart.blocking_write(\u0026amp;response_code);\n                // Data reponse from CR95 OK\n                if response_code == echo_command_code {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Err(_e) =\u0026gt; {\n                dbg_print(debug_uart, \u0026#34;Read UART Error - Func health_check_cr95hf\u0026#34;).await;\n                // delay 10ms\n                Timer::after(Duration::from_millis(10)).await;\n                continue;\n            }\n        }\n    }\n\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"func-read_until_idle\"\u003eFunc \u003ccode\u003eread_until_idle\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐể hiểu hơn về \u003cstrong\u003eIDLE UART\u003c/strong\u003e, mình đã tham khảo tài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette\nhttps://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTức là với func này, nó sẽ chia ra thành từng \u003cstrong\u003eblock\u003c/strong\u003e để đọc dữ liệu.\u003c/li\u003e\n\u003cli\u003eDưới đây là đoạn code với chức năng là: gửi command sau đó đọc \u003cstrong\u003e4 bytes\u003c/strong\u003e dữ liệu, tuy nhiên chỉ lấy \u003cstrong\u003e2 bytes\u003c/strong\u003e đầu để xử lý dữ liệu\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// no_tag_cr95hf: Check no_tag\n// Return true: if not detectd tag card\nasync fn no_tag_cr95hf(\n    rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n) -\u0026gt; bool {\n    // First: Setup Protocol ISO15693\n    setup_protocol_iso15693(rfid_uart).await;\n\n    // Second: Read data and check errors code\n    // Define the initial byte array\n    let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00];\n\n    for _i in 1..3 {\n        // Send command\n        rfid_uart.blocking_write(\u0026amp;sendrecv_command).unwrap();\n\n        // Buffer data reponse from CR95HF\n        let mut response_data = [0u8; 4];\n        let _size_data: usize = 2;\n\n        // Read reponse from CR95HF\n        match rfid_uart.read_until_idle(\u0026amp;mut response_data).await {\n            Ok(_size_data) =\u0026gt; {\n                // let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data.clone());\n                let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data);\n                // let _ = debug_uart.blocking_write(\u0026amp;response_data);\n                // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes());\n                if is_no_tag == true {\n                    dbg_print(debug_uart, \u0026#34;NO TAG CARD\u0026#34;).await;\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Err(_e) =\u0026gt; {\n                // delay 10ms\n                Timer::after(Duration::from_millis(10)).await;\n            }\n        }\n    }\n\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/software/uart_embassy/",
      "date_published": "7086-07-09T823:77:00+07:00",
      "date_modified": "7086-07-09T823:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "85f09ce2f3cf711d085e9963d1cd2f835cfcf5d6",
      "title": "IoT_Security_JD",
      "summary": "",
      "content_text": "Bữa lang thang trên diễn đàn CISSP trên facebook, mình thấy một JD về Security cho IoT. Mình thấy JD này đầy đủ và cụ thể:\nVNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị UAV, drone, IoT, satellite,... Nếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn: Có kỹ năng dịch ngược phần mềm (Reverse Engineering) và tìm kiếm lỗ hổng từ file thực thi đó Thông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware Thông thạo kỹ năng khai thác lỗ hổng phần mềm, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v.... Có kỹ năng Source code review + Pentest blackbox các các thiết bị IoT Đam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới Bạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm: Kiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v... trước khi hòa mạng vào hệ thống mạng băng rộng VNPT Nghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …) Nghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, … Nghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile VCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT: Gia nhập VCI, bạn sẽ đóng vai chính cho các dự án Làm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh Chế độ đãi ngộ hấp dẫn và review lương theo năng lực Chúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân Nếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé! Hồ sơ ứng viên xin gửi về địa chỉ email: security@vnpt.vn Reverse Đây là kỹ năng mà mình cần rèn luyện và trau dồi.\nDịch ngược Phần cứng Việc bóc tách chip nhớ thì sẽ có 2 mục tiêu chính: Thứ 1: Đọc các dữ liệu được lưu trữ không Flash Thứ 2: Dump Firmware Mình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại. Việc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị. Khai thác lỗ hổng Khi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn. Trong JD có các thuật ngữ mà mình không hiểu, ngoại trừ command injection. Cái này phức tạp vãi chưởng luôn. Pentest blackbox Các thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là Pentest Web. Hoặc có thể là lấy thông tin từ Debug UART, tìm kiếm IP Gateway Server, FTP Server,\u0026hellip; =\u0026gt; Pentest Web. Kiểm định, đánh giá an toàn bảo mật Các giao thức truyền thông IoT thì mình biết, nhưng mà để đánh giá ATTT thì mình chưa rõ. Không lẻ lấy theo tiêu chuẩn NIS2 Nhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.\nBiết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là điều kiện thực hành.\nMình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.\nVì trong IoT còn có những mảng nhỏ khác như:\nDesign (vẽ Schematic, PCB) Code nhúng Firmware cho MCU Code nhúng cho Linux Cũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]\n",
      "content_html": "\u003cp\u003eBữa lang thang trên diễn đàn \u003cstrong\u003eCISSP trên facebook\u003c/strong\u003e, mình thấy một \u003cstrong\u003eJD về Security cho IoT\u003c/strong\u003e. Mình thấy JD này đầy đủ và cụ thể:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eVNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị UAV, drone, IoT, satellite,...\nNếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn:\nCó kỹ năng dịch ngược phần mềm (Reverse Engineering) và tìm kiếm lỗ hổng từ file thực thi đó\nThông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware\nThông thạo kỹ năng khai thác lỗ hổng phần mềm, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v....\nCó kỹ năng Source code review + Pentest blackbox các các thiết bị IoT\nĐam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới\nBạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm:\nKiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v... trước khi hòa mạng vào hệ thống mạng băng rộng VNPT\nNghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …)\nNghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, …\nNghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile\nVCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT:\nGia nhập VCI, bạn sẽ đóng vai chính cho các dự án\nLàm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh\nChế độ đãi ngộ hấp dẫn và review lương theo năng lực\nChúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân\nNếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé!\nHồ sơ ứng viên xin gửi về địa chỉ email: security@vnpt.vn\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"reverse\"\u003eReverse\u003c/h2\u003e\n\u003cp\u003eĐây là kỹ năng mà mình cần rèn luyện và trau dồi.\u003c/p\u003e\n\u003ch3 id=\"dịch-ngược-phần-cứng\"\u003eDịch ngược Phần cứng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eViệc \u003cstrong\u003ebóc tách chip nhớ\u003c/strong\u003e thì sẽ có 2 mục tiêu chính:\n\u003cul\u003e\n\u003cli\u003eThứ 1: Đọc các dữ liệu được lưu trữ không Flash\u003c/li\u003e\n\u003cli\u003eThứ 2: Dump Firmware\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại.\u003c/li\u003e\n\u003cli\u003eViệc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"khai-thác-lỗ-hổng\"\u003eKhai thác lỗ hổng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn.\u003c/li\u003e\n\u003cli\u003eTrong JD có các thuật ngữ mà mình không hiểu, ngoại trừ \u003cstrong\u003ecommand injection\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCái này phức tạp vãi chưởng luôn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pentest-blackbox\"\u003ePentest blackbox\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là \u003cstrong\u003ePentest Web\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHoặc có thể là lấy thông tin từ \u003cstrong\u003eDebug UART\u003c/strong\u003e, tìm kiếm IP Gateway Server, FTP Server,\u0026hellip; =\u0026gt; Pentest Web.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kiểm-định-đánh-giá-an-toàn-bảo-mật\"\u003eKiểm định, đánh giá an toàn bảo mật\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác giao thức truyền thông IoT thì mình biết, nhưng mà để \u003cstrong\u003eđánh giá ATTT\u003c/strong\u003e thì mình chưa rõ.\u003c/li\u003e\n\u003cli\u003eKhông lẻ lấy theo tiêu chuẩn \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/nis2/\"\u003eNIS2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eNhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.\u003c/p\u003e\n\u003cp\u003eBiết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là \u003cstrong\u003eđiều kiện thực hành\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.\u003c/p\u003e\n\u003cp\u003eVì trong IoT còn có những mảng nhỏ khác như:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDesign (vẽ Schematic, PCB)\nCode nhúng Firmware cho MCU\nCode nhúng cho Linux\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://media.springernature.com/lw685/springer-static/image/chp%3A10.1007%2F978-981-15-6353-9_46/MediaObjects/488228_1_En_46_Fig1_HTML.png\"\n  alt=\"IoT\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/iot_security_jd/",
      "date_published": "4086-04-09T84:44:00+07:00",
      "date_modified": "4086-04-09T84:44:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "588a7f7dd0c3320660bf06f7cbd7a404d2ae850d",
      "title": "Docklight",
      "summary": "",
      "content_text": " Bữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn. Gửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết. Sang tuần mới có board mạch hoàn chỉnh. Lúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để giả lập data Serial.\nCông cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án Công lạnh.\nTool giả lập data cho Serial Mục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code. Những thông tin, data, command id,\u0026hellip; tất cả mình đã có hết. Lúc này mình sẽ dùng Docklight để giả lập data (tương tự như cách CR95 phản hồi command từ MCU). Docklight Đây là công cụ có bản quyền, phải trả phí. Tuy nhiên để dùng free thì mình cần tải phiên bản Docklight 2.2 trở xuống. Download Docklight 2.2 Download Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016) Và đây là Key number để kích hoạt: KEY NUMBER 010111323344556 ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eBữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn.\u003c/li\u003e\n\u003cli\u003eGửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết.\u003c/li\u003e\n\u003cli\u003eSang tuần mới có board mạch hoàn chỉnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để \u003cstrong\u003egiả lập data Serial\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCông cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án \u003cstrong\u003eCông lạnh\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"tool-giả-lập-data-cho-serial\"\u003eTool giả lập data cho Serial\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code.\u003c/li\u003e\n\u003cli\u003eNhững thông tin, data, command id,\u0026hellip; tất cả mình đã có hết.\u003c/li\u003e\n\u003cli\u003eLúc này mình sẽ dùng \u003cstrong\u003eDocklight\u003c/strong\u003e để \u003cstrong\u003egiả lập data\u003c/strong\u003e (tương tự như cách CR95 phản hồi command từ MCU).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"docklight\"\u003eDocklight\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là công cụ có bản quyền, phải trả phí.\u003c/li\u003e\n\u003cli\u003eTuy nhiên để dùng \u003cstrong\u003efree\u003c/strong\u003e thì mình cần tải phiên bản \u003cstrong\u003eDocklight 2.2\u003c/strong\u003e trở xuống.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://docklight.de/downloads/\"\u003eDocklight 2.2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDownload Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eVà đây là \u003cstrong\u003eKey number\u003c/strong\u003e để kích hoạt:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eKEY NUMBER\n010111323344556\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://docklight.de/wp-content/uploads/2018/09/app3_docklight_screenshot_simulator_based_on_log_data.png\"\n  alt=\"docklight\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/docklight/",
      "date_published": "3086-03-09T824:33:00+07:00",
      "date_modified": "3086-03-09T824:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "bbc6371e5a3df28e5b52599641e63196f8c43b5b",
      "title": "ParamSpider",
      "summary": "",
      "content_text": "Bữa có coi video trên Youtube có tựa đề: 5 Hacking Tools I Can\u0026rsquo;t Live Without\nTrong đó có đề cập đến các công cụ dành cho việc Pentest Web:\n1. DevTools 2. BURP Suite 3. Containers 4. FFUF 5. ParamSpider Mấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.\nGithub ParamSpider Dựa vào thông tin trên github công cụ giống như Wayback Machine Tuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian. Công cụ này cũng ổn áp \u0026ldquo;phết\u0026rdquo;. ",
      "content_html": "\u003cp\u003eBữa có coi video trên Youtube có tựa đề: \u003ca href=\"https://www.youtube.com/watch?v=JHRzVEvpHSM\u0026amp;list=WL\u0026amp;index=2\"\u003e5 Hacking Tools I Can\u0026rsquo;t Live Without\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTrong đó có đề cập đến các công cụ dành cho việc Pentest Web:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. DevTools\n2. BURP Suite\n3. Containers\n4. FFUF\n5. ParamSpider\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.\u003c/p\u003e\n\u003ch3 id=\"github-paramspiderhttpsgithubcomdevanshbathamparamspider\"\u003e\u003ca href=\"https://github.com/devanshbatham/ParamSpider\"\u003eGithub ParamSpider\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa vào thông tin trên github công cụ giống như \u003ca href=\"https://web.archive.org/\"\u003eWayback Machine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian.\u003c/li\u003e\n\u003cli\u003eCông cụ này cũng ổn áp \u0026ldquo;phết\u0026rdquo;.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://raw.githubusercontent.com/devanshbatham/ParamSpider/master/static/paramspider.png\"\n  alt=\"paramspider\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/paramspider/",
      "date_published": "3086-03-09T824:33:00+07:00",
      "date_modified": "3086-03-09T824:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a0a7c8213b1aec2b91bd5b2214fd070ecf7037c",
      "title": "Research_CR95",
      "summary": "",
      "content_text": "Giới thiệu: CR95 là dòng chip dùng để đọc RFID và NFC. Các thiết bị Giám sát hành trình theo QCVN31 đều phải có bộ RFID, để đọc thẻ tài xế. Công ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại IC CR95 (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này). Yêu cầu: Nghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART. Dùng ngôn ngữ lập trình Rust để viết Firmware. Research Sau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là SPI. Mình cần xem lại datasheet của CR95. Về phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware. May mắn thay Lúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART. Source code anh này được viết bằng C, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một board phần cứng CR95 khác Sau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là: Echo: 0x55 Info: 0x0100 Set Protocol: 0x02020109 SendRecv: 0x0403022000 Tới đây thì mình bó tay, không hiều làm sao mà có thể đọc được thông tin ID, tên tài xế, giấy phép lái xe của thẻ RFID Và mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,\u0026hellip; Nhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp. Đọc tín hiệu xung Khi gần như bế tắc thì anh Sơn đã gợi ý là đọc tín hiệu xung. Và mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng board logic analyzer Board này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại phần mềm hỗ trợ cho board này lại cực xịn (đánh giá cá nhân). Từ hình 1 và hình 2 là mình biết rằng những lệnh command ban đầu của mình đã đúng. Tiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế: Cuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi SendRecv thì nó chỉ đọc được số lượng byte nhất định, nên để đọc được hết thông tin thì mình cần gửi: 0x0403022000 0x0403022001 0x0403022002 0x0403022003 0x0403022004 . . . . . . Cứ thế gửi cho đến khi đọc hết thông tin. Nhiệm vụ tiếp theo Bây giờ đã rõ hết cấu trúc bản tin. Nhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết. Parse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh. Suy nghĩ: Lúc trước mình có xem một video về các công cụ hardware hacking dành cho việc Firmware Reverse, thì Logic Analyzer là một trong các công cụ đó. Mình thấy một Hardware Engineer công việc cũng giống như một IoT Hacker, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế. Chỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,\u0026hellip; Mình có thể mường tưởng ra cách Trung Quốc họ copy: Mua sản phẩm Kiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng) Dịch ngược bằng cách: bắt tín hiệu xung, dump firmware. Đến bây giờ mình mới có thể hiểu. =]] ",
      "content_html": "\u003ch3 id=\"giới-thiệu\"\u003eGiới thiệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCR95\u003c/strong\u003e là dòng chip dùng để đọc \u003cstrong\u003eRFID\u003c/strong\u003e và \u003cstrong\u003eNFC\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCác thiết bị Giám sát hành trình theo \u003cstrong\u003eQCVN31\u003c/strong\u003e đều phải có bộ RFID, để đọc thẻ tài xế.\u003c/li\u003e\n\u003cli\u003eCông ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại \u003cstrong\u003eIC CR95\u003c/strong\u003e (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"yêu-cầu\"\u003eYêu cầu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART.\u003c/li\u003e\n\u003cli\u003eDùng ngôn ngữ lập trình Rust để viết Firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"research\"\u003eResearch\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là \u003cstrong\u003eSPI\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình cần xem lại \u003ca href=\"https://www.st.com/resource/en/datasheet/cr95hf.pdf\"\u003edatasheet của CR95\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eVề phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"may-mắn-thay\"\u003eMay mắn thay\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSource code\u003c/strong\u003e anh này được viết \u003cstrong\u003ebằng C\u003c/strong\u003e, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một \u003ca href=\"http://www.tme.vn/product.aspx?id=2095#page=pro_info\"\u003eboard phần cứng CR95 khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/CR95HF-BRD.jpg\"\n  alt=\"CR95HF-BRD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eEcho: 0x55\nInfo: 0x0100\nSet Protocol: 0x02020109\nSendRecv: 0x0403022000\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTới đây thì mình \u003cstrong\u003ebó tay\u003c/strong\u003e, không hiều làm sao mà có thể đọc được \u003cstrong\u003ethông tin ID, tên tài xế, giấy phép lái xe\u003c/strong\u003e của thẻ RFID\u003c/li\u003e\n\u003cli\u003eVà mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eNhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"đọc-tín-hiệu-xung\"\u003eĐọc tín hiệu xung\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi gần như bế tắc thì anh Sơn đã gợi ý là \u003cstrong\u003eđọc tín hiệu xung\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng \u003ca href=\"https://hshop.vn/products/mach-usb-saleae-8ch-24mhz-logic-analyzer\"\u003eboard logic analyzer\u003c/a\u003e\n\u003cimg\n  src=\"https://product.hstatic.net/1000069225/product/c583f4e0-da4c-4abe-9e29-16844f44de69_1_201_a_9a3822254fa44d8e9e2fb043ec157eaf_1024x1024.jpg\"\n  alt=\"logic analyzer\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/li\u003e\n\u003cli\u003eBoard này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại \u003ca href=\"https://www.saleae.com/pages/downloads\"\u003ephần mềm hỗ trợ\u003c/a\u003e cho board này lại cực xịn (đánh giá cá nhân).\u003c/li\u003e\n\u003cli\u003eTừ \u003cstrong\u003ehình 1\u003c/strong\u003e và \u003cstrong\u003ehình 2\u003c/strong\u003e là mình biết rằng những lệnh command ban đầu của mình đã đúng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_1.png\"\n  alt=\"CR95-Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_2.png\"\n  alt=\"CR95-Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_3.png\"\n  alt=\"CR95-Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi \u003cstrong\u003eSendRecv\u003c/strong\u003e thì nó chỉ đọc được số lượng \u003cstrong\u003ebyte\u003c/strong\u003e nhất định, nên để đọc được hết thông tin thì mình cần gửi:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e0x0403022000\n0x0403022001\n0x0403022002\n0x0403022003\n0x0403022004\n.\n.\n.\n.\n.\n.\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCứ thế gửi cho đến khi đọc hết thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nhiệm-vụ-tiếp-theo\"\u003eNhiệm vụ tiếp theo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBây giờ đã rõ hết cấu trúc bản tin.\u003c/li\u003e\n\u003cli\u003eNhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết.\u003c/li\u003e\n\u003cli\u003eParse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"suy-nghĩ\"\u003eSuy nghĩ:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước mình có xem một video về các công cụ hardware hacking dành cho việc \u003cstrong\u003eFirmware Reverse\u003c/strong\u003e, thì \u003cstrong\u003eLogic Analyzer\u003c/strong\u003e là một trong các công cụ đó.\u003c/li\u003e\n\u003cli\u003eMình thấy một \u003cstrong\u003eHardware Engineer\u003c/strong\u003e công việc cũng giống như một \u003cstrong\u003eIoT Hacker\u003c/strong\u003e, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế.\u003c/li\u003e\n\u003cli\u003eChỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eMình có thể mường tưởng ra cách Trung Quốc họ copy:\n\u003cul\u003e\n\u003cli\u003eMua sản phẩm\u003c/li\u003e\n\u003cli\u003eKiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng)\u003c/li\u003e\n\u003cli\u003eDịch ngược bằng cách: bắt tín hiệu xung, dump firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐến bây giờ mình mới có thể hiểu. =]]\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/research_cr95/",
      "date_published": "28076-28-09T712:2828:00+07:00",
      "date_modified": "28076-28-09T712:2828:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "3773da73191fa8a6069587b66c683bd684be80dd",
      "title": "Tails_OS",
      "summary": "",
      "content_text": "Ẩn danh - Anonymous Mình có đọc hết cuốn Nghệ Thuật Ẩn Mình, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay. Tựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.\nDùng sóng di động (nói chung là dùng sim4G) Sử dụng VPN, Proxy. Sử dụng Tor Browser Hôm nay khi xem video trên Youtube, thì mình biết đến Tails\nHow To Access the DARK WEB in 2024 (3 Levels) Tails Linux USB with Persistence (Be invisible online in 7 minutes) Tails OS Tails tương tự như việc mình chạy một hệ điều hành song song vậy (và ở đây là trên USB). Bản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như Tor Browser. Như mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,\u0026hellip; Ngay cả khi mình tắt máy, thì những thông tin đó vẫn được lưu trữ trên RAM. Và đây là lúc Tails phát huy ưu điểm nổi bật chính là không lưu trữ bất kỳ thứ gì sau khi tắt máy. Tức là những thao tác trên máy, thông tin hoặc vô tình bị dính malware đều sẽ biến mất hết khi mình rút USB. HAY THẬT Suy nghĩ về Ẩn danh Nói ẩn danh cho vui vậy thôi, chứ nhà nước mà muốn mò ra thì mò cái một. Đơn giản là vì nhà mạng nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là vấn đề thời gian. Do đó nếu muốn ẩn danh thật sự thì tốt nhất đừng làm gì liên quan đến Chính phủ. =]] Mình thì không có nhu cầu vào Dark Web, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên Tails OS vẫn là một biện pháp hay ho khi mình muốn làm gì đó mà không muốn người khác biết. ",
      "content_html": "\u003ch3 id=\"ẩn-danh---anonymous\"\u003eẨn danh - Anonymous\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMình có đọc hết cuốn \u003ca href=\"https://tiki.vn/nghe-thuat-an-minh-p8845822.html\"\u003eNghệ Thuật Ẩn Mình\u003c/a\u003e, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay.\n\u003cimg\n  src=\"https://salt.tikicdn.com/cache/750x750/ts/product/47/4b/45/6386ab1926fd23aad2b93d8f83429769.jpg.webp\"\n  alt=\"Nghệ Thuật Ẩn Mình\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDùng sóng di động (nói chung là \u003cstrong\u003edùng sim4G\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003eSử dụng VPN, Proxy.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003ca href=\"https://www.torproject.org/download/\"\u003eTor Browser\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHôm nay khi xem video trên Youtube, thì mình biết đến \u003ca href=\"https://tails.net/\"\u003eTails\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=U2-JPqrALsA\u0026amp;list=WL\u0026amp;index=2\"\u003eHow To Access the DARK WEB in 2024 (3 Levels)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=gO9fTnMxwYw\"\u003eTails Linux USB with Persistence (Be invisible online in 7 minutes)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tails-os\"\u003eTails OS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTails\u003c/strong\u003e tương tự như việc mình chạy một \u003cstrong\u003ehệ điều hành\u003c/strong\u003e song song vậy (và ở đây là trên USB).\u003c/li\u003e\n\u003cli\u003eBản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như \u003cstrong\u003eTor Browser\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhư mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eNgay cả khi mình tắt máy, thì những thông tin đó vẫn được \u003cstrong\u003elưu trữ trên RAM\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà đây là lúc \u003cstrong\u003eTails\u003c/strong\u003e phát huy ưu điểm nổi bật chính là \u003cstrong\u003ekhông lưu trữ bất kỳ thứ gì sau khi tắt máy\u003c/strong\u003e. Tức là những thao tác trên máy, thông tin hoặc vô tình \u003cstrong\u003ebị dính malware\u003c/strong\u003e đều sẽ biến mất hết khi mình rút USB.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHAY THẬT\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"suy-nghĩ-về-ẩn-danh\"\u003eSuy nghĩ về Ẩn danh\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNói \u003cstrong\u003eẩn danh\u003c/strong\u003e cho vui vậy thôi, chứ nhà nước mà muốn \u003cstrong\u003emò\u003c/strong\u003e ra thì mò cái một. Đơn giản là vì \u003cstrong\u003enhà mạng\u003c/strong\u003e nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là \u003cstrong\u003evấn đề thời gian\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDo đó nếu muốn \u003cstrong\u003eẩn danh thật sự\u003c/strong\u003e thì tốt nhất đừng làm gì liên quan đến \u003cstrong\u003eChính phủ\u003c/strong\u003e. =]]\u003c/li\u003e\n\u003cli\u003eMình thì không có nhu cầu vào \u003cstrong\u003eDark Web\u003c/strong\u003e, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên \u003cstrong\u003eTails OS\u003c/strong\u003e vẫn là một biện pháp hay ho khi mình \u003cstrong\u003emuốn làm gì đó mà không muốn người khác biết\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Google_vs_DuckDuckGo.jpg\"\n  alt=\"Search\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/tails_os/",
      "date_published": "21076-21-09T734:2121:00+07:00",
      "date_modified": "21076-21-09T734:2121:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7966a7585a1eca2b3277bf71ec1d0a822315c7b7",
      "title": "Suy_nghi_ve_Hardware_Hacking",
      "summary": "",
      "content_text": "Sau khi mình đã đọc hết cuốn Vùng tối. Những hacker đời đầu chính là các nhà vật lý, những người kỹ sư, kỹ thuật điện tử.\nKhi thế giới vẫn còn điện tử tương tự, các điệp viên đã dùng các kỹ thuật để chặn, bắt tín hiệu.\nĐể rồi khi thế giới chuyển sang điện tử số, sự ra đời của internet. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,\u0026hellip;\nDạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.\nCũng như trong Show Ryan: What Does a Former Black Hat Hacker Carry Everyday? có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể thu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu. Mình nhớ kỹ thuật này gọi là Relay Atack\nLà một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự quá hay và ghê gớm.\nNgười làm ra những thiết bị này đúng là tay chơi về phần cứng, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.\nLà hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.\nMình cần rèn luyện kỹ năng, và ghi nhớ Hack to learn and not Learn to Hack.\nMột bài viết khác về Hardware hacking - Tấn công HID Tổng hợp các tài liệu về IoT Hacking: https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/ https://v33ru.github.io/IoTSecurity101/ https://github.com/nebgnahz/awesome-iot-hacks https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme https://www.iotpentestingguide.com/ https://p.ost2.fyi/courses IoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.\nCó lẻ vậy.\nTổng hợp các ý hay trong cuốn Vùng tối Nền tảng của Tác chiến Thông tin: Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.\nCNE (Computer Network Exploitation) - Khai thác Mạng máy tính: Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.\n",
      "content_html": "\u003cp\u003eSau khi mình đã đọc hết cuốn \u003ca href=\"https://tiki.vn/khoa-hoc-kham-pha-vung-toi-lich-su-bi-an-cua-chien-tranh-mang-p251393388.html\"\u003eVùng tối\u003c/a\u003e. Những \u003cstrong\u003ehacker đời đầu\u003c/strong\u003e chính là các \u003cstrong\u003enhà vật lý\u003c/strong\u003e, những người \u003cstrong\u003ekỹ sư, kỹ thuật điện tử\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://salt.tikicdn.com/cache/540x540/ts/product/46/60/43/e4ff35baeeaf8bb049e0c864e6132c6b.jpg\"\n  alt=\"Vùng tối - Book\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eKhi thế giới vẫn còn \u003cstrong\u003eđiện tử tương tự\u003c/strong\u003e, các điệp viên đã dùng các kỹ thuật để \u003cstrong\u003echặn, bắt tín hiệu\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐể rồi khi thế giới chuyển sang \u003cstrong\u003eđiện tử số\u003c/strong\u003e, sự ra đời của \u003cstrong\u003einternet\u003c/strong\u003e. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eDạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.\u003c/p\u003e\n\u003cp\u003eCũng như trong \u003ca href=\"https://www.youtube.com/watch?v=7MIoFxwawc0\u0026amp;list=WL\u0026amp;index=4\u0026amp;t=1s\"\u003eShow Ryan: What Does a Former Black Hat Hacker Carry Everyday?\u003c/a\u003e có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể \u003cstrong\u003ethu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu\u003c/strong\u003e. Mình nhớ kỹ thuật này gọi là \u003cstrong\u003eRelay Atack\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLà một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự \u003cstrong\u003equá hay và ghê gớm\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNgười làm ra những thiết bị này đúng là \u003cstrong\u003etay chơi về phần cứng\u003c/strong\u003e, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.\u003c/p\u003e\n\u003cp\u003eLà hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.\u003c/p\u003e\n\u003cp\u003eMình cần rèn luyện kỹ năng, và ghi nhớ \u003cstrong\u003eHack to learn and not Learn to Hack\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"một-bài-viết-khác-về-hardware-hacking---tấn-công-hidhttpswhitehatvnthreadstan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao18012\"\u003e\u003ca href=\"https://whitehat.vn/threads/tan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao.18012/\"\u003eMột bài viết khác về Hardware hacking - Tấn công HID\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-tài-liệu-về-iot-hacking\"\u003eTổng hợp các tài liệu về IoT Hacking:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/\"\u003ehttps://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://v33ru.github.io/IoTSecurity101/\"\u003ehttps://v33ru.github.io/IoTSecurity101/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/nebgnahz/awesome-iot-hacks\"\u003ehttps://github.com/nebgnahz/awesome-iot-hacks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme\"\u003ehttps://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.iotpentestingguide.com/\"\u003ehttps://www.iotpentestingguide.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://p.ost2.fyi/courses\"\u003ehttps://p.ost2.fyi/courses\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.\u003c/p\u003e\n\u003cp\u003eCó lẻ vậy.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Hardware_Hacking.jpg\"\n  alt=\"Hardware Hacking Tools\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"tổng-hợp-các-ý-hay-trong-cuốn-vùng-tối\"\u003eTổng hợp các ý hay trong cuốn \u003cstrong\u003eVùng tối\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eNền tảng của Tác chiến Thông tin:\u003c/strong\u003e Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCNE (Computer Network Exploitation) - Khai thác Mạng máy tính:\u003c/strong\u003e Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/suy_nghi_ve_hardware_hacking/",
      "date_published": "10076-10-09T734:1010:00+07:00",
      "date_modified": "10076-10-09T734:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c4bdccacc5a8e26c6238ec72e87ccc4b188451b2",
      "title": "Goc_nhin_ve_Ngoai_ngu",
      "summary": "",
      "content_text": "Một góc nhìn cá nhân về Ngoại ngữ Là một người thiên về Khoa học Kỹ thuật thì với mình, Ngoại ngữ là một công cụ. Mình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là một cái gì đó. Tại sao mình có suy nghĩ Ngoại ngữ là một công cụ Thú thật thì mình là một đứa ngu ngốc về ngoại ngữ (cụ thể là Anh văn). Chả biết là do mình yếu Anh văn \u0026ndash;\u0026gt; Không coi trọng, hay là vì Không coi trọng \u0026ndash;\u0026gt; Yếu Anh văn ??? Nhưng có một điều chắc chắn là mình biết anh văn quan trọng, nhưng chưa phải là yếu tố quyết định. Mục tiêu của mình đối với Anh văn chỉ đơn giản, đó là cầu nối với kiến thức của nhân loại. Anh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì. Tại sao lại thế? Mình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có sự yêu thích và đam mê nhất định thì mới theo được. Mình cũng vậy, khi có sự yêu thích sẽ dẫn đến nhu cầu tìm hiểu, học hỏi cái mới. Và đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào: Search keyword bằng tiếng anh. Đọc hiểu tài liệu tiếng anh. Đó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân). Một tình huống hài hước khác. Có những lúc đi hội thảo, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh. Có những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày. Nhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu: Ông này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.\nSuy nghĩ khác Nếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì Trời đất, họ sẽ thăng tiến kinh lắm. Chưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là leader, Manager,\u0026hellip; Lương sẽ khủng lắm đây. Mà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.\nNgười ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân.\n",
      "content_html": "\u003ch2 id=\"một-góc-nhìn-cá-nhân-về-ngoại-ngữ\"\u003eMột \u003cstrong\u003egóc nhìn cá nhân\u003c/strong\u003e về Ngoại ngữ\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLà một người thiên về Khoa học Kỹ thuật thì với mình, \u003cstrong\u003eNgoại ngữ là một công cụ\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là \u003cstrong\u003emột cái gì đó\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-mình-có-suy-nghĩ-ngoại-ngữ-là-một-công-cụ\"\u003eTại sao mình có suy nghĩ \u003cstrong\u003eNgoại ngữ là một công cụ\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThú thật thì mình là một đứa \u003cstrong\u003engu ngốc\u003c/strong\u003e về ngoại ngữ (cụ thể là \u003cstrong\u003eAnh văn\u003c/strong\u003e).\u003c/li\u003e\n\u003cli\u003eChả biết là do mình \u003cstrong\u003eyếu Anh văn \u0026ndash;\u0026gt; Không coi trọng\u003c/strong\u003e, hay là vì \u003cstrong\u003eKhông coi trọng \u0026ndash;\u0026gt; Yếu Anh văn\u003c/strong\u003e ???\u003c/li\u003e\n\u003cli\u003eNhưng có một điều chắc chắn là mình biết \u003cstrong\u003eanh văn quan trọng\u003c/strong\u003e, nhưng chưa phải là \u003cstrong\u003eyếu tố quyết định\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMục tiêu của mình đối với Anh văn chỉ đơn giản, đó là \u003cstrong\u003ecầu nối với kiến thức của nhân loại\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eAnh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-lại-thế\"\u003eTại sao lại thế?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có \u003cstrong\u003esự yêu thích và đam mê nhất định\u003c/strong\u003e thì mới theo được.\u003c/li\u003e\n\u003cli\u003eMình cũng vậy, khi có sự yêu thích sẽ dẫn đến \u003cstrong\u003enhu cầu tìm hiểu, học hỏi cái mới\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào:\n\u003cul\u003e\n\u003cli\u003eSearch keyword bằng tiếng anh.\u003c/li\u003e\n\u003cli\u003eĐọc hiểu tài liệu tiếng anh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-tình-huống-hài-hước-khác\"\u003eMột tình huống hài hước khác.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó những lúc đi \u003cstrong\u003ehội thảo\u003c/strong\u003e, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh.\u003c/li\u003e\n\u003cli\u003eCó những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày.\u003c/li\u003e\n\u003cli\u003eNhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eÔng này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"suy-nghĩ-khác\"\u003eSuy nghĩ khác\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì \u003cstrong\u003eTrời đất, họ sẽ thăng tiến kinh lắm\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eChưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là \u003cstrong\u003eleader\u003c/strong\u003e, \u003cstrong\u003eManager\u003c/strong\u003e,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eLương sẽ khủng lắm đây.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNgười ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân\u003c/strong\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/goc_nhin_ve_ngoai_ngu/",
      "date_published": "7076-07-09T73:77:00+07:00",
      "date_modified": "7076-07-09T73:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4fa8cc860c52b268dc6a3adcde7305e9415db5bb",
      "title": "Tools",
      "summary": "",
      "content_text": "Tool: Git-Dumper Trong quá trình recon một trang web, mà mình thấy có đường dẫn .git Thì có thể dùng tool git-dumper này để lấy thông tin. Tool Web Check Đây là một công cụ có thể sử dụng online, hoặc build ở local. Công cụ này giúp mình recon những thông số cơ bản của một trang web. Tài liệu: 1. https://github.com/lissy93/web-check 2. https://web-check.xyz/about#api-documentation Caido Công cụ này có chức năng tương tự như Burp-Suite, nhưng mà là ở giao diện Web. Tham khảo Youtube: How to Hack Web Apps with Caido Tài liệu: Docs Github Project Cuckoo Sandbox https://cuckoosandbox.org/download https://cuckoo.sh/docs/ https://cuckoo.sh/docs/installation/host/requirements.html https://cuckoosandbox.org/blog/207-interim-release Bunkerweb - WAF https://github.com/bunkerity/bunkerweb https://www.bunkerweb.io/ https://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview https://demo.bunkerweb.io/ https://www.youtube.com/@bunkerity4183/videos Duplicati Youtube: Backup in Linux Servers - Docker Volumes, and Databases Theo như video, thì ở đây sử dụng một open-source tên là duplicati Documents của Duplicati Cài đặt Duplicati bằng Docker linuxserver/duplicati duplicati-tutorial Script thực hiện việc auto-backup Tham khảo khác Nettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management Github Project: Nettacker Documents: https://owasp.org/www-project-nettacker/ Note: Nhìn chung mình thấy tool này khá giống với tool reNgine, hoặc một số công cụ auto-scan khác. AESCrypt: Công cụ mã hóa file Đây là một phần mềm mã nguồn mở, hỗ trợ mã hóa file. Video giới thiệu về công cụ này: AESCrypt - Mã hoá file Một bài viết khác ",
      "content_html": "\u003ch3 id=\"tool-git-dumperhttpsgithubcomarthaudgit-dumper\"\u003e\u003ca href=\"https://github.com/arthaud/git-dumper\"\u003eTool: Git-Dumper\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình \u003cstrong\u003erecon\u003c/strong\u003e một trang web, mà mình thấy có đường dẫn \u003ccode\u003e.git\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThì có thể dùng tool \u003cstrong\u003egit-dumper\u003c/strong\u003e này để lấy thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tool-web-checkhttpsweb-checkxyz\"\u003e\u003ca href=\"https://web-check.xyz/\"\u003eTool Web Check\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ có thể sử dụng online, hoặc build ở local.\u003c/li\u003e\n\u003cli\u003eCông cụ này giúp mình recon những thông số cơ bản của một trang web.\u003c/li\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. https://github.com/lissy93/web-check\n2. https://web-check.xyz/about#api-documentation\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"caidohttpscaidoio\"\u003e\u003ca href=\"https://caido.io/\"\u003eCaido\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này có chức năng tương tự như \u003cstrong\u003eBurp-Suite\u003c/strong\u003e, nhưng mà là ở \u003cstrong\u003egiao diện Web\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=5Di0VVK9JiQ\u0026amp;list=WL\u0026amp;index=2\"\u003eTham khảo Youtube: How to Hack Web Apps with Caido\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.caido.io/\"\u003eDocs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/caido\"\u003eGithub Project\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"cuckoo-sandbox\"\u003eCuckoo Sandbox\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://cuckoosandbox.org/download\nhttps://cuckoo.sh/docs/\nhttps://cuckoo.sh/docs/installation/host/requirements.html\nhttps://cuckoosandbox.org/blog/207-interim-release\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"bunkerweb---waf\"\u003eBunkerweb - WAF\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/bunkerity/bunkerweb\"\u003ehttps://github.com/bunkerity/bunkerweb\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.bunkerweb.io/\"\u003ehttps://www.bunkerweb.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview\"\u003ehttps://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://demo.bunkerweb.io/\"\u003ehttps://demo.bunkerweb.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/@bunkerity4183/videos\"\u003ehttps://www.youtube.com/@bunkerity4183/videos\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"duplicati\"\u003eDuplicati\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=JoA6Bezgk1c\u0026amp;list=WL\u0026amp;index=107\"\u003eYoutube: Backup in Linux Servers - Docker Volumes, and Databases\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTheo như video, thì ở đây sử dụng một open-source tên là \u003ca href=\"https://www.duplicati.com/download\"\u003eduplicati\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://duplicati.readthedocs.io/en/latest/01-introduction/\"\u003eDocuments của Duplicati\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"cài-đặt-duplicati-bằng-docker\"\u003eCài đặt Duplicati bằng Docker\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.linuxserver.io/images/docker-duplicati\"\u003elinuxserver/duplicati\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/christianlempa/videos/tree/main/duplicati-tutorial\"\u003eduplicati-tutorial\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"script-thực-hiện-việc-auto-backuphttpsgithubcomchristianlempascriptstreemaindb-container-backup\"\u003e\u003ca href=\"https://github.com/ChristianLempa/scripts/tree/main/db-container-backup\"\u003eScript thực hiện việc auto-backup\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=wvsi3QilNQ8\"\u003eTham khảo khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nettacker-automated-penetration-testing-framework---open-source-vulnerability-scanner---vulnerability-management\"\u003eNettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGithub Project: \u003ca href=\"https://github.com/OWASP/Nettacker\"\u003eNettacker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocuments: \u003ca href=\"https://owasp.org/www-project-nettacker/\"\u003ehttps://owasp.org/www-project-nettacker/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Nhìn chung mình thấy tool này khá giống với tool \u003cstrong\u003ereNgine\u003c/strong\u003e, hoặc một số công cụ auto-scan khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"aescrypthttpswwwaescryptcom-công-cụ-mã-hóa-file\"\u003e\u003ca href=\"https://www.aescrypt.com/\"\u003eAESCrypt\u003c/a\u003e: Công cụ mã hóa file\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một phần mềm \u003cstrong\u003emã nguồn mở\u003c/strong\u003e, hỗ trợ mã hóa file.\u003c/li\u003e\n\u003cli\u003eVideo giới thiệu về công cụ này: \u003ca href=\"https://www.youtube.com/watch?v=zA4dDlslDXo\"\u003eAESCrypt - Mã hoá file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://services.udel.edu/TDClient/32/Portal/KB/ArticleDet?ID=366\"\u003eMột bài viết khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/tools/",
      "date_published": "6076-06-09T736:66:00+07:00",
      "date_modified": "6076-06-09T736:66:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "101ddf258848dd5a99a97fc806696d3b87397047",
      "title": "RedTeam",
      "summary": "",
      "content_text": "5 free red teaming resources to get you started Red Team Notes Red Teaming Handbook Red Team Tools Red Teaming Toolkit ",
      "content_html": "\u003ch3 id=\"5-free-red-teaming-resources-to-get-you-startedhttpswwwhelpnetsecuritycom20240416free-red-teaming-resources\"\u003e\u003ca href=\"https://www.helpnetsecurity.com/2024/04/16/free-red-teaming-resources/\"\u003e5 free red teaming resources to get you started\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dmcxblue.gitbook.io/red-team-notes-2-0\"\u003eRed Team Notes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://assets.publishing.service.gov.uk/media/61702155e90e07197867eb93/20210625-Red_Teaming_Handbook.pdf\"\u003eRed Teaming Handbook\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/A-poc/RedTeam-Tools\"\u003eRed Team Tools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/infosecn1nja/Red-Teaming-Toolkit\"\u003eRed Teaming Toolkit\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/redteam/",
      "date_published": "15066-15-09T65:1515:00+07:00",
      "date_modified": "15066-15-09T65:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4f09e909e9a87e6f4fa1e981ddc482695a0ed92a",
      "title": "TheHive",
      "summary": "",
      "content_text": " Theo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình: Phát hiện Báo cáo Xử lý Công cụ TheHive là nằm trong giai đoạn 2. Ví dụ dễ hiểu như sau: Khi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này. Nếu không xử lý được, hoặc mức độ phức tạp cao thì tạo Ticket mô tả và cung cấp đầy đủ thông tin. (Giai đoạn này là bước sử dụng TheHive). Người có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý. TheHive TheHive cũng có chức năng như JIRA, tuy nhiên TheHive là open-source. Documents: - https://thehive-project.org/ - http://docs.thehive-project.org/cortex/ - https://github.com/thehive-project/Cortex/ - https://blog.thehive-project.org/ - https://docs.thehive-project.org/ - https://github.com/TheHive-Project/Cortex Tham khảo TheHive với Graylog - https://blog.reconinfosec.com/integrating-graylog-with-thehive - https://github.com/ReconInfoSec/graylog2thehive ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eTheo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình:\n\u003cul\u003e\n\u003cli\u003ePhát hiện\u003c/li\u003e\n\u003cli\u003eBáo cáo\u003c/li\u003e\n\u003cli\u003eXử lý\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCông cụ \u003cstrong\u003eTheHive\u003c/strong\u003e là nằm trong giai đoạn 2.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ví-dụ-dễ-hiểu-như-sau\"\u003eVí dụ dễ hiểu như sau:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này.\u003c/li\u003e\n\u003cli\u003eNếu không xử lý được, hoặc mức độ phức tạp cao thì tạo \u003cstrong\u003eTicket\u003c/strong\u003e mô tả và cung cấp đầy đủ thông tin.\n(Giai đoạn này là bước sử dụng \u003cstrong\u003eTheHive\u003c/strong\u003e).\u003c/li\u003e\n\u003cli\u003eNgười có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"thehive\"\u003eTheHive\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTheHive cũng có chức năng như \u003cstrong\u003eJIRA\u003c/strong\u003e, tuy nhiên TheHive là \u003cstrong\u003eopen-source\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDocuments:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- https://thehive-project.org/\n- http://docs.thehive-project.org/cortex/\n- https://github.com/thehive-project/Cortex/\n- https://blog.thehive-project.org/\n- https://docs.thehive-project.org/\n- https://github.com/TheHive-Project/Cortex\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tham-khảo-thehive-với-graylog\"\u003eTham khảo TheHive với Graylog\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- https://blog.reconinfosec.com/integrating-graylog-with-thehive\n- https://github.com/ReconInfoSec/graylog2thehive\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/thehive/",
      "date_published": "15066-15-09T64:1515:00+07:00",
      "date_modified": "15066-15-09T64:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d301d9e6e4aeff77c37f37bb07966a98039f0832",
      "title": "OSINT",
      "summary": "",
      "content_text": "OSINT - Open Source Intelligence Bước đầu tiên trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là thu thập các thông tin giá trị về mục tiêu. Thu thập thông tin thì có 2 dạng là: Passive Reconnaissance - Thu thập thông tin thụ động Active Reconnaissance - Thu thập thông tin chủ động Trong đó việc thu thập thông tin thụ động thường được gọi là OSINT. Bất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí. Others Documents https://www.hackers-arise.com/osint Top 10 công cụ OSINT tốt nhất 2020 Một số công cụ theo OSINT Framework mà mình biết: VirusTotal Shodan Wayback Machine ANY.RUN ",
      "content_html": "\u003ch3 id=\"osint---open-source-intelligencehttpsanonyvietcomosint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet\"\u003e\u003ca href=\"https://anonyviet.com/osint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet/\"\u003eOSINT - Open Source Intelligence\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBước đầu tiên\u003c/strong\u003e trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là \u003cstrong\u003ethu thập các thông tin\u003c/strong\u003e giá trị về mục tiêu.\u003c/li\u003e\n\u003cli\u003eThu thập thông tin thì có 2 dạng là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePassive Reconnaissance - Thu thập thông tin thụ động\nActive Reconnaissance - Thu thập thông tin chủ động\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTrong đó việc \u003cstrong\u003ethu thập thông tin thụ động\u003c/strong\u003e thường được gọi là \u003cstrong\u003eOSINT\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eBất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"others-documents\"\u003eOthers Documents\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.hackers-arise.com/osint\"\u003ehttps://www.hackers-arise.com/osint\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://anonyviet.com/cac-tool-osint-truy-vet-toi-pham-tren-internet/\"\u003eTop 10 công cụ OSINT tốt nhất 2020\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-số-công-cụ-theo-osint-frameworkhttpsosintframeworkcom-mà-mình-biết\"\u003eMột số công cụ theo \u003ca href=\"https://osintframework.com/\"\u003eOSINT Framework\u003c/a\u003e mà mình biết:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.virustotal.com/gui/home/upload\"\u003eVirusTotal\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.shodan.io/\"\u003eShodan\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://archive.org/web/\"\u003eWayback Machine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://any.run/\"\u003eANY.RUN\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/osint/",
      "date_published": "15066-15-09T62:1515:00+07:00",
      "date_modified": "15066-15-09T62:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c63929f0d793b4d6bd0bdcf6149015836543e3ec",
      "title": "ESD",
      "summary": "",
      "content_text": "ESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện Là dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.\nĐây là một video nói về cách chống tĩnh điện, dựa trên các linh kiện:\nTVS - Transient Voltage Suppressor MOV - Metal Oxide Varistor GDT - Gas Discharge Tube TVS Diode Một video giải thích cách hoạt động của TVS Diode\nTrong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.\nMột ví dụ về linh kiện TVS, Semtech SMF05C.TCT\nMOV Linh kiện Bourns MOV-10D470KKTR GDT Linh kiện Bourns GDT25-47-S1-RP ",
      "content_html": "\u003ch2 id=\"esd-electrostatic-sensitive-devices---sự-phóng-tĩnh-điện\"\u003eESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLà dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eĐây là một \u003ca href=\"https://www.youtube.com/watch?v=MzxBBXpgwrE\"\u003evideo\u003c/a\u003e nói về cách \u003cstrong\u003echống tĩnh điện\u003c/strong\u003e, dựa trên các linh kiện:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eTVS - Transient Voltage Suppressor\nMOV - Metal Oxide Varistor\nGDT - Gas Discharge Tube\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tvs-diode\"\u003eTVS Diode\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=oKACLpBYhxU\"\u003eMột video giải thích cách hoạt động của TVS Diode\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMột ví dụ về linh kiện TVS, \u003ca href=\"https://www.mouser.vn/ProductDetail/Semtech/SMF05C.TCT?qs=rBWM4%252BvDhIcdGOAFdL4XAA%3D%3D\u0026amp;_gl=1*109bc2w*_ga*ODE4NDU2NjY3LjE3MTM3NzI5OTI.*_ga_15W4STQT4T*MTcxMzc3Mjk5Mi4xLjAuMTcxMzc3Mjk5My41OS4wLjA.\"\u003eSemtech SMF05C.TCT\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mov\"\u003eMOV\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLinh kiện \u003ca href=\"https://www.mouser.vn/ProductDetail/Bourns/MOV-10D470KKTR?qs=ST9lo4GX8V0v1uLdRAW6Kg%3D%3D\u0026amp;_gl=1*17bo42l*_ga*MTY3MzQ3NTE2Ni4xNzEzNzcyOTg0*_ga_15W4STQT4T*MTcxMzc3Mjk4My4xLjEuMTcxMzc3Mjk5MC41My4wLjA.\"\u003eBourns MOV-10D470KKTR\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"gdt\"\u003eGDT\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLinh kiện \u003ca href=\"https://www.mouser.vn/ProductDetail/Bourns/GDT25-47-S1-RP?qs=2MMvu9PpTS3BszAgeO7ppQ%3D%3D\"\u003eBourns GDT25-47-S1-RP\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/ESD_Electronics.png\"\n  alt=\"ESD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/esd/",
      "date_published": "25056-25-09T559:2525:00+07:00",
      "date_modified": "25056-25-09T559:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "fd7800093460ca577e6a1fdff2b8aa97568c6540",
      "title": "DFLab_VNCERT",
      "summary": "",
      "content_text": "Bài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC)) Bài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích log. Trong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân: Hayabusa Hayabusa là một công cụ xử lý nhanh Windows Event Log, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v\u0026hellip;\nGoAccess GoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.\nGet Started GoAccess\nHow to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04\n",
      "content_html": "\u003ch2 id=\"bài-viết---công-cụ-điều-tra-nhật-ký-sự-kiện-của-digital-forensics-lab---cục-an-toàn-thông-tin-vncertcchttpsdfirlabvndocstoolslog\"\u003e\u003ca href=\"https://df.irlab.vn/docs/tools/log/\"\u003eBài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC))\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eBài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích \u003cstrong\u003elog\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTrong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hayabusahttpsgithubcomyamato-securityhayabusa\"\u003e\u003ca href=\"https://github.com/Yamato-Security/hayabusa\"\u003eHayabusa\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHayabusa là một công cụ xử lý nhanh \u003cstrong\u003eWindows Event Log\u003c/strong\u003e, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v\u0026hellip;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"goaccesshttpsgithubcomallinurlgoaccess\"\u003e\u003ca href=\"https://github.com/allinurl/goaccess\"\u003eGoAccess\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://goaccess.io/get-started\"\u003eGet Started GoAccess\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=PbKpdHeuG2A\"\u003eHow to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/dflab_vncert/",
      "date_published": "25056-25-09T556:2525:00+07:00",
      "date_modified": "25056-25-09T556:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8ab10c1348d533258955d2c165104e8fc6b6fb36",
      "title": "Firewall_CheckList",
      "summary": "",
      "content_text": "Có thể coi Firewall Checklist là phương pháp để mình Pentest Network Dùng các công cụ để test hạ tầng Network: Nmap Ettercap Firewalk Wireshark Check version của Firewall + CVE, tìm các cách khắc phục. Dựa vào file Firewall_Checklist để áp dụng cách đặt rule. Documents Firewall_Checklist ",
      "content_html": "\u003ch3 id=\"có-thể-coi-firewall-checklist-là-phương-pháp-để-mình-pentest-network\"\u003eCó thể coi \u003ccode\u003eFirewall Checklist\u003c/code\u003e là phương pháp để mình Pentest Network\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng các công cụ để test hạ tầng Network:\n\u003cul\u003e\n\u003cli\u003eNmap\u003c/li\u003e\n\u003cli\u003eEttercap\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kali.org/tools/firewalk/\"\u003eFirewalk\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eWireshark\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCheck version của Firewall + CVE, tìm các cách khắc phục.\u003c/li\u003e\n\u003cli\u003eDựa vào file \u003cstrong\u003eFirewall_Checklist\u003c/strong\u003e để áp dụng cách đặt rule.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"documents-firewall_checklistdocsfirewallchecklistpdf\"\u003e\u003ca href=\"/docs/FirewallChecklist.pdf\"\u003eDocuments Firewall_Checklist\u003c/a\u003e\u003c/h3\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Firewall_Cheatsheet.jpg\"\n  alt=\"Firewall Checklist\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/firewall_checklist/",
      "date_published": "25056-25-09T548:2525:00+07:00",
      "date_modified": "25056-25-09T548:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a8e9a70dc4d226a2d6960103dadfbaf851de55b7",
      "title": "NIS2",
      "summary": "",
      "content_text": "Bài viết: Tuân thủ NIS2 cho các mạng công nghiệp NIS2 Compliance for Industries White Paper Tổng hợp các thông tin cần biết trong bài viết: Các phần tử kết nối mạng OT cần được chứng nhận an toàn:\nCác tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì. Vì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên. Đánh giá và xếp loại ưu tiên các rủi ro mạng OT:\nNhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ. NIS2 yêu cầu bạn có khả năng \u0026ldquo;nhìn xuyên thấu\u0026rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh. Triển khai Zero-trust:\nHầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2. Lưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn. ISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có. Đây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng. Triển khai Zero-trust remote access:\nThay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop\u0026hellip;) Hãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập. Phát hiện và báo cáo sự cố: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.\n",
      "content_html": "\u003ch2 id=\"bài-viết-tuân-thủ-nis2-cho-các-mạng-công-nghiệphttpswhitehatvnthreadstuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua17872\"\u003e\u003ca href=\"https://whitehat.vn/threads/tuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua.17872/\"\u003eBài viết: Tuân thủ NIS2 cho các mạng công nghiệp\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"nis2-compliance-for-industries-white-paperhttpswwwciscocomcenusproductscollateralsecurityindustrial-securitynetwork-info-security-wppdf\"\u003e\u003ca href=\"https://www.cisco.com/c/en/us/products/collateral/security/industrial-security/network-info-security-wp.pdf\"\u003eNIS2 Compliance for Industries White Paper\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-thông-tin-cần-biết-trong-bài-viết\"\u003eTổng hợp các thông tin cần biết trong bài viết:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCác phần tử kết nối mạng OT cần được chứng nhận an toàn\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCác tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì.\u003c/li\u003e\n\u003cli\u003eVì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eĐánh giá và xếp loại ưu tiên các rủi ro mạng OT\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ.\u003c/li\u003e\n\u003cli\u003eNIS2 yêu cầu bạn có khả năng \u0026ldquo;nhìn xuyên thấu\u0026rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTriển khai Zero-trust\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2.\u003c/li\u003e\n\u003cli\u003eLưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn.\u003c/li\u003e\n\u003cli\u003eISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có.\u003c/li\u003e\n\u003cli\u003eĐây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTriển khai Zero-trust remote access\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop\u0026hellip;)\u003c/li\u003e\n\u003cli\u003eHãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePhát hiện và báo cáo sự cố\u003c/strong\u003e: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/IoT_Security.jpg\"\n  alt=\"IoT Security\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/nis2/",
      "date_published": "25056-25-09T543:2525:00+07:00",
      "date_modified": "25056-25-09T543:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4cce4220308fd2f1f01e3e19db45c5f96e482829",
      "title": "Raspberry OpenAuto",
      "summary": "",
      "content_text": "OpenAuto Link\nSource\nTheo như mình hiểu thì OpenAuto, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.\nHình như CrankShaft cũng từ open source của OpenAuto mà ra.\nTham khảo\nVideo tham khảo https://www.youtube.com/watch?v=RgbHXTHUnQw https://www.youtube.com/watch?v=ko-udLtaPk8 ",
      "content_html": "\u003ch3 id=\"openauto\"\u003eOpenAuto\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://bluewavestudio.io/#features\"\u003eLink\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"9https://bluewavestudio.io/community/showthread.php?tid=2774\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTheo như mình hiểu thì \u003cstrong\u003eOpenAuto\u003c/strong\u003e, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHình như \u003cstrong\u003eCrankShaft\u003c/strong\u003e cũng từ open source của \u003cstrong\u003eOpenAuto\u003c/strong\u003e mà ra.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/f1xpl/openauto/wiki\"\u003eTham khảo\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"video-tham-khao\"\u003eVideo tham khảo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=RgbHXTHUnQw\"\u003ehttps://www.youtube.com/watch?v=RgbHXTHUnQw\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=ko-udLtaPk8\"\u003ehttps://www.youtube.com/watch?v=ko-udLtaPk8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/raspberry-openauto/",
      "date_published": "1046-01-09T457:11:00+07:00",
      "date_modified": "1046-01-09T457:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "0bf57abd5b47956c7b4a48e0064a549fbeba3877",
      "title": "Pi400 Keyboard",
      "summary": "",
      "content_text": "Sử dụng Raspberry Pi400 như một bàn phím thông thường. https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/ https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard https://github.com/Gadgetoid/pi400kb/tree/main ",
      "content_html": "\u003ch3 id=\"sử-dụng-raspberry-pi400-như-một-bàn-phím-thông-thường\"\u003eSử dụng Raspberry Pi400 như một bàn phím thông thường.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/\"\u003ehttps://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard\"\u003ehttps://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Gadgetoid/pi400kb/tree/main\"\u003ehttps://github.com/Gadgetoid/pi400kb/tree/main\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.cytron.io/image/landing/RPI%20400/photo_2020-10-31_11-28-37.jpg\"\n  alt=\"Pi400\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/pi400-keyboard/",
      "date_published": "1046-01-09T453:11:00+07:00",
      "date_modified": "1046-01-09T453:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1467c592c4f59f946735e658ee5827f9a222c791",
      "title": "PiKVM",
      "summary": "",
      "content_text": "PiKVM Theo tài liệu thì KVM (Keyboard-Video-Mouse), tức là PiKVM là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP. Tức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần: Màn hình để xuất hình ảnh. Chuột và bàn phím để điều khiển. Với PiKVM nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua WebUI. PiKVM lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa. Thông thường nếu chỉ dùng Anydesk, TeamViewer,\u0026hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất. Vậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của PiKVM. Tham khảo video https://www.youtube.com/watch?v=2HqbQdZUEmY https://www.youtube.com/watch?v=PppcpSVYh0E https://www.youtube.com/watch?v=KrpHCsK7veA Documents https://docs.pikvm.org/ https://pikvm.org/ https://wiki.geekworm.com/PiKVM Note PiKVM có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image. Cần thêm module covert từ HDMI - CSI ",
      "content_html": "\u003ch3 id=\"pikvmhttpsgithubcompikvmpikvm\"\u003e\u003ca href=\"https://github.com/pikvm/pikvm\"\u003ePiKVM\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo tài liệu thì \u003cstrong\u003eKVM (Keyboard-Video-Mouse)\u003c/strong\u003e, tức là \u003cstrong\u003ePiKVM\u003c/strong\u003e là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP.\u003c/li\u003e\n\u003cli\u003eTức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần:\n\u003cul\u003e\n\u003cli\u003eMàn hình để xuất hình ảnh.\u003c/li\u003e\n\u003cli\u003eChuột và bàn phím để điều khiển.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eVới \u003cstrong\u003ePiKVM\u003c/strong\u003e nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua \u003cstrong\u003eWebUI\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePiKVM\u003c/strong\u003e lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa.\u003c/li\u003e\n\u003cli\u003eThông thường nếu chỉ dùng Anydesk, TeamViewer,\u0026hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất.\u003c/li\u003e\n\u003cli\u003eVậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của \u003cstrong\u003ePiKVM\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tham-khảo-video\"\u003eTham khảo video\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=2HqbQdZUEmY\"\u003ehttps://www.youtube.com/watch?v=2HqbQdZUEmY\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=PppcpSVYh0E\"\u003ehttps://www.youtube.com/watch?v=PppcpSVYh0E\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=KrpHCsK7veA\"\u003ehttps://www.youtube.com/watch?v=KrpHCsK7veA\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"documents\"\u003eDocuments\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.pikvm.org/\"\u003ehttps://docs.pikvm.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pikvm.org/\"\u003ehttps://pikvm.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://wiki.geekworm.com/PiKVM\"\u003ehttps://wiki.geekworm.com/PiKVM\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePiKVM\u003c/strong\u003e có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.waveshare.com/wiki/HDMI_to_CSI_Adapter\"\u003eCần thêm module covert từ HDMI - CSI\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/pikvm/",
      "date_published": "1046-01-09T449:11:00+07:00",
      "date_modified": "1046-01-09T449:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "571f7a701d03049f4c4b93851c869e0c14023691",
      "title": "UNIHIKER",
      "summary": "",
      "content_text": "Documents Getting Started with UNIHIKER Dfrobot Sản phẩm ",
      "content_html": "\u003ch3 id=\"documents\"\u003eDocuments\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.unihiker.com/wiki/get-started\"\u003eGetting Started with UNIHIKER\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.dfrobot.com/product-2691.html\"\u003eDfrobot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sản-phẩmhttpswwwproevnunihiker-iot-python-programming-single-board-computer-with-touchscreen\"\u003e\u003ca href=\"https://www.proe.vn/unihiker-iot-python-programming-single-board-computer-with-touchscreen\"\u003eSản phẩm\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://cdn.mos.cms.futurecdn.net/KRLwXFfy86ybfwUdzxmaFm-1200-80.jpg\"\n  alt=\"SP\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/unihiker/",
      "date_published": "1046-01-09T434:11:00+07:00",
      "date_modified": "1046-01-09T434:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    }
    
  ]
}