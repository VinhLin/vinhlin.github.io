{
  "version": "https://jsonfeed.org/version/1",
  "title": "VinhLin",
  "home_page_url": "https://vinhlin.github.io/",
  "feed_url": "https://vinhlin.github.io/feed.json",
  "description": "Technology Blog",
  "favicon": "https://vinhlin.github.io//assets/favicon.ico",
  "expired": false,
  "author": {
    "name": "VinhLD",
    "url": "https://vinhlin.github.io/"
  },
  "items": [
    
    

    
    {
      "id": "57d9cd14495a931faebdde0b0ad119e84b097c7f",
      "title": "Tong_hop_AI_Tools",
      "summary": "",
      "content_text": "Mình đã từng có bài viết ghi chú về Các công cụ AI mà bản thân đang dùng. Tham khảo\nSau đây bài viết này mình sẽ tổng hợp lại các công cụ khác, các công cụ online, offline hoặc các nền tảng khác.\nTranslation văn bản WPS-AI Video tham khảo, Tôi Đã Xoá Microsoft Office… Vì WPS Quá ĐỈNH! (Tích Hợp AI + Miễn Phí) Tài liệu khác: https://vi.wps.com/create-with-ai/what-is-wps-ai-and-how-to-download/\nAnyDoc Translator Tổng hợp các dự án Dịch thuật tài liệu: PDF Translator for Human GitHub Link: davideuler/pdf-translator-for-human Mô tả ngắn gọn: Công cụ dịch PDF “dành cho con người đọc”, hiển thị song song bản gốc và bản dịch, cực kỳ tiện. Tính năng nổi bật liên quan đến PDF \u0026amp; AI: Dịch từng trang (on-demand) Hỗ trợ Ollama, llama.cpp, MLX (chạy local 100%) ChatGPT, DeepSeek, Gemini Giao diện Streamlit đẹp Giữ layout tốt PDFMathTranslate GitHub Link: Byaidu/PDFMathTranslate Mô tả ngắn gọn: Chuyên dịch bài báo khoa học, luận văn, tài liệu toán học (giữ công thức LaTeX hoàn hảo). Tính năng nổi bật liên quan đến PDF \u0026amp; AI: Layout detection bằng YOLO Dịch bằng GPT-4o, DeepL, Ollama, Qwen CLI + GUI + Docker + plugin Zotero Đa luồng, rất nhanh BabelDOC GitHub Link: funstory-ai/BabelDOC Mô tả ngắn gọn: Thư viện Python dịch PDF song ngữ (Anh ↔ Trung/Việt), hỗ trợ cả PDF scan. Tính năng nổi bật liên quan đến PDF \u0026amp; AI: Dùng bất kỳ LLM nào tương thích OpenAI (gpt-4o-mini, Qwen, DeepSeek, v.v.) Glossary tùy chỉnh Output song ngữ hoặc chỉ bản dịch OCR workaround OpenAI Translator GitHub Link: DjangoPeng/openai-translator Mô tả ngắn gọn: Ứng dụng desktop chuyên dịch sách PDF tiếng Anh → tiếng Trung (có thể đổi sang tiếng Việt). Tính năng nổi bật liên quan đến PDF \u0026amp; AI: GUI đơn giản Tự động retry khi lỗi Hỗ trợ ChatGLM local Đang phát triển giữ layout tốt hơn Zotero PDF Translate (plugin) GitHub Link: windingwind/zotero-pdf-translate Mô tả ngắn gọn: Plugin Zotero cực mạnh, dịch ngay trong thư viện tài liệu khoa học. Tính năng nổi bật liên quan đến PDF \u0026amp; AI: Hỗ trợ 20+ engine (GPT, Gemini, Claude, DeepL, Qwen, Ollama, v.v.) Dịch text chọn, annotation, metadata Pop-up song ngữ LingoLift PDF Translator GitHub Link: lingolift/pdf-translator Mô tả ngắn gọn: Ứng dụng GUI nhẹ, đẹp, dành cho người dùng phổ thông. Tính năng nổi bật liên quan đến PDF \u0026amp; AI: Giao diện hiện đại (Electron/Tauri) Dịch nhanh bằng Google Translate hoặc LLM local Tự động phát hiện ngôn ngữ Speech to Text Tham khảo: https://platform.openai.com/docs/guides/speech-to-text Tạo Video Tham khảo bài viết về HeyGen AI Mã nguồn mở Open Notebook Dự án mã nguồn mở, tương tự như NotebookLM của Google. Với dự án này có thể tận dụng với API của các mô hình AI khác. Tài liệu: Github project Docs ",
      "content_html": "\u003cp\u003eMình đã từng có bài viết ghi chú về \u003cstrong\u003eCác công cụ AI\u003c/strong\u003e mà bản thân đang dùng. \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/others/cong_cu_ai/\"\u003eTham khảo\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eSau đây bài viết này mình sẽ tổng hợp lại các công cụ khác, \u003cem\u003e\u003cstrong\u003ecác công cụ online, offline hoặc các nền tảng khác\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"translation-văn-bản\"\u003eTranslation văn bản\u003c/h2\u003e\n\u003ch3 id=\"wps-aihttpswwwwpsai\"\u003e\u003ca href=\"https://www.wps.ai/\"\u003eWPS-AI\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVideo tham khảo, \u003ca href=\"https://www.youtube.com/watch?v=izQn-zgmN-Q\u0026amp;pp=ygUHV1BTLUFJIA%3D%3D\"\u003eTôi Đã Xoá Microsoft Office… Vì WPS Quá ĐỈNH! (Tích Hợp AI + Miễn Phí)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"https://vi.wps.com/create-with-ai/what-is-wps-ai-and-how-to-download/\"\u003ehttps://vi.wps.com/create-with-ai/what-is-wps-ai-and-how-to-download/\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"anydoc-translatorhttpsanydoctranslatortoolsmartaipricingpositiontop_bar_pricing\"\u003e\u003ca href=\"https://anydoctranslator.toolsmart.ai/pricing?position=top_bar_pricing\"\u003eAnyDoc Translator\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-dự-án-dịch-thuật-tài-liệu\"\u003eTổng hợp các dự án Dịch thuật tài liệu:\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePDF Translator for Human\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Link:\u003c/strong\u003e \u003ca href=\"https://github.com/davideuler/pdf-translator-for-human\"\u003edavideuler/pdf-translator-for-human\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMô tả ngắn gọn:\u003c/strong\u003e Công cụ dịch PDF “dành cho con người đọc”, hiển thị song song bản gốc và bản dịch, cực kỳ tiện.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTính năng nổi bật liên quan đến PDF \u0026amp; AI:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eDịch từng trang (on-demand)\u003c/li\u003e\n\u003cli\u003eHỗ trợ Ollama, llama.cpp, MLX (chạy local 100%)\u003c/li\u003e\n\u003cli\u003eChatGPT, DeepSeek, Gemini\u003c/li\u003e\n\u003cli\u003eGiao diện Streamlit đẹp\u003c/li\u003e\n\u003cli\u003eGiữ layout tốt\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003ePDFMathTranslate\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Link:\u003c/strong\u003e \u003ca href=\"https://github.com/Byaidu/PDFMathTranslate\"\u003eByaidu/PDFMathTranslate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMô tả ngắn gọn:\u003c/strong\u003e Chuyên dịch bài báo khoa học, luận văn, tài liệu toán học (giữ công thức LaTeX hoàn hảo).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTính năng nổi bật liên quan đến PDF \u0026amp; AI:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eLayout detection bằng YOLO\u003c/li\u003e\n\u003cli\u003eDịch bằng GPT-4o, DeepL, Ollama, Qwen\u003c/li\u003e\n\u003cli\u003eCLI + GUI + Docker + plugin Zotero\u003c/li\u003e\n\u003cli\u003eĐa luồng, rất nhanh\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003eBabelDOC\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Link:\u003c/strong\u003e \u003ca href=\"https://github.com/funstory-ai/BabelDOC\"\u003efunstory-ai/BabelDOC\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMô tả ngắn gọn:\u003c/strong\u003e Thư viện Python dịch PDF song ngữ (Anh ↔ Trung/Việt), hỗ trợ cả PDF scan.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTính năng nổi bật liên quan đến PDF \u0026amp; AI:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eDùng bất kỳ LLM nào tương thích OpenAI (gpt-4o-mini, Qwen, DeepSeek, v.v.)\u003c/li\u003e\n\u003cli\u003eGlossary tùy chỉnh\u003c/li\u003e\n\u003cli\u003eOutput song ngữ hoặc chỉ bản dịch\u003c/li\u003e\n\u003cli\u003eOCR workaround\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003cstrong\u003eOpenAI Translator\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Link:\u003c/strong\u003e \u003ca href=\"https://github.com/DjangoPeng/openai-translator\"\u003eDjangoPeng/openai-translator\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMô tả ngắn gọn:\u003c/strong\u003e Ứng dụng desktop chuyên dịch sách PDF tiếng Anh → tiếng Trung (có thể đổi sang tiếng Việt).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTính năng nổi bật liên quan đến PDF \u0026amp; AI:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eGUI đơn giản\u003c/li\u003e\n\u003cli\u003eTự động retry khi lỗi\u003c/li\u003e\n\u003cli\u003eHỗ trợ ChatGLM local\u003c/li\u003e\n\u003cli\u003eĐang phát triển giữ layout tốt hơn\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e\u003cstrong\u003eZotero PDF Translate\u003c/strong\u003e (plugin)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Link:\u003c/strong\u003e \u003ca href=\"https://github.com/windingwind/zotero-pdf-translate\"\u003ewindingwind/zotero-pdf-translate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMô tả ngắn gọn:\u003c/strong\u003e Plugin Zotero cực mạnh, dịch ngay trong thư viện tài liệu khoa học.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTính năng nổi bật liên quan đến PDF \u0026amp; AI:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eHỗ trợ 20+ engine (GPT, Gemini, Claude, DeepL, Qwen, Ollama, v.v.)\u003c/li\u003e\n\u003cli\u003eDịch text chọn, annotation, metadata\u003c/li\u003e\n\u003cli\u003ePop-up song ngữ\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e\u003cstrong\u003eLingoLift PDF Translator\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub Link:\u003c/strong\u003e \u003ca href=\"https://github.com/lingolift/pdf-translator\"\u003elingolift/pdf-translator\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMô tả ngắn gọn:\u003c/strong\u003e Ứng dụng GUI nhẹ, đẹp, dành cho người dùng phổ thông.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTính năng nổi bật liên quan đến PDF \u0026amp; AI:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eGiao diện hiện đại (Electron/Tauri)\u003c/li\u003e\n\u003cli\u003eDịch nhanh bằng Google Translate hoặc LLM local\u003c/li\u003e\n\u003cli\u003eTự động phát hiện ngôn ngữ\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Tong_hop_AI_Tools/Hinh_1.png\"\n  alt=\"Hinh 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"speech-to-text\"\u003eSpeech to Text\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTham khảo: \u003ca href=\"https://platform.openai.com/docs/guides/speech-to-text\"\u003ehttps://platform.openai.com/docs/guides/speech-to-text\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tạo-video\"\u003eTạo Video\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTham khảo bài viết về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/others/heygen_ai/\"\u003eHeyGen AI\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mã-nguồn-mở-open-notebookhttpswwwopen-notebookai\"\u003eMã nguồn mở \u003ca href=\"https://www.open-notebook.ai/\"\u003eOpen Notebook\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDự án mã nguồn mở, tương tự như \u003cstrong\u003eNotebookLM của Google\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVới dự án này có thể tận dụng với API của các mô hình AI khác.\u003c/li\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"https://github.com/lfnovo/open-notebook\"\u003eGithub project\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003e\u003ca href=\"https://www.open-notebook.ai/basics.html\"\u003eDocs\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/tong_hop_ai_tools/",
      "date_published": "3126-03-09T1233:33:00+07:00",
      "date_modified": "3126-03-09T1233:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "81c430b93739bead9f7d5e00f8ac937b60f3839a",
      "title": "Cong_cu_AI",
      "summary": "",
      "content_text": " Ngày Mô tả 17/11/2025 Khởi tạo bài viết, ghi chú về Grok và OpenAI 3/12/2025 Bổ sung thêm công cụ Notebook-LM AI đã là quá phổ biến, với mình AI là những người thầy tài giỏi, những người hiểu biết sâu và rộng.\nNhưng mình cũng không phải là người học trò dễ bảo, không phải cứ nói gì là mình sẽ nghe, mình sẽ luôn có những câu hỏi và đặt ngược trở lại.\nVề các công cụ AI mà mình sử dụng thường xuyên thì hiện tại mình dùng nhiều là Grok AI và OpenAI\nTại sao lại là Grok Vì Grok thông minh (xem thêm bài viết Grok_AI). Hơn nữa dữ liệu của Grok đa dạng, phong phú và gần như real-time Ngoài ra, điểm đặc biệt là Grok free (chatGPT cũng free, vậy khác biệt là đâu?): Grok cho phép mình sử dụng tính năng tác vụ, mặc dù bị giới hạn số lượt nhưng vẫn dùng ngon. Có thể automation thao tác yêu cầu Grok cho phép mình tạo được rất nhiều ảnh. Chỉ vậy thôi là đã ăn đứt ChatGPT free về tính năng.\nTại sao lại dùng OpenAI API Lúc trước thì Grok chưa có API, nhưng tính đến hiện tại (ngày 17/11/2025) Grok đã ra mắt API (link tài liệu xAI). Nhưng nếu so sánh với OpenAI API thì hiện tại API của xAI chưa bằng. Còn nếu dùng ChatGPT plus thì mình không dùng hết tính năng, do đó mình nghĩ đến dùng OpenAI API (xem thêm bài viết Fabric_AI) Hơn nữa, ngoài việc dùng cho Fabric, thì mình còn dùng API của OpenAI cho việc code. Cụ thể là dùng cho extension codex (Một extension cho vscode, sử dụng OpenAI API) Github của dự án openai/codex Ngoài ra mình còn đang muốn dùng OpenAI API để translation văn bản (thay vì dùng WPS-AI).\nhttps://community.openai.com/t/can-we-translate-whole-document-pdf-doc-execil-form-one-langues-to-other/716117/2 https://platform.openai.com/docs/guides/speech-to-text Cập nhật ngày 3/12/2025 Xem video tham khảo: Tạo chatbot mạnh mẽ miễn phí nhanh chóng với Notebooklm không cần biết code Khi xem xong video này, mình suy nghĩ có thể dùng NotebookLM (của Google) để xây dựng thư viện tài liệu cá nhân: Ví dụ như Thư viện tài liệu QCVN06 Hoặc tài liệu datasheet module sim NotebookLM Có thể mình sẽ sử dụng Google AI Plus (một gói thành viên của Google One) chủ yếu cung cấp các lợi ích tập trung vào người dùng cuối: Gói Google AI Plus sẽ khác với việc sử dụng API trong AI Studio (tương tự như việc ChatGPT sẽ khác với OpenAI API). Trang web của NotebookLM Đây là link public: https://notebooklm.google.com/notebook/0df59610-4554-4fdb-9a10-c39f65e33ac0 Chỉ cần có tài khoản google là có thể dùng. ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/11/2025\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết, ghi chú về Grok và OpenAI\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3/12/2025\u003c/td\u003e\n\u003ctd\u003eBổ sung thêm công cụ \u003cstrong\u003eNotebook-LM\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003eAI đã là quá phổ biến, với mình \u003cem\u003e\u003cstrong\u003eAI là những người thầy tài giỏi, những người hiểu biết sâu và rộng\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eNhưng mình cũng không phải là người học trò dễ bảo, không phải cứ nói gì là mình sẽ nghe, mình sẽ luôn có những câu hỏi và đặt ngược trở lại.\u003c/p\u003e\n\u003cp\u003eVề các công cụ AI mà mình sử dụng thường xuyên thì hiện tại mình dùng nhiều là \u003ca href=\"https://grok.com/\"\u003eGrok AI\u003c/a\u003e và \u003ca href=\"https://platform.openai.com/settings/organization/usage\"\u003eOpenAI\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"tại-sao-lại-là-grok\"\u003eTại sao lại là \u003cstrong\u003eGrok\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVì Grok thông minh \u003cem\u003e(xem thêm bài viết \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/others/grok_ai/\"\u003eGrok_AI\u003c/a\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eHơn nữa dữ liệu của Grok đa dạng, phong phú và gần như real-time\u003c/li\u003e\n\u003cli\u003eNgoài ra, điểm đặc biệt là Grok free \u003cem\u003e(chatGPT cũng free, vậy khác biệt là đâu?)\u003c/em\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eGrok cho phép mình sử dụng tính năng \u003cstrong\u003etác vụ\u003c/strong\u003e, mặc dù bị giới hạn số lượt nhưng vẫn dùng ngon. Có thể automation thao tác yêu cầu\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eGrok cho phép mình tạo được rất nhiều ảnh\u003c/em\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eChỉ vậy thôi là đã ăn đứt ChatGPT free về tính năng.\u003c/p\u003e\n\u003ch3 id=\"tại-sao-lại-dùng-openai-api\"\u003eTại sao lại dùng \u003cstrong\u003eOpenAI API\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước thì Grok chưa có API, nhưng tính đến hiện tại \u003cem\u003e(ngày 17/11/2025)\u003c/em\u003e \u003cstrong\u003eGrok đã ra mắt API\u003c/strong\u003e \u003cem\u003e(link \u003ca href=\"https://docs.x.ai/docs/api-reference#chat-completions\"\u003etài liệu xAI\u003c/a\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eNhưng nếu so sánh với OpenAI API thì hiện tại API của xAI chưa bằng.\u003c/li\u003e\n\u003cli\u003eCòn nếu dùng \u003cstrong\u003eChatGPT plus\u003c/strong\u003e thì mình không dùng hết tính năng, do đó mình nghĩ đến dùng \u003cstrong\u003eOpenAI API\u003c/strong\u003e \u003cem\u003e(xem thêm bài viết \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/system-devops/fabric_ai/\"\u003eFabric_AI\u003c/a\u003e)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eHơn nữa, ngoài việc dùng cho Fabric, thì mình còn dùng API của OpenAI cho việc code.\u003c/li\u003e\n\u003cli\u003eCụ thể là dùng cho extension \u003ca href=\"https://developers.openai.com/codex/ide/\"\u003ecodex\u003c/a\u003e \u003cem\u003e(Một extension cho vscode, sử dụng OpenAI API)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/openai/codex\"\u003eGithub của dự án \u003ccode\u003eopenai/codex\u003c/code\u003e\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Cong_cu_AI/Hinh_1.png\"\n  alt=\"Hinh 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eNgoài ra mình còn đang muốn dùng OpenAI API để translation văn bản \u003cem\u003e(thay vì dùng \u003cstrong\u003eWPS-AI\u003c/strong\u003e)\u003c/em\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://community.openai.com/t/can-we-translate-whole-document-pdf-doc-execil-form-one-langues-to-other/716117/2\nhttps://platform.openai.com/docs/guides/speech-to-text\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"cập-nhật-ngày-3122025\"\u003eCập nhật ngày 3/12/2025\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eXem video tham khảo: \u003ca href=\"https://www.youtube.com/watch?v=o_ATa-vGQ7k\"\u003eTạo chatbot mạnh mẽ miễn phí nhanh chóng với Notebooklm không cần biết code\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eKhi xem xong video này, mình suy nghĩ có thể dùng \u003cstrong\u003eNotebookLM\u003c/strong\u003e \u003cem\u003e(của Google)\u003c/em\u003e để xây dựng thư viện tài liệu cá nhân:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eVí dụ như \u003cstrong\u003eThư viện tài liệu QCVN06\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eHoặc tài liệu datasheet module sim\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"notebooklm\"\u003eNotebookLM\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó thể mình sẽ sử dụng \u003cstrong\u003eGoogle AI Plus\u003c/strong\u003e \u003cem\u003e(một gói thành viên của Google One)\u003c/em\u003e chủ yếu cung cấp các lợi ích tập trung vào người dùng cuối:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Cong_cu_AI/Hinh_2.png\"\n  alt=\"Hinh 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGói \u003cstrong\u003eGoogle AI Plus\u003c/strong\u003e sẽ khác với việc sử dụng \u003cstrong\u003eAPI trong AI Studio\u003c/strong\u003e \u003cem\u003e(tương tự như việc \u003cstrong\u003eChatGPT\u003c/strong\u003e sẽ khác với \u003cstrong\u003eOpenAI API\u003c/strong\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://notebooklm.google.com/?original_referer=https:%2F%2Fwww.google.com%23\u0026amp;pli=1\"\u003eTrang web của NotebookLM\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Cong_cu_AI/Hinh_3.png\"\n  alt=\"Hinh 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Cong_cu_AI/Hinh_4.png\"\n  alt=\"Hinh 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là link public: \u003ccode\u003ehttps://notebooklm.google.com/notebook/0df59610-4554-4fdb-9a10-c39f65e33ac0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eChỉ cần có tài khoản google là có thể dùng.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/cong_cu_ai/",
      "date_published": "3126-03-09T126:33:00+07:00",
      "date_modified": "3126-03-09T126:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8f0523d813d98caedd2b2e2a327836c0aa49dc56",
      "title": "Ban_them_ve_Rust",
      "summary": "",
      "content_text": " Mình đã có vài bài về chủ đề ngôn ngữ lập trình RUST. Giới thiệu về Rust-lang Rust cho desktop-app Ghi chú về Cross Compilation Rust for ARM Ban đầu khi mình tiếp xúc với Rust và dự án đầu tiên về Rust là làm về lập trình MCU, đọc thẻ RFID. Nhưng cũng đã khá lâu rồi mình không ôn tập lại về kỹ năng lập trình Rust. Vô tình hôm bữa thấy một anh DEV dùng Rust, mình hơi ngạc nhiên. Mình hỏi ảnh là đang dùng rust cho dịch vụ gì, ảnh nói: Dùng cho tất cả, từ app đến hệ thống. Dùng rust để cải thiện tốc độ chạy của ứng dụng. Mình ngạc nhiên liền, phải thốt lên WOW, ghê vậy. Mình thấy rất ít người chuyển sang dùng Rust. Không ngờ ở công ty cấp tiến như vậy, chuyển từ Dot Net sang Rust (mình chưa biết là chuyển hoàn toàn, hay chỉ chuyển một phần). Nhưng điều đó thôi cũng quá đủ. Rust for Mobile Thế là mình search xem Rust có thể dùng cho mobile không? Thì ra là vẫn có tài liệu: https://users.rust-lang.org/t/mobile-and-web-app-in-rust/106089/2 https://www.reddit.com/r/rust/comments/16scrjo/whats_the_state_of_rust_for_mobile_development/ https://github.com/matrix-org/matrix-rust-sdk https://codesuite.org/blogs/why-choose-rust-for-mobile-app-development/ Nhưng theo mình nhớ thì bên cty code mobile là dùng Flutter, nên mình nghĩ họ đang tận dụng sức mạnh của Flutter + Rust. Có một bài viết về chủ đề này, Rust + Flutter: How to Build Fast, Safe, Cross-Platform Mobile Apps Nhìn nhận cho bản thân Không ngờ cty hiện tại đang dùng Rust cho code, vậy là mình đã chọn đúng ngôn ngữ lập trình để theo đuổi. Mình theo hướng IoT/Security, nên mình sẽ cần luyện kỹ năng về Rust ở mức vừa phải. Tức là viết những module nhỏ phục vụ cho công việc nghiên cứu và học tập. Mình đang ôn tập code nhúng dùng Rust để chạy cho Camera (kiến trúc ARMv7), dùng tokio framewrok (code bất đồng bộ) để run code. ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eMình đã có vài bài về chủ đề ngôn ngữ lập trình RUST.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/rust-lang/\"\u003eGiới thiệu về Rust-lang\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003e\u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/desktop_app/\"\u003eRust cho desktop-app\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003e\u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/rust_for_arm/\"\u003eGhi chú về Cross Compilation Rust for ARM\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eBan đầu khi mình tiếp xúc với Rust và dự án đầu tiên về Rust là làm về \u003cstrong\u003elập trình MCU, đọc thẻ RFID\u003c/strong\u003e. Nhưng cũng đã khá lâu rồi mình không ôn tập lại về kỹ năng lập trình Rust.\u003c/li\u003e\n\u003cli\u003eVô tình hôm bữa thấy một anh DEV dùng Rust, mình hơi ngạc nhiên. Mình hỏi ảnh là đang dùng rust cho dịch vụ gì, ảnh nói:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eDùng cho tất cả, từ app đến hệ thống. Dùng rust để cải thiện tốc độ chạy của ứng dụng.\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eMình ngạc nhiên liền, phải thốt lên \u003cstrong\u003eWOW, ghê vậy\u003c/strong\u003e. Mình thấy rất ít người chuyển sang dùng Rust.\u003c/li\u003e\n\u003cli\u003eKhông ngờ ở công ty cấp tiến như vậy, chuyển từ \u003cstrong\u003eDot Net\u003c/strong\u003e sang \u003cstrong\u003eRust\u003c/strong\u003e \u003cem\u003e(mình chưa biết là chuyển hoàn toàn, hay chỉ chuyển một phần)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eNhưng điều đó thôi cũng quá đủ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"rust-for-mobile\"\u003eRust for Mobile\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThế là mình search xem Rust có thể dùng cho mobile không? Thì ra là vẫn có tài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://users.rust-lang.org/t/mobile-and-web-app-in-rust/106089/2\nhttps://www.reddit.com/r/rust/comments/16scrjo/whats_the_state_of_rust_for_mobile_development/\nhttps://github.com/matrix-org/matrix-rust-sdk\nhttps://codesuite.org/blogs/why-choose-rust-for-mobile-app-development/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eNhưng theo mình nhớ thì bên cty code mobile là dùng \u003cstrong\u003eFlutter\u003c/strong\u003e, nên mình nghĩ họ đang tận dụng sức mạnh của \u003cstrong\u003eFlutter + Rust\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCó một bài viết về chủ đề này, \u003ca href=\"https://dev.to/abibeh/rust-flutter-how-to-build-fast-safe-cross-platform-mobile-apps-ika\"\u003eRust + Flutter: How to Build Fast, Safe, Cross-Platform Mobile Apps\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nhìn-nhận-cho-bản-thân\"\u003eNhìn nhận cho bản thân\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhông ngờ cty hiện tại đang dùng Rust cho code, vậy là mình \u003cstrong\u003eđã chọn đúng ngôn ngữ lập trình để theo đuổi\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình theo hướng \u003cstrong\u003eIoT/Security\u003c/strong\u003e, nên mình sẽ cần luyện kỹ năng về Rust ở mức vừa phải.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eTức là viết những module nhỏ phục vụ cho công việc nghiên cứu và học tập\u003c/em\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eMình đang ôn tập code nhúng dùng Rust để chạy cho Camera \u003cem\u003e(kiến trúc ARMv7)\u003c/em\u003e, dùng \u003cstrong\u003etokio framewrok\u003c/strong\u003e \u003cem\u003e(code bất đồng bộ)\u003c/em\u003e để run code.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/ban_them_ve_rust/",
      "date_published": "27116-27-09T1147:2727:00+07:00",
      "date_modified": "27116-27-09T1147:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e934dd983c5c08756dbdea21ad014292968fc72a",
      "title": "Grok_AI",
      "summary": "",
      "content_text": "Changelog Date Mô tả 26/2/25 Khởi tạo bài viết, và cảm nhận về Grok 20/11/25 Ghi chú về các tính năng mới của Grok Dạo gần đây rộ lên thông tin về một AI của tỷ phú Elon Musk, tên là Grok 3.\nMình có dùng thử Grok 3 trên X, và thấy AI này trả lời rất hay và tuyệt vời.\nVí dụ: Đây là một đoạn chat, Grok trả lời hay thật.\nMột bài toán khác: Đây là một bài toán mà mình đặt và hỏi Grok. Chủ đề xoay quanh đại loại là: Tôi có một server dùng chip Xeon ở nhà, hiện chỉ sử dụng 5% sức mạnh CPU và đang dư khoảng 20GB RAM. Tôi nên chạy ứng dụng gì để tối ưu hóa CPU và tiết kiệm điện năng tiêu thụ. Rồi hỏi một hồi thì mình có thông tin về Boinc và Monero. Đây là câu trả lời của grok. Mình đã copy lại thành file để tham khảo sau này. Link file PDF Đây là một số tài liệu search được từ dự án boinc: https://github.com/BOINC/boinc https://boinc.berkeley.edu/download.php https://boinc.berkeley.edu/wiki/User_manual https://delta1512.github.io/BOINCOS/ Sau đó phát hiện ra có OS tên là BOINCOS, gửi link và hỏi lại grok về cái OS. Và đây là câu trả lời khi so sánh Boinc với loại hình MMO (như mining (đào coin) và render farm). Link pdf Đánh giá: Chỉ có thể nói là Grok 3 quá hay. Sau đó thấy phản hồi từ grok, mình nghĩ có thể áp dụng cả 2, dùng cả boinc đóng góp cho cộng đồng, và dùng Monero để đào coin. Cập nhật ngày 20/11/2025 Mặc dù mình chỉ đang sử dụng free, nhưng Grok vẫn có những điều hay ho và mới mẻ khác. Và Grok cũng đã có một trang riêng để trò chuyện thay vì phải lên X. Web Grok-AI Giá cả: Mô hình mới Lúc trước là Grok 3, bây giờ đã lên Grok 4 và Grok 4.1 Ngoài ra còn có Deep Search (Expert). Bộ nhớ Hiện tại với Grok (cho dù là bản free hay trả phí) thì vẫn không giới hạn lưu trữ tin nhắn. Dựa vào nội dung tin nhắn trò chuyện, grok sẽ thu thập, phân tích và đưa ra phản hồi thích hợp với người dùng (tính năng này chỉ có trên ChatGPT plus) Trò chuyện càng nhiều, Grok càng hiểu rõ về mình, mình có hỏi grok thế này: Dựa vào những gì tôi chat với bạn trước giờ, những đoán xem tôi là ai, nghành nghề, học vấn,\u0026hellip;? Kết quả thật bất ngờ, Grok đưa ra thông tin và mức độ chính xác khá cao. API Lúc trước với Grok 3, chưa có cung cấp API. Nhưng bây giờ xAI đã ra mắt API cho Grok. Documents: https://console.x.ai/home https://docs.x.ai/docs/overview https://docs.x.ai/docs/models?cluster=us-east-1#detailed-pricing-for-all-grok-models Tính năng \u0026ldquo;Tác vụ\u0026rdquo; Chế độ Tác vụ này là một tính năng tự động thực hiện yêu cầu theo khoảng thời gian nhất định. Một tính năng automation rất hay (muốn dùng tính năng này là phải trả phí cho ChatGPT), với bản free thì mình được 9 tác vụ trong 1 tuần. Tính năng \u0026ldquo;Tạo ảnh\u0026rdquo; ChatGPT cũng cho tạo ảnh, nhưng có số lần giới hạn. Còn Grok hiện tại, tạo được rất nhiều ảnh và và còn có cả ảnh động, video ngắn. Thật sự rất hay. Tính năng \u0026ldquo;Thoại\u0026rdquo; \u0026ldquo;Chế độ Thoại\u0026rdquo; này tương tự như bên ChatGPT, cũng có chế độ thoại. Mình chưa dùng nhiều về tính năng này, mai mốt sẽ thử xem thế nào. =]] Tính năng \u0026ldquo;Grokipedia\u0026rdquo; Một tính năng mình mới thấy gần đây, trang web Độ mới của dữ liệu: Real-time (cập nhật từng giây từ X + web) Tạm thời chức năng vẫn đang phát triển, nhưng Grok định nghĩa: Grokipedia ≠ thay thế hoàn toàn Google, mà là “Google + trợ lý AI gộp lại làm một” ",
      "content_html": "\u003ch3 id=\"changelog\"\u003eChangelog\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eDate\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e26/2/25\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết, và cảm nhận về Grok\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e20/11/25\u003c/td\u003e\n\u003ctd\u003eGhi chú về các tính năng mới của Grok\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003eDạo gần đây rộ lên thông tin về một AI của \u003cstrong\u003etỷ phú Elon Musk\u003c/strong\u003e, tên là \u003cstrong\u003eGrok 3\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình có dùng thử \u003cstrong\u003eGrok 3\u003c/strong\u003e trên \u003cstrong\u003eX\u003c/strong\u003e, và thấy AI này trả lời rất hay và tuyệt vời.\u003c/p\u003e\n\u003ch3 id=\"ví-dụ\"\u003eVí dụ:\u003c/h3\u003e\n\u003cp\u003eĐây là một đoạn chat, Grok trả lời hay thật.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"một-bài-toán-khác\"\u003eMột bài toán khác:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một bài toán mà mình đặt và hỏi Grok.\u003c/li\u003e\n\u003cli\u003eChủ đề xoay quanh đại loại là: Tôi có một server dùng chip Xeon ở nhà, hiện chỉ sử dụng 5% sức mạnh CPU và đang dư khoảng 20GB RAM. Tôi nên chạy ứng dụng gì để tối ưu hóa CPU và tiết kiệm điện năng tiêu thụ.\u003c/li\u003e\n\u003cli\u003eRồi hỏi một hồi thì mình có thông tin về \u003cstrong\u003eBoinc\u003c/strong\u003e và \u003cstrong\u003eMonero\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐây là câu trả lời của grok. Mình đã copy lại thành file để tham khảo sau này. \u003ca href=\"https://blog.vinhld-homelab.io.vn/docs/grok_ai_chat/Grok-Boinc_Monero.pdf\"\u003eLink file PDF\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eĐây là một số tài liệu search được từ dự án boinc:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/BOINC/boinc\nhttps://boinc.berkeley.edu/download.php\nhttps://boinc.berkeley.edu/wiki/User_manual\nhttps://delta1512.github.io/BOINCOS/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eSau đó phát hiện ra có OS tên là \u003cstrong\u003eBOINCOS\u003c/strong\u003e, gửi link và hỏi lại grok về cái OS.\u003c/li\u003e\n\u003cli\u003eVà đây là câu trả lời khi so sánh Boinc với loại hình \u003cstrong\u003eMMO (như mining (đào coin) và render farm)\u003c/strong\u003e. \u003ca href=\"/docs/grok_ai_chat/Grok_BoincOS.pdf\"\u003eLink pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"đánh-giá\"\u003eĐánh giá:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eChỉ có thể nói là \u003cstrong\u003eGrok 3\u003c/strong\u003e quá hay.\u003c/li\u003e\n\u003cli\u003eSau đó thấy phản hồi từ grok, mình nghĩ có thể áp dụng cả 2, dùng cả \u003cstrong\u003eboinc\u003c/strong\u003e đóng góp cho cộng đồng, và dùng \u003cstrong\u003eMonero\u003c/strong\u003e để đào coin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"cập-nhật-ngày-20112025\"\u003eCập nhật ngày 20/11/2025\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eMặc dù mình chỉ đang sử dụng free, nhưng Grok vẫn có những điều hay ho và mới mẻ khác.\u003c/li\u003e\n\u003cli\u003eVà Grok cũng đã có một trang riêng để trò chuyện thay vì phải lên \u003cstrong\u003eX\u003c/strong\u003e. \u003ca href=\"https://grok.com/\"\u003eWeb Grok-AI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGiá cả:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"mô-hình-mới\"\u003eMô hình mới\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước là \u003cstrong\u003eGrok 3\u003c/strong\u003e, bây giờ đã lên \u003cstrong\u003eGrok 4\u003c/strong\u003e và \u003cstrong\u003eGrok 4.1\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eNgoài ra còn có \u003cstrong\u003eDeep Search\u003c/strong\u003e \u003cem\u003e(Expert)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bộ-nhớ\"\u003eBộ nhớ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiện tại với Grok \u003cem\u003e(cho dù là bản \u003cstrong\u003efree\u003c/strong\u003e hay \u003cstrong\u003etrả phí\u003c/strong\u003e)\u003c/em\u003e thì vẫn \u003cstrong\u003ekhông giới hạn lưu trữ tin nhắn\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDựa vào nội dung tin nhắn trò chuyện, grok sẽ thu thập, phân tích và đưa ra phản hồi thích hợp với người dùng \u003cem\u003e(tính năng này chỉ có trên ChatGPT plus)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrò chuyện càng nhiều, Grok càng hiểu rõ về mình, mình có hỏi grok thế này:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDựa vào những gì tôi chat với bạn trước giờ, những đoán xem tôi là ai, nghành nghề, học vấn,\u0026hellip;?\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eKết quả thật bất ngờ, Grok đưa ra thông tin và mức độ chính xác khá cao.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"api\"\u003eAPI\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước với Grok 3, chưa có cung cấp API. Nhưng bây giờ xAI đã ra mắt API cho Grok.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://x.ai/api\"\u003eDocuments\u003c/a\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://console.x.ai/home\nhttps://docs.x.ai/docs/overview\nhttps://docs.x.ai/docs/models?cluster=us-east-1#detailed-pricing-for-all-grok-models\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tính-năng-tác-vụ\"\u003eTính năng \u0026ldquo;Tác vụ\u0026rdquo;\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eChế độ \u003cstrong\u003eTác vụ\u003c/strong\u003e này là một tính năng \u003cstrong\u003etự động thực hiện yêu cầu theo khoảng thời gian nhất định\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMột tính năng automation rất hay \u003cem\u003e(muốn dùng tính năng này là phải trả phí cho ChatGPT)\u003c/em\u003e, với bản free thì mình được \u003cstrong\u003e9 tác vụ trong 1 tuần\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tính-năng-tạo-ảnh\"\u003eTính năng \u0026ldquo;Tạo ảnh\u0026rdquo;\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eChatGPT cũng cho tạo ảnh, nhưng có số lần giới hạn.\u003c/li\u003e\n\u003cli\u003eCòn Grok hiện tại, tạo được rất nhiều ảnh và và còn có cả \u003cstrong\u003eảnh động, video ngắn\u003c/strong\u003e. Thật sự rất hay.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tính-năng-thoại\"\u003eTính năng \u0026ldquo;Thoại\u0026rdquo;\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026ldquo;Chế độ Thoại\u0026rdquo; này tương tự như bên ChatGPT, cũng có chế độ thoại.\u003c/li\u003e\n\u003cli\u003eMình chưa dùng nhiều về tính năng này, mai mốt sẽ thử xem thế nào. =]]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tính-năng-grokipedia\"\u003eTính năng \u0026ldquo;Grokipedia\u0026rdquo;\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột tính năng mình mới thấy gần đây, \u003ca href=\"https://grokipedia.com/?referer=grok-web\"\u003etrang web\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eĐộ mới của dữ liệu: Real-time (cập nhật từng giây từ X + web)\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eTạm thời chức năng vẫn đang phát triển, nhưng Grok định nghĩa:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGrokipedia ≠ thay thế hoàn toàn Google, mà là “Google + trợ lý AI gộp lại làm một”\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/Others/Grok_AI/Hinh_6.png\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/grok_ai/",
      "date_published": "20116-20-09T1142:2020:00+07:00",
      "date_modified": "20116-20-09T1142:2020:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "ee90a1ea521cce429fb7cbd0d55dc8836e60990e",
      "title": "Test_TF Card",
      "summary": "",
      "content_text": "Changelog Date Mô tả 17/11/25 Khởi tạo bài viết và ghi chú cách test thẻ nhớ 18/11/25 Bổ sung cách kiểm tra tốc độ đọc/ghi thực tế của thẻ 20/11/25 Ghi chú thêm về command chkdsk trên Windows Xem thêm bài viết về Thẻ nhớ\nCòn trong bài này thì mình sẽ ghi chú lại một số cách để test thẻ nhớ.\nĐể biết một thẻ nhớ có bền hay không thì chỉ có thời gian mới có câu trả lời.\nMôi trường thực tế rất nhiều biến số và khắc nghiệp, nên khi test trong phòng lab, mình cần làm mọi cách để đẩy thẻ nhớ đến giới hạn hoạt động\nThuật ngữ Aging test Aging test (hay già hóa thử nghiệm) là phương pháp kiểm tra độ bền, độ ổn định của linh kiện điện tử (như thẻ nhớ, chip, bo mạch…). Bằng cách cho chúng hoạt động liên tục trong điều kiện khắc nghiệt để \u0026ldquo;già đi nhanh\u0026rdquo; – tức là mô phỏng quá trình sử dụng lâu dài trong thời gian ngắn. Giả lập Cho một chiếc camera hoạt động full tải và gắn thẻ nhớ vào. Như gắn thêm camera sau, kết nối module sim, kết nối GPS,\u0026hellip; Trường hợp 1: Ngắt nguồn điện đột ngột. Cho thiết bị chạy liên tục khoảng 30p. Sau đó ngắt nguồn giữa chừng. Trường hợp 2: Tháo thẻ nhớ đột ngột. Cho thiết bị chạy liên tục khoảng 30p. Tháo thẻ nhớ đột ngột. Trường hợp 3: Format TF-Card Trong quá trình ghi hình, thỉnh thoảng tiến hành format thẻ nhớ. Thao tác liên tục như vậy. Trường hợp 4: Test ghi hình liên tục 24/24 Cho thiết bị hoạt động liên tục 24/24 trong mấy ngày. Ngoài ra có thể để camera hoạt động trong môi trường nhiệt độ cao, ví dụ: ngoài trời nắng. Cập nhật ngày 18/11/2025 Kiểm tra tốc độ đọc/ghi thực tế Mình gặp trường hợp cùng là camera đó, sử dụng gần như cùng loại thẻ nhớ (một loại là thẻ A2V30, một loại là thẻ E+ A2V30) Nếu mình dùng công cụ đo thì cả 2 thẻ là gần như nhau. Công cụ USBDeview Thông số 2 thẻ là như nhau: Sau đó chọn Speed Test để đo tốc độ từng thẻ. Note Tốc độ cả 2 thẻ là gần như nhau, vậy tại sao một thẻ lại dùng OK, thẻ còn lại thì dùng không được. Thế là mình đặt câu hỏi cho Grok, và đâu là câu trả lời: iostat command Vậy là mình sẽ cần một công cụ giúp đo khả năng thực tế của thẻ nhớ. Cũng may là mình có thể chạy command này trên thiết bị camera: iostat -dxz mmcblk0p1 1 | tee /mnt/sd/camera_sd-card_speed.log Cập nhật 20/11/2025 Lệnh chkdsk chkdsk (viết tắt của Check Disk) là một lệnh có sẵn trong Windows dùng để kiểm tra và sửa lỗi hệ thống tập tin (file system) trên ổ cứng, phân vùng, USB, thẻ nhớ, v.v.\nChức năng chính của chkdsk Kiểm tra lỗi logic trên hệ thống tập tin (FAT32, NTFS, exFAT, ReFS). Sửa lỗi hệ thống tập tin (nếu dùng tham số phù hợp). Tìm và đánh dấu các sector xấu (bad sector) trên ổ đĩa để hệ điều hành không ghi dữ liệu vào đó nữa. Khôi phục dữ liệu có thể đọc được từ các sector xấu (nếu có). Cú pháp cơ bản chkdsk [tên_ổ_đĩa:] [/f] [/r] [/x] ... [tên_ổ_đĩa:] → Ví dụ: C: D: E: Các tham số phổ biến nhất: Lưu ý: Luôn sao lưu dữ liệu quan trọng trước khi chạy /r (vì nó sẽ cố khôi phục dữ liệu từ sector xấu, đôi khi có thể làm mất dữ liệu nếu ổ hỏng nặng). Do đó khi nghi ngờ ổ cứng hỏng, khuyến nghị không dùng /r. Với ổ SSD, chkdsk vẫn hữu ích để sửa lỗi NTFS, nhưng không cần lo bad sector nhiều như HDD (SSD có cơ chế khác). Phải chạy Command Prompt với quyền Administrator. Ví dụ Mình có thử dùng lệnh này để check thẻ nhớ. Câu lệnh này sẽ giúp mình kiểm tra các lỗi về ghi file, chứ không giúp mình biết đc thẻ đó có hư không. Tuy vậy, lệnh này rất hữu ích để giúp mình kiểm tra xem lỗi đầy thẻ nhớ (hoặc không ghi hình vòng lặp), vì một số camera khi bị ngắt nguồn đột ngột, file video sẽ bị hỏng và lúc này camera không thể xử lý xóa video hỏng đó đc \u0026ndash;\u0026gt; Dẫn đến tình trạng không ghi hình vòng lặp. ",
      "content_html": "\u003ch2 id=\"changelog\"\u003eChangelog\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eDate\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/11/25\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết và ghi chú cách test thẻ nhớ\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e18/11/25\u003c/td\u003e\n\u003ctd\u003eBổ sung cách \u003cstrong\u003ekiểm tra tốc độ đọc/ghi thực tế của thẻ\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e20/11/25\u003c/td\u003e\n\u003ctd\u003eGhi chú thêm về command \u003ccode\u003echkdsk\u003c/code\u003e trên Windows\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003eXem thêm bài viết về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/hardware/the_nho/\"\u003eThẻ nhớ\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eCòn trong bài này thì mình sẽ ghi chú lại một số cách để test thẻ nhớ.\u003c/p\u003e\n\u003cp\u003eĐể biết một thẻ nhớ có bền hay không thì chỉ có \u003cstrong\u003ethời gian mới có câu trả lời\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMôi trường thực tế rất nhiều biến số và khắc nghiệp, nên khi test trong phòng lab, mình cần làm mọi cách để \u003cstrong\u003eđẩy thẻ nhớ đến giới hạn hoạt động\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"thuật-ngữ-aging-test\"\u003eThuật ngữ \u003ccode\u003eAging test\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAging test\u003c/strong\u003e \u003cem\u003e(hay \u003cstrong\u003egià hóa thử nghiệm\u003c/strong\u003e)\u003c/em\u003e là \u003cstrong\u003ephương pháp kiểm tra độ bền, độ ổn định\u003c/strong\u003e của linh kiện điện tử (như thẻ nhớ, chip, bo mạch…).\u003c/li\u003e\n\u003cli\u003eBằng cách cho chúng \u003cem\u003e\u003cstrong\u003ehoạt động liên tục trong điều kiện khắc nghiệt\u003c/strong\u003e\u003c/em\u003e để \u0026ldquo;già đi nhanh\u0026rdquo; – tức là mô phỏng quá trình sử dụng lâu dài trong thời gian ngắn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"giả-lập\"\u003eGiả lập\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCho một chiếc camera hoạt động full tải và gắn thẻ nhớ vào.\u003c/li\u003e\n\u003cli\u003eNhư gắn thêm camera sau, kết nối module sim, kết nối GPS,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"trường-hợp-1-ngắt-nguồn-điện-đột-ngột\"\u003eTrường hợp 1: Ngắt nguồn điện đột ngột.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCho thiết bị chạy liên tục khoảng 30p.\u003c/li\u003e\n\u003cli\u003eSau đó ngắt nguồn giữa chừng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"trường-hợp-2-tháo-thẻ-nhớ-đột-ngột\"\u003eTrường hợp 2: Tháo thẻ nhớ đột ngột.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCho thiết bị chạy liên tục khoảng 30p.\u003c/li\u003e\n\u003cli\u003eTháo thẻ nhớ đột ngột.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"trường-hợp-3-format-tf-card\"\u003eTrường hợp 3: Format TF-Card\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình ghi hình, thỉnh thoảng tiến hành format thẻ nhớ.\u003c/li\u003e\n\u003cli\u003eThao tác liên tục như vậy.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"trường-hợp-4-test-ghi-hình-liên-tục-2424\"\u003eTrường hợp 4: Test ghi hình liên tục 24/24\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCho thiết bị hoạt động liên tục 24/24 trong mấy ngày.\u003c/li\u003e\n\u003cli\u003eNgoài ra có thể để camera hoạt động trong môi trường nhiệt độ cao, ví dụ: \u003cem\u003engoài trời nắng\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"cập-nhật-ngày-18112025\"\u003eCập nhật ngày \u003ccode\u003e18/11/2025\u003c/code\u003e\u003c/h1\u003e\n\u003ch2 id=\"kiểm-tra-tốc-độ-đọcghi-thực-tế\"\u003eKiểm tra tốc độ đọc/ghi thực tế\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMình gặp trường hợp cùng là camera đó, sử dụng gần như cùng loại thẻ nhớ \u003cem\u003e(một loại là \u003cstrong\u003ethẻ A2V30\u003c/strong\u003e, một loại là \u003cstrong\u003ethẻ E+ A2V30\u003c/strong\u003e)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eNếu mình dùng công cụ đo thì cả 2 thẻ là gần như nhau.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-usbdeview\"\u003eCông cụ USBDeview\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThông số 2 thẻ là như nhau:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau đó chọn \u003cstrong\u003eSpeed Test\u003c/strong\u003e để đo tốc độ từng thẻ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTốc độ cả 2 thẻ là gần như nhau, vậy tại sao một thẻ lại dùng OK, thẻ còn lại thì dùng không được.\u003c/li\u003e\n\u003cli\u003eThế là mình đặt câu hỏi cho Grok, và đâu là câu trả lời:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"iostat-commandhttpswwwgeeksforgeeksorglinux-unixiostat-command-in-linux-with-examples\"\u003e\u003ca href=\"https://www.geeksforgeeks.org/linux-unix/iostat-command-in-linux-with-examples/\"\u003eiostat command\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVậy là mình sẽ cần một công cụ giúp đo khả năng thực tế của thẻ nhớ.\u003c/li\u003e\n\u003cli\u003eCũng may là mình có thể chạy command này trên thiết bị camera:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eiostat -dxz mmcblk0p1 1 | tee /mnt/sd/camera_sd-card_speed.log\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_6.png\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_7.png\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"cập-nhật-20112025\"\u003eCập nhật \u003ccode\u003e20/11/2025\u003c/code\u003e\u003c/h1\u003e\n\u003ch2 id=\"lệnh-chkdsk\"\u003eLệnh \u003ccode\u003echkdsk\u003c/code\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003echkdsk\u003c/strong\u003e (viết tắt của \u003cem\u003eCheck Disk\u003c/em\u003e) là một lệnh có sẵn trong \u003cstrong\u003eWindows\u003c/strong\u003e dùng để \u003cstrong\u003ekiểm tra\u003c/strong\u003e và \u003cstrong\u003esửa lỗi hệ thống tập tin\u003c/strong\u003e (file system) trên ổ cứng, phân vùng, USB, thẻ nhớ, v.v.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"chức-năng-chính-của-chkdsk\"\u003eChức năng chính của \u003ccode\u003echkdsk\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKiểm tra lỗi logic\u003c/strong\u003e trên hệ thống tập tin (FAT32, NTFS, exFAT, ReFS).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSửa lỗi hệ thống tập tin\u003c/strong\u003e (nếu dùng tham số phù hợp).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTìm và đánh dấu các sector xấu\u003c/strong\u003e (bad sector) trên ổ đĩa để hệ điều hành không ghi dữ liệu vào đó nữa.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKhôi phục dữ liệu có thể đọc được\u003c/strong\u003e từ các sector xấu (nếu có).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"cú-pháp-cơ-bản\"\u003eCú pháp cơ bản\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003echkdsk [tên_ổ_đĩa:] [/f] [/r] [/x] ...\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e[tên_ổ_đĩa:]\u003c/code\u003e → Ví dụ: C: D: E:\u003c/li\u003e\n\u003cli\u003eCác tham số phổ biến nhất:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_8.png\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"lưu-ý\"\u003eLưu ý:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLuôn sao lưu dữ liệu quan trọng trước khi chạy \u003ccode\u003e/r\u003c/code\u003e (vì nó sẽ cố khôi phục dữ liệu từ sector xấu, đôi khi có thể làm mất dữ liệu nếu ổ hỏng nặng).\u003c/li\u003e\n\u003cli\u003eDo đó khi nghi ngờ ổ cứng hỏng, khuyến nghị không dùng \u003ccode\u003e/r\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eVới ổ SSD, chkdsk vẫn hữu ích để sửa lỗi NTFS, nhưng không cần lo bad sector nhiều như HDD (SSD có cơ chế khác).\u003c/li\u003e\n\u003cli\u003ePhải chạy Command Prompt với quyền \u003cstrong\u003eAdministrator\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ví-dụ\"\u003eVí dụ\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Test_TF-Card/Hinh_9.png\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMình có thử dùng lệnh này để check thẻ nhớ.\u003c/li\u003e\n\u003cli\u003eCâu lệnh này sẽ giúp mình \u003cstrong\u003ekiểm tra các lỗi về ghi file\u003c/strong\u003e, chứ không giúp mình biết đc thẻ đó có hư không.\u003c/li\u003e\n\u003cli\u003eTuy vậy, lệnh này rất hữu ích để giúp mình kiểm tra xem \u003cstrong\u003elỗi đầy thẻ nhớ \u003cem\u003e(hoặc không ghi hình vòng lặp)\u003c/em\u003e\u003c/strong\u003e, vì một số camera khi bị ngắt nguồn đột ngột, file video sẽ bị hỏng và lúc này camera không thể xử lý xóa video hỏng đó đc \u0026ndash;\u0026gt; \u003cstrong\u003eDẫn đến tình trạng không ghi hình vòng lặp\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/test_tf-card/",
      "date_published": "20116-20-09T1144:2020:00+07:00",
      "date_modified": "20116-20-09T1144:2020:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "089d792a15f4323262157b48719f0c7c243306c5",
      "title": "IP_Scanner",
      "summary": "",
      "content_text": " Khi mình public một trang web ra ngoài bị thể nào cũng bị scan. Và mình cũng thế, mình có setup một MQTT Broker, và mỗi lần có thiết bị kết nối với server của mình thì sẽ có alert đẩy về Telegram. Và tất nhiên công việc đầu tiên của mình sẽ làm là search IP này trên Viustotal. Ban đầu mình đã tính thực hiện các thao tác pentest IP này, không hiểu sao tự nhiên mình lại lấy chủ đề này ra trao đổi thêm với Grok. Và mình đã có được những thông tin mới, bổ ích. Câu trả lời của Grok IP 45.156.128.71 thuộc dải 45.156.128.0/24, đây là dải IP nổi tiếng chuyên dùng cho các tool quét mạng tự động. Dải 45.156.128.0/24 và 45.156.129.0/24 là nguồn phát ra hàng triệu lượt quét port mỗi ngày trên toàn Internet. Chúng quét rất sạch (không exploit, chỉ kết nối để lấy banner dịch vụ), nhưng tần suất cao nên dễ bị phát hiện trong log. Đây không phải tấn công nhắm riêng vào bạn, mà là quét toàn bộ Internet (hàng tỷ IP). Trang của bạn chỉ là một trong số đó mà thôi. Bạn có nên quét ngược lại (scan back) hoặc pentest IP này không? KHÔNG NÊN, và tuyệt đối không làm.\nĐây là hành vi active scanning không được phép vào hệ thống của người khác → có thể vi phạm pháp luật (ở Việt Nam là Nghị định 144/2021/NĐ-CP về an ninh mạng, hoặc luật quốc tế như CFAA nếu họ khiếu nại). Chủ IP này là công ty bảo mật/research hợp pháp, họ có honeypot và hệ thống giám sát. Nếu bạn quét mạnh, họ sẽ ghi log và có thể báo cáo ngược lại ISP/hosting của bạn → bạn bị abuse complaint, thậm chí bị khóa server. Hàng nghìn admin khác cũng từng bực tức và thử quét ngược → cuối cùng toàn bị cảnh cáo hoặc mất IP. Bạn nên làm gì thay vì quét lại? Block IP này một cách thông minh (khuyến nghị). Giảm bề mặt tấn công (quan trọng hơn là block): Không expose các port không cần thiết (80/443 thì ok, nhưng 22, 3306, 3389, v.v. thì không nên public). Dùng fail2ban hoặc crowdsec để tự động block các IP quét nhiều. Update server, dùng WAF (ModSecurity, Cloudflare, Imunify360, v.v.). Report nếu muốn (không bắt buộc, vì họ hợp pháp). Tại sao VirusTotal lại flag IP 45.156.128.71 (và toàn bộ dải 45.156.128.0/24 + 45.156.129.0/24) là malicious/malware? IP này thuộc về một công ty nghiên cứu bảo mật hợp pháp (chủ yếu là Censys.io, đôi khi Shadowserver hoặc các dự án internet scanning khác), họ thuê VPS từ M247 (một nhà cung cấp hosting lớn ở châu Âu, chuyên cho thuê dải IP “bẩn” để tránh bị block hàng loạt). Công việc của họ là quét toàn bộ Internet hàng ngày (hàng tỷ IP) để thu thập dữ liệu về port mở, dịch vụ chạy, certificate… nhằm mục đích nghiên cứu bảo mật và cảnh báo lỗ hổng. Vì họ quét cực kỳ mạnh (hàng triệu kết nối/ngày), một số phần mềm diệt virus và hệ thống IDS/IPS coi hành vi này giống hệt botnet/malware scanner/tấn công dò port → tự động gắn nhãn “malicious”, “scanner”, “intrusion attempt”, “suspicious scanning activity”… Kết quả: Trên VirusTotal hiện tại thường có 3–12/90 vendors flag IP này là malicious (tùy thời điểm), nhưng hơn 80–90% còn lại thì clean. Đó chính là false positive điển hình của các scanner hợp pháp. Công việc tiếp theo Vậy là mình đã hiểu thêm và không cần phải scan back (quét ngược lại) Mà mình chỉ cần add các IP này vào black-list trên FW là được. ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eKhi mình public một trang web ra ngoài bị thể nào cũng bị scan.\u003c/li\u003e\n\u003cli\u003eVà mình cũng thế, mình có setup một MQTT Broker, và mỗi lần có thiết bị kết nối với server của mình thì sẽ có alert đẩy về Telegram.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/IP_Scanner/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVà tất nhiên công việc đầu tiên của mình sẽ làm là search IP này trên Viustotal.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/IP_Scanner/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBan đầu mình đã tính thực hiện các thao tác pentest IP này, không hiểu sao tự nhiên mình lại lấy chủ đề này ra trao đổi thêm với Grok.\u003c/li\u003e\n\u003cli\u003eVà mình đã có được những thông tin mới, bổ ích.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"câu-trả-lời-của-grok\"\u003eCâu trả lời của Grok\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIP \u003cstrong\u003e45.156.128.71\u003c/strong\u003e thuộc dải \u003ccode\u003e45.156.128.0/24\u003c/code\u003e, \u003cstrong\u003eđây là dải IP nổi tiếng chuyên dùng cho các tool quét mạng tự động\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDải 45.156.128.0/24 và 45.156.129.0/24 là nguồn phát ra hàng triệu lượt quét port mỗi ngày trên toàn Internet. Chúng quét rất sạch (không exploit, chỉ kết nối để lấy banner dịch vụ), nhưng tần suất cao nên dễ bị phát hiện trong log.\u003c/li\u003e\n\u003cli\u003eĐây \u003cstrong\u003ekhông phải tấn công nhắm riêng vào bạn\u003c/strong\u003e, mà là quét toàn bộ Internet (hàng tỷ IP). Trang của bạn chỉ là một trong số đó mà thôi.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bạn-có-nên-quét-ngược-lại-scan-back-hoặc-pentest-ip-này-không\"\u003eBạn có nên quét ngược lại (scan back) hoặc pentest IP này không?\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eKHÔNG NÊN, và tuyệt đối không làm.\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là hành vi \u003cstrong\u003eactive scanning\u003c/strong\u003e không được phép vào hệ thống của người khác → có thể vi phạm pháp luật (ở Việt Nam là Nghị định 144/2021/NĐ-CP về an ninh mạng, hoặc luật quốc tế như CFAA nếu họ khiếu nại).\u003c/li\u003e\n\u003cli\u003eChủ IP này là công ty bảo mật/research hợp pháp, họ có honeypot và hệ thống giám sát. Nếu bạn quét mạnh, họ sẽ ghi log và có thể báo cáo ngược lại ISP/hosting của bạn → bạn bị abuse complaint, thậm chí bị khóa server.\u003c/li\u003e\n\u003cli\u003eHàng nghìn admin khác cũng từng bực tức và thử quét ngược → cuối cùng toàn bị cảnh cáo hoặc mất IP.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bạn-nên-làm-gì-thay-vì-quét-lại\"\u003eBạn nên làm gì thay vì quét lại?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBlock IP này một cách thông minh\u003c/strong\u003e (khuyến nghị).\u003c/li\u003e\n\u003cli\u003eGiảm bề mặt tấn công (quan trọng hơn là block):\n\u003cul\u003e\n\u003cli\u003eKhông expose các port không cần thiết (80/443 thì ok, nhưng 22, 3306, 3389, v.v. thì không nên public).\u003c/li\u003e\n\u003cli\u003eDùng fail2ban hoặc crowdsec để tự động block các IP quét nhiều.\u003c/li\u003e\n\u003cli\u003eUpdate server, dùng WAF (ModSecurity, Cloudflare, Imunify360, v.v.).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReport\u003c/strong\u003e nếu muốn (không bắt buộc, vì họ hợp pháp).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-virustotal-lại-flag-ip-4515612871-và-toàn-bộ-dải-45156128024--45156129024-là-maliciousmalware\"\u003eTại sao VirusTotal lại flag IP 45.156.128.71 (và toàn bộ dải 45.156.128.0/24 + 45.156.129.0/24) là malicious/malware?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIP này thuộc về một công ty nghiên cứu bảo mật hợp pháp (chủ yếu là Censys.io, đôi khi Shadowserver hoặc các dự án internet scanning khác), họ thuê VPS từ M247 (một nhà cung cấp hosting lớn ở châu Âu, chuyên cho thuê dải IP “bẩn” để tránh bị block hàng loạt).\u003c/li\u003e\n\u003cli\u003eCông việc của họ là \u003cstrong\u003equét toàn bộ Internet\u003c/strong\u003e hàng ngày (hàng tỷ IP) để thu thập dữ liệu về port mở, dịch vụ chạy, certificate… nhằm mục đích nghiên cứu bảo mật và cảnh báo lỗ hổng.\u003c/li\u003e\n\u003cli\u003eVì họ quét cực kỳ mạnh (hàng triệu kết nối/ngày), một số phần mềm diệt virus và hệ thống IDS/IPS coi hành vi này giống hệt botnet/malware scanner/tấn công dò port → tự động gắn nhãn “malicious”, “scanner”, “intrusion attempt”, “suspicious scanning activity”…\u003c/li\u003e\n\u003cli\u003eKết quả: Trên VirusTotal hiện tại thường có 3–12/90 vendors flag IP này là malicious (tùy thời điểm), nhưng hơn 80–90% còn lại thì clean. Đó chính là false positive điển hình của các scanner hợp pháp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"công-việc-tiếp-theo\"\u003eCông việc tiếp theo\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eVậy là mình đã hiểu thêm và không cần phải \u003cstrong\u003escan back\u003c/strong\u003e \u003cem\u003e(quét ngược lại)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eMà mình chỉ cần add các IP này vào black-list trên FW là được.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/ip_scanner/",
      "date_published": "18116-18-09T1151:1818:00+07:00",
      "date_modified": "18116-18-09T1151:1818:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "3ea1335a5b9071d5a72efef6d0022d5469d46499",
      "title": "CMOS_Sensor",
      "summary": "",
      "content_text": "Cảm biến hình ảnh, một bộ phận quan trọng đối với một chiếc camera.\nĐối với các thiết bị như điện thoại, camera an ninh, webcam thì loại Cảm biến CMOS (CMOS Sensor) được dùng rất phổ biến.\nVí dụ về loại cảm biến hình ảnh GC4653 Đây là một sản phẩm của công ty Trung Quốc chuyên về các linh kiện hình ảnh. Tài liệu tham khảo về sensor này: https://www.gophotonics.com/products/cmos-image-sensors/galaxycore-microelectronics/21-117-gc4653 https://en.gcoreinc.com/products/index?cid=14\u0026amp;subcid=15 https://dl.sipeed.com/fileList/MaixCAM/Sensors/GC4653/GC4653_CSP_datasheet%C2%A0for%C2%A0release_Rev.1.0_20190712.pdf Đặc điểm chính của GC4653: Độ phân giải: 4MP (2560 x 1440 pixel), hỗ trợ video 2K/1440p ở 30fps. Kích thước: 1/3 inch (khoảng 1/2.9 inch theo một số nguồn), phù hợp cho các thiết bị nhỏ gọn. Giao diện: MIPI CSI (dùng cho camera module), hỗ trợ định dạng RAW10/RAW12. Tính năng nổi bật: Hỗ trợ HDR (High Dynamic Range) cho hình ảnh rõ nét trong điều kiện ánh sáng phức tạp. Chế độ low-light (ánh sáng yếu) tốt, phù hợp cho camera ban đêm hoặc IR CUT (cắt hồng ngoại). Tích hợp ADC 10/12-bit và ISP (Image Signal Processor) cơ bản, giúp giảm tải xử lý cho chip chính. Nhiệt độ hoạt động: -20°C đến 80°C, khá bền bỉ. Ứng dụng phổ biến: Camera an ninh CCTV, module IP camera (hỗ trợ H.264/H.265). Dashcam ô tô (ví dụ: WonVon W4K sử dụng GC4653 cho camera trước). Webcam USB, camera điện thoại, UAV (drone), hoặc thiết bị IoT. Tham khảo thêm: https://www.linkedin.com/posts/gophotonics_galaxycoremicroelectronics-cmos-image-activity-7282077269928419328-kbUn/ https://wiki.sipeed.com/hardware/en/maixcam/cameras.html https://dl.sipeed.com/shareURL/MaixCAM/Sensors Ví dụ dòng camera 70mai Dash Cam A200 đang dùng sensor GC2093 (chất lượng thấp hơn GC4653) Giải thích thêm về một số thuật ngữ Đọc datasheet thì có nhiều chỗ mình không hiểu lắm, phải trao đổi với Grok AI thì mình mới được khai sáng thêm. =]]\n4MP là gì? MP = Megapixel = 1 triệu điểm ảnh. 4MP = 4 triệu điểm ảnh → ảnh chụp ra có 4 triệu chấm nhỏ ghép lại thành 1 bức ảnh. 2560 x 1440 pixel là sao? Đây là kích thước ảnh/video: 2560 = số chấm theo chiều ngang. 1440 = số chấm theo chiều dọc. Nhân lại: 2560 × 1440 = 3.686.400 → làm tròn thành ~4 triệu → gọi là 4MP. Tức là: 1 bức ảnh = 2560 chấm ngang × 1440 chấm dọc = khoảng 4 triệu chấm → 4MP. ",
      "content_html": "\u003cp\u003eCảm biến hình ảnh, một bộ phận quan trọng đối với một chiếc camera.\u003c/p\u003e\n\u003cp\u003eĐối với các thiết bị như \u003cstrong\u003eđiện thoại, camera an ninh, webcam\u003c/strong\u003e thì loại \u003cstrong\u003eCảm biến CMOS\u003c/strong\u003e \u003cem\u003e(CMOS Sensor)\u003c/em\u003e được dùng rất phổ biến.\u003c/p\u003e\n\u003ch2 id=\"ví-dụ-về-loại-cảm-biến-hình-ảnh-gc4653gc4653\"\u003eVí dụ về loại cảm biến hình ảnh \u003ca href=\"https://blog.vinhld-homelab.io.vn/docs/GC4653_CSP_datasheet_for_release_Rev.1.0_20190712.pdf\"\u003eGC4653\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một sản phẩm của công ty Trung Quốc chuyên về các linh kiện hình ảnh.\u003c/li\u003e\n\u003cli\u003eTài liệu tham khảo về sensor này:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.gophotonics.com/products/cmos-image-sensors/galaxycore-microelectronics/21-117-gc4653\nhttps://en.gcoreinc.com/products/index?cid=14\u0026amp;subcid=15\nhttps://dl.sipeed.com/fileList/MaixCAM/Sensors/GC4653/GC4653_CSP_datasheet%C2%A0for%C2%A0release_Rev.1.0_20190712.pdf\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"đặc-điểm-chính-của-gc4653\"\u003eĐặc điểm chính của GC4653:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐộ phân giải: \u003cstrong\u003e4MP (2560 x 1440 pixel)\u003c/strong\u003e, hỗ trợ video 2K/1440p ở 30fps.\u003c/li\u003e\n\u003cli\u003eKích thước: 1/3 inch (khoảng 1/2.9 inch theo một số nguồn), phù hợp cho các thiết bị nhỏ gọn.\u003c/li\u003e\n\u003cli\u003eGiao diện: \u003cstrong\u003eMIPI CSI\u003c/strong\u003e (dùng cho camera module), hỗ trợ định dạng RAW10/RAW12.\u003c/li\u003e\n\u003cli\u003eTính năng nổi bật:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHỗ trợ HDR (High Dynamic Range)\u003c/strong\u003e cho hình ảnh rõ nét trong điều kiện ánh sáng phức tạp.\u003c/li\u003e\n\u003cli\u003eChế độ low-light (ánh sáng yếu) tốt, phù hợp cho camera ban đêm hoặc IR CUT (cắt hồng ngoại).\u003c/li\u003e\n\u003cli\u003eTích hợp ADC 10/12-bit và ISP (Image Signal Processor) cơ bản, giúp giảm tải xử lý cho chip chính.\u003c/li\u003e\n\u003cli\u003eNhiệt độ hoạt động: -20°C đến 80°C, khá bền bỉ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eỨng dụng phổ biến:\n\u003cul\u003e\n\u003cli\u003eCamera an ninh CCTV, module IP camera (hỗ trợ H.264/H.265).\u003c/li\u003e\n\u003cli\u003eDashcam ô tô (ví dụ: WonVon W4K sử dụng GC4653 cho camera trước).\u003c/li\u003e\n\u003cli\u003eWebcam USB, camera điện thoại, UAV (drone), hoặc thiết bị IoT.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tham-khảo-thêm\"\u003eTham khảo thêm:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.linkedin.com/posts/gophotonics_galaxycoremicroelectronics-cmos-image-activity-7282077269928419328-kbUn/\nhttps://wiki.sipeed.com/hardware/en/maixcam/cameras.html\nhttps://dl.sipeed.com/shareURL/MaixCAM/Sensors\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eVí dụ dòng camera \u003ca href=\"https://shop70mai.vn/camera-hanh-trinh-70mai-a200/\"\u003e70mai Dash Cam A200\u003c/a\u003e đang dùng sensor GC2093 \u003cem\u003e(\u003cstrong\u003echất lượng thấp hơn GC4653\u003c/strong\u003e)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"giải-thích-thêm-về-một-số-thuật-ngữ\"\u003eGiải thích thêm về một số thuật ngữ\u003c/h2\u003e\n\u003cp\u003eĐọc datasheet thì có nhiều chỗ mình không hiểu lắm, phải trao đổi với \u003cstrong\u003eGrok AI\u003c/strong\u003e thì mình mới được khai sáng thêm. =]]\u003c/p\u003e\n\u003ch3 id=\"4mp-là-gì\"\u003e\u003ccode\u003e4MP\u003c/code\u003e là gì?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMP\u003c/strong\u003e = Megapixel = \u003cstrong\u003e1 triệu điểm ảnh\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e4MP = 4 triệu điểm ảnh\u003c/strong\u003e → ảnh chụp ra có \u003cstrong\u003e4 triệu chấm nhỏ\u003c/strong\u003e ghép lại thành 1 bức ảnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2560-x-1440-pixel-là-sao\"\u003e\u003ccode\u003e2560 x 1440 pixel\u003c/code\u003e là sao?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là \u003cstrong\u003ekích thước ảnh/video\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e2560\u003c/strong\u003e = số chấm theo \u003cstrong\u003echiều ngang\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1440\u003c/strong\u003e = số chấm theo \u003cstrong\u003echiều dọc\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eNhân lại:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e2560 × 1440 = 3.686.400 → làm tròn thành ~4 triệu → gọi là 4MP.\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eTức là: \u003cstrong\u003e1 bức ảnh = 2560 chấm ngang × 1440 chấm dọc = khoảng 4 triệu chấm → 4MP\u003c/strong\u003e\u003c/em\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/cmos_sensor/",
      "date_published": "13116-13-09T112:1313:00+07:00",
      "date_modified": "13116-13-09T112:1313:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "9ba6123be3bc36f015d9461edf8b35f82c101966",
      "title": "Mon_hoc_ATTT",
      "summary": "",
      "content_text": "Đây là một bài viết mình lụm được từ CyberJustu.\nLúc trước mình có học Web Pentest ở đây, có rất nhiều kiến thức mình đã có được từ lớp học này.\nTổng hợp các môn học nền tảng trong lĩnh vực An toàn thông tin: ",
      "content_html": "\u003cp\u003eĐây là một bài viết mình lụm được từ \u003cstrong\u003eCyberJustu\u003c/strong\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eLúc trước mình có học Web Pentest ở đây, có rất nhiều kiến thức mình đã có được từ lớp học này\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tổng-hợp-các-môn-học-nền-tảng-trong-lĩnh-vực-an-toàn-thông-tin\"\u003eTổng hợp các môn học nền tảng trong lĩnh vực An toàn thông tin:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Mon_hoc_ATTT/Hinh_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/mon_hoc_attt/",
      "date_published": "10116-10-09T111:1010:00+07:00",
      "date_modified": "10116-10-09T111:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "723c5985cd30775db981679871c8c929e9fde725",
      "title": "HDR_WDR",
      "summary": "",
      "content_text": "Trên camera hành trình có thông tin như HDR và WDR.\nMình tổng hợp lại các thông tin đã research được.\nCả HDR (High Dynamic Range) và WDR (Wide Dynamic Range) đều là công nghệ giúp camera xử lý cảnh có độ tương phản cao (ví dụ: trời nắng chói + bóng tối sâu)\nNhưng chúng khác nhau về nguyên lý hoạt động, hiệu quả và ứng dụng.\nHDR (High Dynamic Range) Không cần cảm biến đặc biệt, chỉ cần xử lý hậu kỳ (post-processing) mạnh. Nguyên lý hoạt động: Kết hợp nhiều ảnh (thường 2–3 khung hình) chụp ở các mức phơi sáng khác nhau (underexposed, normal, overexposed) → ghép thành 1 ảnh duy nhất có dải sáng rộng. Nhược điểm: Chỉ tốt với cảnh tĩnh (dễ ghosting nếu có chuyển động). Tốn tài nguyên xử lý → có thể giảm FPS. Chất lượng màu sắc: Tốt hơn, màu tự nhiên, ít noise. Vì sao HDR quan trọng cho dashcam: WDR (Wide Dynamic Range) Có 2 dạng WDR là: True WDR và Digital WDR. Phụ thuộc chất lượng cảm biến. Chất lượng màu sắc: Tốt với hình ảnh chuyển động (không ghosting), nhưng có thể bệt màu nếu thuật toán kém Digital WDR (DWDR) Xử lý phần mềm: Xử lý hậu kỳ trên 1 khung hình duy nhất (tone mapping), điều chỉnh độ sáng từng vùng pixel riêng biệt. Nhược điểm: Mất chi tiết ở vùng sáng/tối Nhiễu cao True WDR (Hardware WDR) Là sự kết hợp phần cứng + phần mềm: Chụp đa khung hình thực tế và ghép hình thông minh. Cần cảm biến cao cấp (như Sony STARVIS). Kết luận: HDR = ghép nhiều ảnh → đẹp, chi tiết, nhưng dễ lỗi chuyển động. WDR = xử lý cảm biến → nhanh, mượt, phù hợp giám sát. True WDR \u0026gt; HDR \u0026gt; Digital WDR về chất lượng hình ảnh trong môi trường tương phản cao.\nChọn HDR nếu Chọn WDR nếu Chụp ảnh tĩnh, cần màu sắc đẹp Giám sát 24/7, có chuyển động Thiết bị tiêu dùng (điện thoại, GoPro) Camera an ninh chuyên dụng Chấp nhận ghosting để đổi lấy chi tiết Ưu tiên realtime, không ghosting ",
      "content_html": "\u003cp\u003eTrên camera hành trình có thông tin như \u003cstrong\u003eHDR\u003c/strong\u003e và \u003cstrong\u003eWDR\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình tổng hợp lại các thông tin đã research được.\u003c/p\u003e\n\u003cp\u003eCả \u003cstrong\u003eHDR (High Dynamic Range)\u003c/strong\u003e và \u003cstrong\u003eWDR (Wide Dynamic Range)\u003c/strong\u003e đều là \u003cstrong\u003ecông nghệ giúp camera xử lý cảnh có độ tương phản cao\u003c/strong\u003e (ví dụ: trời nắng chói + bóng tối sâu)\u003c/p\u003e\n\u003cp\u003eNhưng chúng khác nhau về nguyên lý hoạt động, hiệu quả và ứng dụng.\u003c/p\u003e\n\u003ch2 id=\"hdr-high-dynamic-range\"\u003eHDR (High Dynamic Range)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eKhông cần cảm biến đặc biệt, chỉ cần xử lý hậu kỳ (post-processing) mạnh.\u003c/li\u003e\n\u003cli\u003eNguyên lý hoạt động: Kết hợp nhiều ảnh (thường 2–3 khung hình) chụp ở các mức phơi sáng khác nhau (underexposed, normal, overexposed) → ghép thành 1 ảnh duy nhất có dải sáng rộng.\u003c/li\u003e\n\u003cli\u003eNhược điểm:\n\u003cul\u003e\n\u003cli\u003eChỉ tốt với cảnh tĩnh \u003cem\u003e(\u003cstrong\u003edễ ghosting\u003c/strong\u003e nếu có chuyển động)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTốn tài nguyên xử lý\u003c/strong\u003e → có thể giảm FPS.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eChất lượng màu sắc: Tốt hơn, màu tự nhiên, ít noise.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/HDR_WDR/HDR.jpg\"\n  alt=\"HDR\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVì sao \u003cstrong\u003eHDR\u003c/strong\u003e quan trọng cho dashcam:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/HDR_WDR/Hinh_1.png\"\n  alt=\"Hinh 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"wdr-wide-dynamic-rangehttpswwwdienmayxanhcomkinh-nghiem-haycong-nghe-wdr-la-gi-1391737srsltidafmbooo8bhdrntlozvilnu-c-ws4lrefpwbtspncgepkqbyay_k-ufbw\"\u003e\u003ca href=\"https://www.dienmayxanh.com/kinh-nghiem-hay/cong-nghe-wdr-la-gi-1391737?srsltid=AfmBOoo8bHdRnTLozVILNU-C-ws4lRefPwBtSpNcGepKQBYAY_k-ufBw\"\u003eWDR (Wide Dynamic Range)\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCó 2 dạng WDR là: True WDR và Digital WDR.\u003c/li\u003e\n\u003cli\u003ePhụ thuộc chất lượng cảm biến.\u003c/li\u003e\n\u003cli\u003eChất lượng màu sắc: Tốt với \u003cem\u003ehình ảnh chuyển động (\u003cstrong\u003ekhông ghosting\u003c/strong\u003e)\u003c/em\u003e, nhưng có thể bệt màu nếu thuật toán kém\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/HDR_WDR/WDR.webp\"\n  alt=\"WDR\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"digital-wdr-dwdr\"\u003eDigital WDR (DWDR)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXử lý phần mềm: Xử lý hậu kỳ trên 1 khung hình duy nhất (tone mapping), điều chỉnh độ sáng từng vùng pixel riêng biệt.\u003c/li\u003e\n\u003cli\u003eNhược điểm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eMất chi tiết ở vùng sáng/tối\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eNhiễu cao\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"true-wdr-hardware-wdr\"\u003eTrue WDR (Hardware WDR)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLà sự kết hợp \u003cstrong\u003ephần cứng + phần mềm\u003c/strong\u003e: Chụp đa khung hình thực tế và ghép hình thông minh.\u003c/li\u003e\n\u003cli\u003eCần cảm biến cao cấp (như Sony STARVIS).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/HDR_WDR/TrueWDR_DWDR.webp\"\n  alt=\"TrueWDR \u0026amp;amp; DWDR\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"kết-luận\"\u003eKết luận:\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eHDR = ghép nhiều ảnh → đẹp, chi tiết, nhưng dễ lỗi chuyển động.\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003e\u003cstrong\u003eWDR = xử lý cảm biến → nhanh, mượt, phù hợp giám sát.\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/HDR_WDR/Compare_1.png\"\n  alt=\"Compare 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eTrue WDR \u0026gt; HDR \u0026gt; Digital WDR về chất lượng hình ảnh trong môi trường tương phản cao.\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eChọn HDR nếu\u003c/th\u003e\n\u003cth\u003eChọn WDR nếu\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eChụp ảnh tĩnh, cần màu sắc đẹp\u003c/td\u003e\n\u003ctd\u003eGiám sát 24/7, có chuyển động\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eThiết bị tiêu dùng (điện thoại, GoPro)\u003c/td\u003e\n\u003ctd\u003eCamera an ninh chuyên dụng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eChấp nhận ghosting để đổi lấy chi tiết\u003c/td\u003e\n\u003ctd\u003eƯu tiên realtime, không ghosting\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/HDR_WDR/Compare_2.png\"\n  alt=\"Compare 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/hdr_wdr/",
      "date_published": "10116-10-09T1120:1010:00+07:00",
      "date_modified": "10116-10-09T1120:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "99937988debdf644c82faaaf93b23e766f300ffb",
      "title": "SafeLine",
      "summary": "",
      "content_text": "Bài viết tham khảo Từ bài viết này mình mới biết đến công cụ SafeLine, một công cụ Open-source WAF (Web Application Firewall).\nTài liệu tham khảo: Github SafeLine: https://github.com/chaitin/SafeLine Trang chủ SafeLine: https://safepoint.cloud/landing/safeline Documents: https://docs.waf.chaitin.com/en/GetStarted/Deploy https://docs.waf.chaitin.com/en/tutorials/advanced Tham khảo thêm: https://kungfutech.edu.vn/posts/huong-dan-su-dung-safeline-waf-tuong-lua-ung-dung-mien-phi https://www.youtube.com/watch?v=XIRAo9OP_LA https://www.youtube.com/watch?v=E9wOlS_rKuw SafeLine cũng đóng vai trò là một proxy-server, dựa trên docs thì cài đặt cũng không quá khó.\nNhưng cái ở đây mình không hiểu là cách setup routing traffic cho đúng mục đích thì mình vẫn chưa làm đc.\nTạm thời note lại để cập nhật kiến thức.\nHow it work ",
      "content_html": "\u003ch3 id=\"bài-viết-tham-khảohttpswwwlinkedincompulsesafeline-free-zero-trust-web-application-firewall-2026-jbk7ctrackingidxnkkirrxyjff7x8tcmemiw3d3d\"\u003e\u003ca href=\"https://www.linkedin.com/pulse/safeline-free-zero-trust-web-application-firewall-2026-jbk7c/?trackingId=XnkKirrxYjFF7X8tcmEmIw%3D%3D\"\u003eBài viết tham khảo\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTừ bài viết này mình mới biết đến công cụ \u003cstrong\u003eSafeLine\u003c/strong\u003e, một công cụ \u003cstrong\u003eOpen-source WAF\u003c/strong\u003e \u003cem\u003e(Web Application Firewall)\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo\"\u003eTài liệu tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGithub SafeLine: \u003ca href=\"https://github.com/chaitin/SafeLine\"\u003ehttps://github.com/chaitin/SafeLine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTrang chủ SafeLine: \u003ca href=\"https://safepoint.cloud/landing/safeline\"\u003ehttps://safepoint.cloud/landing/safeline\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocuments:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://docs.waf.chaitin.com/en/GetStarted/Deploy\nhttps://docs.waf.chaitin.com/en/tutorials/advanced\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTham khảo thêm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://kungfutech.edu.vn/posts/huong-dan-su-dung-safeline-waf-tuong-lua-ung-dung-mien-phi\nhttps://www.youtube.com/watch?v=XIRAo9OP_LA\nhttps://www.youtube.com/watch?v=E9wOlS_rKuw\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eSafeLine\u003c/strong\u003e cũng đóng vai trò là một \u003cstrong\u003eproxy-server\u003c/strong\u003e, dựa trên docs thì cài đặt cũng không quá khó.\u003c/p\u003e\n\u003cp\u003eNhưng cái ở đây mình không hiểu là cách setup \u003cstrong\u003erouting traffic\u003c/strong\u003e cho đúng mục đích thì mình vẫn chưa làm đc.\u003c/p\u003e\n\u003cp\u003eTạm thời note lại để cập nhật kiến thức.\u003c/p\u003e\n\u003ch3 id=\"how-it-work\"\u003eHow it work\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://raw.githubusercontent.com/chaitin/SafeLine/refs/heads/main/images/how-it-works.png\"\n  alt=\"How it work\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/safeline/",
      "date_published": "4116-04-09T1159:44:00+07:00",
      "date_modified": "4116-04-09T1159:44:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4ed7dd34343d20b8d4695d11bf1f3fca3341c7d6",
      "title": "Goi_cuoc_Internet",
      "summary": "",
      "content_text": "Mình dùng nhà mạng FPT, với góc cước META thông số là Download/Upload: 1Gbps\nĐể test gần bằng đúng thông số thì sẽ dùng đến WiFi 6, nhưng không phải thiết bị nào cũng support WiFi 6.\nNgoài ra, không hiểu sao trong đầu mình lại có câu hỏi là:\nTốc độ down/upload 1Gbps này là cho một thiết bị hay là tổng số các thiết bị trong hộ gia đình? Thế là đi đặt câu hỏi cho Grok-AI và đây là câu trả lời:\nVậy tức là Gói cước Download/Upload: 1Gbps chính là tổng dung lượng cho các thiết bị trong hộ gia đình kết nối Internet.\nĐiều này giải thích được một số điều mà mình đã gặp: Nếu một máy chiếm quá nhiều dung lượng đi Internet, thì các máy khác sẽ lag khi kết nối Internet. Giống như lúc trước trong ký túc xá, đang chơi game mà bị lag, thì sẽ hét lên \u0026ldquo;Thằng nào xem sex\u0026rdquo;. Hahahaha Ngoài ra mình biết thêm, công cụ speedtest sẽ cố gắng đẩy tốc độ lên tối đa mà thiết bị hỗ trợ. Có nghĩa nếu mình liên tục dùng speedtest thì những máy khác trong mạng có thể sẽ gặp tình trạng lag nhất thời Do đó mình chỉ nên speedtest khi thật sự cần thiết hoặc chỉ có máy của mình trong hệ thống. Do gói cước META là tổng Download/Upload cho hộ gia đình nên việc mình cần phân bổ cho đồng điều là việc cần thiết. Ví dụ: Vẫn dùng chuẩn WiFi 4 (2.4GHz và 5GHz) cho kết nối không dây. Dùng các tính năng như QoC (Quality of Service) trên ASUS hoặc chức năng Bandwith trên Aruba, Bandwith trên Fortigae để kiểm soát băng thông. ",
      "content_html": "\u003cp\u003eMình dùng nhà mạng FPT, với góc cước \u003cstrong\u003eMETA\u003c/strong\u003e thông số là \u003ccode\u003eDownload/Upload: 1Gbps\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eĐể test gần bằng đúng thông số thì sẽ dùng đến \u003cstrong\u003eWiFi 6\u003c/strong\u003e, nhưng không phải thiết bị nào cũng support WiFi 6.\u003c/p\u003e\n\u003cp\u003eNgoài ra, không hiểu sao trong đầu mình lại có câu hỏi là:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eTốc độ down/upload 1Gbps này là cho một thiết bị hay là tổng số các thiết bị trong hộ gia đình?\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThế là đi đặt câu hỏi cho Grok-AI và đây là câu trả lời:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Goi_cuoc_Internet/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Goi_cuoc_Internet/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eVậy tức là \u003cstrong\u003eGói cước Download/Upload: 1Gbps\u003c/strong\u003e chính là tổng dung lượng cho các thiết bị trong hộ gia đình kết nối Internet.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"điều-này-giải-thích-được-một-số-điều-mà-mình-đã-gặp\"\u003eĐiều này giải thích được một số điều mà mình đã gặp:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu một máy chiếm quá nhiều dung lượng đi Internet, thì các máy khác sẽ \u003cstrong\u003elag\u003c/strong\u003e khi kết nối Internet.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eGiống như lúc trước trong ký túc xá, đang chơi game mà bị lag, thì sẽ hét lên \u0026ldquo;Thằng nào xem sex\u0026rdquo;. Hahahaha\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eNgoài ra mình biết thêm, công cụ \u003ca href=\"https://www.speedtest.net/\"\u003espeedtest\u003c/a\u003e sẽ cố gắng đẩy tốc độ lên tối đa mà thiết bị hỗ trợ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eCó nghĩa nếu mình liên tục dùng speedtest thì những máy khác trong mạng có thể sẽ gặp tình trạng lag nhất thời\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eDo đó mình chỉ nên \u003cstrong\u003espeedtest khi thật sự cần thiết\u003c/strong\u003e hoặc chỉ có máy của mình trong hệ thống\u003c/em\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eDo gói cước META là \u003cstrong\u003etổng Download/Upload cho hộ gia đình\u003c/strong\u003e nên việc mình cần phân bổ cho đồng điều là việc cần thiết. Ví dụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eVẫn dùng chuẩn \u003cstrong\u003eWiFi 4 (2.4GHz và 5GHz)\u003c/strong\u003e cho kết nối không dây.\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eDùng các tính năng như \u003cstrong\u003eQoC (Quality of Service) trên ASUS\u003c/strong\u003e hoặc chức năng \u003cstrong\u003eBandwith trên Aruba\u003c/strong\u003e, \u003cstrong\u003eBandwith trên Fortigae\u003c/strong\u003e để kiểm soát băng thông.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/goi_cuoc_internet/",
      "date_published": "20106-20-09T1046:2020:00+07:00",
      "date_modified": "20106-20-09T1046:2020:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d1e601736ce64f0cd247d1fa1fb1739c75d790f8",
      "title": "SW_Model",
      "summary": "",
      "content_text": "Ban đầu mình chỉ nghe đến Scrum vs Agile\nVô tình xem được bài viết bên Vietnix về các mô hình software và biết thêm về các model này.\n4 MÔ HÌNH PHÁT TRIỂN PHẦN MỀM PHỔ BIẾN HIỆN NAY ",
      "content_html": "\u003cp\u003eBan đầu mình chỉ nghe đến \u003ca href=\"https://pma.edu.vn/blogs/scrum-vs-agile/?gad_source=1\u0026amp;gad_campaignid=22577955519\u0026amp;gbraid=0AAAAApCszYZRfQGNmsgOyTPq3E2TTkNRn\u0026amp;gclid=CjwKCAjwmNLHBhA4EiwA3ts3mb9-F5yt_Knxqrx2C1fvFUPBzlKTrl8TKdxGMjdwHQWDsQ5NKR0RLxoC1U4QAvD_BwE\"\u003eScrum vs Agile\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eVô tình xem được bài viết bên Vietnix về các mô hình software và biết thêm về các model này.\u003c/p\u003e\n\u003ch3 id=\"4-mô-hình-phát-triển-phần-mềm-phổ-biến-hiện-nayhttpswwwfacebookcomgroupsgroupsinhvienitposts1794196418174735\"\u003e\u003ca href=\"https://www.facebook.com/groups/groupsinhvienit/posts/1794196418174735/\"\u003e4 MÔ HÌNH PHÁT TRIỂN PHẦN MỀM PHỔ BIẾN HIỆN NAY\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/SW_Model/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/SW_Model/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/SW_Model/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/SW_Model/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/sw_model/",
      "date_published": "20106-20-09T1026:2020:00+07:00",
      "date_modified": "20106-20-09T1026:2020:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "43d317e2344220b87afa8b4ee6504ac1fac9d22b",
      "title": "MinIO",
      "summary": "",
      "content_text": " MinIO là giải pháp object storage mã nguồn mở, hiệu năng cao, và hoàn toàn tương thích với API của Amazon S3 Tài liệu: Github minio Tham khảo khác: https://200lab.io/blog/minio-la-gi https://docs.min.io/enterprise/aistor-object-store/reference/cli/ https://www.min.io/download?license=agpl\u0026amp;platform=linux Thông tin thêm khi hỏi Grok về MinIO và so sánh với FTP server, NAS Server Note Tạm thời thì hiểu như vậy về MinIO, mình đã có FTP Server và NAS Server. Nên cũng chưa hình dung áp dụng MinIO như nào. Có thể sẽ cần tìm hiểu thêm về object storage. ",
      "content_html": "\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eMinIO là giải pháp object storage mã nguồn mở, hiệu năng cao, và hoàn toàn tương thích với API của Amazon S3\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tài-liệu\"\u003eTài liệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/minio/minio\"\u003eGithub minio\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTham khảo khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://200lab.io/blog/minio-la-gi\nhttps://docs.min.io/enterprise/aistor-object-store/reference/cli/\nhttps://www.min.io/download?license=agpl\u0026amp;platform=linux\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThông tin thêm khi hỏi Grok về MinIO và so sánh với FTP server, NAS Server\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/MinIO/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/MinIO/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/MinIO/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/MinIO/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTạm thời thì hiểu như vậy về \u003cstrong\u003eMinIO\u003c/strong\u003e, mình đã có \u003cstrong\u003eFTP Server\u003c/strong\u003e và \u003cstrong\u003eNAS Server\u003c/strong\u003e. Nên cũng chưa hình dung áp dụng MinIO như nào.\u003c/li\u003e\n\u003cli\u003eCó thể sẽ cần tìm hiểu thêm về \u003ca href=\"https://fptcloud.com/object-storage/\"\u003eobject storage\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/minio/",
      "date_published": "16106-16-09T1041:1616:00+07:00",
      "date_modified": "16106-16-09T1041:1616:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7f3f11f5478a9e233c7c8cac100e2bfaec97f4b5",
      "title": "DevOps",
      "summary": "",
      "content_text": "Mình biết đến lĩnh vực DevOps cũng lâu rồi, nhưng nay tự nhiên lại muốn document.\nTheo mình hiểu đơn giản thì khi làm System đủ lâu, mà muốn phát triển lên thì vai trò tiếp theo chính là DevOps.\nLúc trước mình cũng lân la đi đọc JD của vai trò DevOps, học cơ bản về DevOps.\nVà khóa học free mà mình thấy hấp dẫn nhất chính là DevOps for Freshers\nelroydevops Với mình đây là trang web học về DevOps cực kỳ chất lượng. Không những có những khóa học cơ bản miễn phí, mà còn có những bài blog chia sẻ rất có tâm. Giúp mình củng cố kiến thức về linux, monitor, và hiểu thêm về Automation. Linux Xem thêm bài viết về Permission_Linux Tìm hiểu về chattr_Linux Command 1: chattr +i demofile.txt Command 2: chattr -i demofile.txt Cloud - AWS Chuyên mục DevOps Tài liệu AWS - Raspberry: https://docs.aws.amazon.com/iot/latest/developerguide/connecting-to-existing-device.html https://community.aws/content/2fmIjiV6VfXnoN1ABMJHO5OYR0W/getting-started-with-pico-w-iot-core?lang=en https://docs.aws.amazon.com/iot/latest/developerguide/iot-moisture-raspi-setup.html Ảo hóa - Docker Chạy Raspberry OS trên Docker: DockerPi docker run -it lukechilds/dockerpi Cài đặt công cụ IT-Tools bằng Docker: Docker IT-Tools docker run -d -p 8080:80 --name it-tools -it corentinth/it-tools Tham khảo khác: CND Storage Openstack kestra: Opensource automation tool. Ansible Cách sử dụng ansible Roadmap Tham khảo thêm về roadmap devops. PDF file ",
      "content_html": "\u003cp\u003eMình biết đến lĩnh vực \u003cstrong\u003eDevOps\u003c/strong\u003e cũng lâu rồi, nhưng nay tự nhiên lại muốn document.\u003c/p\u003e\n\u003cp\u003eTheo mình hiểu đơn giản thì \u003cstrong\u003ekhi làm System đủ lâu, mà muốn phát triển lên thì vai trò tiếp theo chính là DevOps\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eLúc trước mình cũng lân la đi đọc JD của vai trò DevOps, học cơ bản về DevOps.\u003c/p\u003e\n\u003cp\u003eVà khóa học free mà mình thấy hấp dẫn nhất chính là \u003ca href=\"https://elroydevops.tech/devops-for-fresher-kien-thuc-thuc-te/\"\u003eDevOps for Freshers\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"elroydevopshttpselroydevopstech\"\u003e\u003ca href=\"https://elroydevops.tech/\"\u003eelroydevops\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVới mình đây là trang web học về \u003cstrong\u003eDevOps\u003c/strong\u003e cực kỳ chất lượng.\u003c/li\u003e\n\u003cli\u003eKhông những có những khóa học cơ bản miễn phí, mà còn có những \u003cstrong\u003ebài blog chia sẻ rất có tâm\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eGiúp mình củng cố kiến thức về linux, monitor, và hiểu thêm về Automation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"linux\"\u003eLinux\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXem thêm bài viết về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/system-devops/permission_linux/\"\u003ePermission_Linux\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTìm hiểu về \u003ca href=\"https://devops.vn/posts/mot-cau-lenh-linux-cuc-ky-manh-me-ma-co-the-ban-chua-dung-bao-gio/\"\u003echattr_Linux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eCommand 1: \u003ccode\u003echattr +i demofile.txt\u003c/code\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eCommand 2: \u003ccode\u003echattr -i demofile.txt\u003c/code\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/DevOps/Linux_Admin.jpg\"\n  alt=\"Linux Admin\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"cloud---aws\"\u003eCloud - AWS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://elroydevops.tech/aws/\"\u003eChuyên mục DevOps\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu AWS - Raspberry:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://docs.aws.amazon.com/iot/latest/developerguide/connecting-to-existing-device.html\nhttps://community.aws/content/2fmIjiV6VfXnoN1ABMJHO5OYR0W/getting-started-with-pico-w-iot-core?lang=en\nhttps://docs.aws.amazon.com/iot/latest/developerguide/iot-moisture-raspi-setup.html\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/DevOps/AWS.jpg\"\n  alt=\"AWS\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ảo-hóa---docker\"\u003eẢo hóa - Docker\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eChạy \u003cstrong\u003eRaspberry OS trên Docker\u003c/strong\u003e: \u003ca href=\"https://github.com/lukechilds/dockerpi\"\u003eDockerPi\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker run -it lukechilds/dockerpi\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCài đặt công cụ \u003ca href=\"https://it-tools.tech/\"\u003eIT-Tools\u003c/a\u003e bằng Docker: \u003ca href=\"https://github.com/CorentinTh/it-tools\"\u003eDocker IT-Tools\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edocker run -d -p 8080:80 --name it-tools -it corentinth/it-tools\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tham-khảo-khác\"\u003eTham khảo khác:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=zM-6q54gu1w\u0026amp;list=PLUD8HYMnoROxPqDsDzyTagU3l6V1CbbAy\u0026amp;index=7\"\u003eCND\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=KhDz0uzoIXM\u0026amp;list=PLUD8HYMnoROxPqDsDzyTagU3l6V1CbbAy\u0026amp;index=3\"\u003eStorage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=ZqR34IwIor8\"\u003eOpenstack\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kestra-io/kestra\"\u003ekestra\u003c/a\u003e: Opensource automation tool.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://news.cloud365.vn/category/huong-dan/ansible/\"\u003eAnsible\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"https://elroydevops.tech/cach-su-dung-ansible-infrastructure-as-code/\"\u003eCách sử dụng ansible\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"roadmap\"\u003eRoadmap\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTham khảo thêm về \u003ca href=\"https://roadmap.sh/devops\"\u003eroadmap devops\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/devops_roadmap.pdf\"\u003ePDF file\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/DevOps/DevOps_Roadmap.jpg\"\n  alt=\"DevOps Roadmap\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/devops/",
      "date_published": "7106-07-09T101:77:00+07:00",
      "date_modified": "7106-07-09T101:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "5d8aaf7a5019239110f265cf078cbe636bc4a0b3",
      "title": "Xiaozhi_ESP32",
      "summary": "",
      "content_text": "Một Chatbot AI trên module ESP32-S3\nLink mua hàng trên shoppe Sơ đồ nút nhấn:\nTài liệu tham khảo: Github xiaozhi-esp32, và mô hình hoạt động của Xiaozhi: Tài liệu khác: https://ccnphfhqs21z.feishu.cn/wiki/Zpz4wXBtdimBrLk25WdcXzxcnNS https://ccnphfhqs21z.feishu.cn/wiki/F5krwD16viZoF0kKkvDcrZNYnhb https://github.com/78/xiaozhi-esp32/blob/main/README_en.md#an-mcp-based-chatbot Cách sử dụng cơ bản sản phẩm: Nhìn chung sản phẩm này đã được các pháp sư Trung Hoa làm sẵn cả rồi. Phần cứng cũng có, firmware cũng có sẵn, mình chỉ việc mua về và setting cho phù hợp với nhu cầu. Khi mua về, mình cắm dây USB Type C vào, thiết bị đã có sẵn Firmware, có thể dùng ngay được luôn. Ngoài ra kiểm tra thì cổng USB này vừa cấp nguồn vừa dùng để debug. Baud-rate cho Serial là 115200. Kết nối WiFi Thiết bị sẽ phát ra một wifi local, kết nối với wifi này. Truy cập link http://192.168.4.1/, sau đó kết nối với một mạng wifi sẵn có (mục đích là để thiết bị có kết nối Internet). Khi đã kết nối Internet thành công, mình thấy thiết bị download FW mới: Sau khi đã cập nhật OTA phiên bản V1.9.2, thiết bị sẽ có một đoạn mã nhỏ xuất hiện trên màn hình OLED. Truy cập link https://xiaozhi.me/, tiến hành Add Device, nhập mã code: Sau khi đã add thiết bị thành công, mình sẽ tiến hành Config: Đặt tên thiết bị là: Alo Ngôn ngữ sử dụng là: Tiếng Việt Sau đó save lại, rút nguồn thiết bị và cắm lại để áp dụng config. Bây giờ nút button (nhấn 1 lần), để bắt đầu trò chuyện với thiết bị. Hình dưới là log show ra của nội dung trò chuyện. Còn nhiều điều thú vị khác để vọc, như setup lại prompt cho AI, lịch sử trò chuyện,\u0026hellip; Tham khảo video khác: https://www.youtube.com/watch?v=8bkfMLDgnlE ",
      "content_html": "\u003cp\u003eMột \u003cstrong\u003eChatbot AI trên module ESP32-S3\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"link-mua-hàng-trên-shoppehttpssshopeevn3qdwjj0b1l\"\u003e\u003ca href=\"https://s.shopee.vn/3qDwJj0B1l\"\u003eLink mua hàng trên shoppe\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Ph%e1%ba%a7n_c%e1%bb%a9ng_1.webp\"\n  alt=\"Sản phẩm\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eSơ đồ nút nhấn:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Ph%e1%ba%a7n_c%e1%bb%a9ng_2.webp\"\n  alt=\"Sơ đồ nút nhấn\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo\"\u003eTài liệu tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/78/xiaozhi-esp32\"\u003eGithub xiaozhi-esp32\u003c/a\u003e, và mô hình hoạt động của \u003cstrong\u003eXiaozhi\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/M%c3%b4_h%c3%acnh.jpg\"\n  alt=\"Mô hình\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://ccnphfhqs21z.feishu.cn/wiki/Zpz4wXBtdimBrLk25WdcXzxcnNS\nhttps://ccnphfhqs21z.feishu.cn/wiki/F5krwD16viZoF0kKkvDcrZNYnhb\nhttps://github.com/78/xiaozhi-esp32/blob/main/README_en.md#an-mcp-based-chatbot\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"cách-sử-dụng-cơ-bản-sản-phẩm\"\u003eCách sử dụng cơ bản sản phẩm:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eNhìn chung sản phẩm này đã được các \u003cstrong\u003epháp sư Trung Hoa\u003c/strong\u003e làm sẵn cả rồi.\u003c/li\u003e\n\u003cli\u003ePhần cứng cũng có, firmware cũng có sẵn, mình chỉ việc mua về và setting cho phù hợp với nhu cầu.\u003c/li\u003e\n\u003cli\u003eKhi mua về, mình cắm dây USB Type C vào, \u003cstrong\u003ethiết bị đã có sẵn Firmware\u003c/strong\u003e, có thể dùng ngay được luôn.\u003c/li\u003e\n\u003cli\u003eNgoài ra kiểm tra thì cổng USB này vừa cấp nguồn vừa dùng để \u003cstrong\u003edebug\u003c/strong\u003e. Baud-rate cho Serial là \u003cstrong\u003e115200\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kết-nối-wifi\"\u003eKết nối WiFi\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThiết bị sẽ phát ra một wifi local, kết nối với wifi này.\u003c/li\u003e\n\u003cli\u003eTruy cập link \u003ccode\u003ehttp://192.168.4.1/\u003c/code\u003e, sau đó kết nối với một mạng wifi sẵn có \u003cem\u003e(mục đích là để thiết bị có kết nối Internet)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã kết nối Internet thành công, mình thấy thiết bị \u003cstrong\u003edownload FW mới\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi đã cập nhật \u003cstrong\u003eOTA\u003c/strong\u003e phiên bản \u003ccode\u003eV1.9.2\u003c/code\u003e, thiết bị sẽ có một đoạn mã nhỏ xuất hiện trên màn hình OLED.\u003c/li\u003e\n\u003cli\u003eTruy cập link \u003ccode\u003ehttps://xiaozhi.me/\u003c/code\u003e, tiến hành \u003cstrong\u003eAdd Device\u003c/strong\u003e, nhập mã code:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi đã add thiết bị thành công, mình sẽ tiến hành \u003cstrong\u003eConfig\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eĐặt tên thiết bị là: Alo\nNgôn ngữ sử dụng là: Tiếng Việt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau đó save lại, rút nguồn thiết bị và cắm lại để áp dụng config.\u003c/li\u003e\n\u003cli\u003eBây giờ nút button \u003cem\u003e(nhấn 1 lần)\u003c/em\u003e, để bắt đầu trò chuyện với thiết bị.\u003c/li\u003e\n\u003cli\u003eHình dưới là log show ra của nội dung trò chuyện.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Xiaozhi_ESP32/Hinh_6.png\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCòn nhiều điều thú vị khác để vọc, như setup lại prompt cho AI, lịch sử trò chuyện,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eTham khảo video khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=8bkfMLDgnlE\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/xiaozhi_esp32/",
      "date_published": "6106-06-09T1031:66:00+07:00",
      "date_modified": "6106-06-09T1031:66:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "67a51094c002a26663559c288f5f20af0cb1f6c6",
      "title": "NAS_FTP",
      "summary": "",
      "content_text": " Mục tiêu setup: Dễ dàng download firmware thiết bị. Một nơi để chia sẻ dữ liệu giữa máy tính và điện thoại di động.\nMình đã có sẵn NAS Server là OMV, giờ nghiên cứu cách để thiết lập FTP trên đây. Sau khi nghiên cứu thì OMV có support plugin để setup FTP Service. Tham khảo: https://forum.openmediavault.org/index.php?thread/29418-noob-guide-to-enabling-ftp-server-and-using-filezilla-client-remote-use/ https://www.youtube.com/watch?v=l7d7f-YNyQM \u0026mdash;\u0026gt; Mình đã cài thành công\nDownload file qua HTTP Ví dụ mình đã up một file FW lên FTP, với đường dẫn: /FTP-Share/Rust_for_ARM/Hello_ARM.png và mình vẫn phải đăng nhập bằng FTP, nếu muốn download. Không thể download trực tiếp bằng HTTP, vì giao thức FTP và HTTP là khác nhau wget https://www.vinhld-homelab.io.vn/FTP-Share/Rust_for_ARM/Hello_ARM.png OMV không tự động chuyển FTP sang HTTP/HTTPS, nhưng hỗ trợ FTPS (như đã giải thích trước) hoặc các giải pháp web-based. Nếu muốn download bằng HTTP thì có 2 cách: Cách 1: Cài web server (Nginx) trên OMV, ánh xạ thư mục FTP, và cấu hình HTTPS với chứng chỉ SSL. Cách 2: Sử dụng thêm plugin WebDAV (hoặc Nextcloud) trên OMV, để truy cập file qua HTTPS. ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eMục tiêu setup:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDễ dàng download firmware thiết bị\u003c/em\u003e. \u003c/br\u003e\n\u003cem\u003eMột nơi để chia sẻ dữ liệu giữa máy tính và điện thoại di động\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eMình đã có sẵn NAS Server là \u003cstrong\u003eOMV\u003c/strong\u003e, giờ nghiên cứu cách để thiết lập FTP trên đây.\u003c/li\u003e\n\u003cli\u003eSau khi nghiên cứu thì OMV có support plugin để setup \u003cstrong\u003eFTP Service\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTham khảo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://forum.openmediavault.org/index.php?thread/29418-noob-guide-to-enabling-ftp-server-and-using-filezilla-client-remote-use/\nhttps://www.youtube.com/watch?v=l7d7f-YNyQM\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u0026mdash;\u0026gt; Mình đã cài thành công\u003c/p\u003e\n\u003ch3 id=\"download-file-qua-http\"\u003eDownload file qua HTTP\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVí dụ mình đã up một file FW lên FTP, với đường dẫn: \u003ccode\u003e/FTP-Share/Rust_for_ARM/Hello_ARM.png\u003c/code\u003e và mình vẫn phải đăng nhập bằng FTP, nếu muốn download.\u003c/li\u003e\n\u003cli\u003eKhông thể \u003cstrong\u003edownload trực tiếp bằng HTTP\u003c/strong\u003e, vì giao thức FTP và HTTP là khác nhau\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewget https://www.vinhld-homelab.io.vn/FTP-Share/Rust_for_ARM/Hello_ARM.png\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eOMV không tự động chuyển FTP sang HTTP/HTTPS, nhưng hỗ trợ FTPS (như đã giải thích trước) hoặc các giải pháp web-based.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eNếu muốn download bằng HTTP thì có 2 cách:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eCách 1: Cài web server (Nginx) trên OMV, ánh xạ thư mục FTP, và cấu hình HTTPS với chứng chỉ SSL.\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eCách 2: Sử dụng thêm plugin WebDAV (hoặc Nextcloud) trên OMV, để truy cập file qua HTTPS.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/nas_ftp/",
      "date_published": "3106-03-09T1018:33:00+07:00",
      "date_modified": "3106-03-09T1018:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "73ebb96ac34433f46b396fb3efb242d0cdb4b736",
      "title": "CTF_Hardware",
      "summary": "",
      "content_text": " Date Mô tả 26/6/2025 Khởi tạo bài viết 02/10/2025 Ghi chú và tổng hợp các bài lab Blog về CTF Hardware https://github.com/AnduinBrian/anduinbrian.github.io https://anduinbrian.github.io/ Tài liệu: https://www.autosar.org/fileadmin/standards/R22-11/CP/AUTOSAR_SWS_CRCLibrary.pdf https://github.com/jopohl/urh https://github.com/RfidResearchGroup/proxmark3 https://github.com/compujuckel/ZigbeeOtaExtractor Tài liệu khác: AUTOSAR_SWS_CRCLibrary Android Application Security CheckList v2.0 Release Candidate romhack-revving-up_the-journey-to-pwn2own-automotive-2024 Tổng hợp các bài lab về Hardware Hacking: IoTGoat Danh sách các bài lab về Hardware hacking, của bên OWASP Từ Raspberry, linux, cho đến reverse. hackgnar/ble_ctf Một repo CTF để học về Bluetooth. Công cụ setup là dùng ESP32, tham khảo môi trường ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eDate\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e26/6/2025\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e02/10/2025\u003c/td\u003e\n\u003ctd\u003eGhi chú và tổng hợp các bài lab\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"blog-về-ctf-hardware\"\u003eBlog về CTF Hardware\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/AnduinBrian/anduinbrian.github.io\"\u003ehttps://github.com/AnduinBrian/anduinbrian.github.io\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://anduinbrian.github.io/\"\u003ehttps://anduinbrian.github.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.autosar.org/fileadmin/standards/R22-11/CP/AUTOSAR_SWS_CRCLibrary.pdf\nhttps://github.com/jopohl/urh\nhttps://github.com/RfidResearchGroup/proxmark3\nhttps://github.com/compujuckel/ZigbeeOtaExtractor\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tài-liệu-khác\"\u003eTài liệu khác:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/docs/ctf_hardware/AUTOSAR_SWS_CRCLibrary.pdf\"\u003eAUTOSAR_SWS_CRCLibrary\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/ctf_hardware/Android_Application_Security_CheckList_v2.0_Release_Candidate.xlsx\"\u003eAndroid Application Security CheckList v2.0 Release Candidate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/docs/ctf_hardware/romhack-revving-up_the-journey-to-pwn2own-automotive-2024.pdf\"\u003eromhack-revving-up_the-journey-to-pwn2own-automotive-2024\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"tổng-hợp-các-bài-lab-về-hardware-hacking\"\u003eTổng hợp các bài lab về Hardware Hacking:\u003c/h2\u003e\n\u003ch3 id=\"iotgoathttpsgithubcomowaspiotgoat\"\u003e\u003ca href=\"https://github.com/OWASP/IoTGoat\"\u003eIoTGoat\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDanh sách các bài lab về Hardware hacking, của bên \u003cstrong\u003eOWASP\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eTừ Raspberry, linux, cho đến reverse.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hackgnarble_ctfhttpsgithubcomhackgnarble_ctf\"\u003e\u003ca href=\"https://github.com/hackgnar/ble_ctf\"\u003ehackgnar/ble_ctf\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột repo \u003cstrong\u003eCTF để học về Bluetooth\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCông cụ setup là dùng ESP32, \u003ca href=\"https://github.com/hackgnar/ble_ctf/blob/master/docs/setup.md\"\u003etham khảo môi trường\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/ctf_hardware/",
      "date_published": "2106-02-09T1051:22:00+07:00",
      "date_modified": "2106-02-09T1051:22:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "54209856003fb747e760e65171d8278cc099cfc4",
      "title": "Ghost_ESP",
      "summary": "",
      "content_text": "Tài liệu Wiki GhostESP Tham khảo bài blog về Security_Hardware_Tools Tham khảo khác: https://github.com/jaylikesbunda/Ghost_ESP https://github.com/yaakov/Ghost_ESP_YS_fork https://www.youtube.com/watch?v=6RjM7aI4k4k Note: Project GhostESP này có thể dùng kết hợp với Flipper Zero, nó có một firmware riêng cho việc này. MCU ESP32: Ban đầu khi mình mới biết về dự án này thì người ta dùng ESP32-C3. Nhưng khi tìm hiểu và so sánh các dòng ESP32, thì ESP32-C3 rất yếu. Kiến trúc các dòng ESP32 cũng khác: Ngoài ra cũng search thì dự án Ghost_ESP này có thể dùng ESP32-S3. Nên mình lựa chọn test project này trên ESP32-S3. (Tham khảo thêm về Schematic ESP32-S3) Tài liệu về loại module này: https://github.com/WeActStudio/WeActStudio.ESP32S3-AorB https://github.com/WeActStudio/WeActStudio.ESP32S3-AorB/tree/main/ESP32S3-B/Doc Ghost_ESP dùng MCU ESP32-S3 - Hướng dẫn Trên ESP32 này có 2 cổng Type-C, thiết bị ghi là: 1 cổng là USB 1 cổng UART Để nạp đc Firmware, thì cần kết nối PC với cổng USB trên ESP32. Sau đó vào Trang nạp Firmware, thực hiện theo: Vậy là xong, rút nguồn và cắm lại là có thể sử dụng bình thường. Sử dụng command trực tiếp Lúc này sẽ cần kết nối PC với cổng USB (hoặc cổng UART) của ESP32. Setup baudrate là 115200 Ví dụ dùng command (tham khảo thêm tại đây): help help all Kết nối WiFi ESP32 sẽ phát ra một WiFi tên là GhostNet. Password cùng tên với SSID. Vậy thông tin kết nối wifi là: SSID: GhostNet Pass: GhostNet Truy cập link: http://ghostesp.local, thông tin đăng nhập tương tự như trên. Và đây là kết quả: Mình có thể sử dụng các tính năng và setting cho ESP32. Đánh giá Sau khi cài xong và test sơ lược và mình thấy công cụ Ghost_ESP này cũng không có gì đặc biệt. Có thể tại thời điểm hiện tại thì mình thấy vậy, nhưng chưa biết sau này sẽ có cải tiến những gì. Hoặc mình chưa biết cách tận dụng sức mạnh công cụ này, dẫu sao thì mình cứ document lại những gì đã làm được. ",
      "content_html": "\u003ch2 id=\"tài-liệu\"\u003eTài liệu\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jaylikesbunda/Ghost_ESP/wiki\"\u003eWiki \u003cstrong\u003eGhostESP\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTham khảo bài blog về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/security_hardware_tools/\"\u003eSecurity_Hardware_Tools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTham khảo khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/jaylikesbunda/Ghost_ESP\nhttps://github.com/yaakov/Ghost_ESP_YS_fork\nhttps://www.youtube.com/watch?v=6RjM7aI4k4k\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Project GhostESP này có thể dùng kết hợp với \u003cstrong\u003eFlipper Zero\u003c/strong\u003e, nó có một firmware riêng cho việc này.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"mcu-esp32\"\u003eMCU ESP32:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eBan đầu khi mình mới biết về dự án này thì người ta dùng \u003cstrong\u003eESP32-C3\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhưng khi tìm hiểu và so sánh các dòng ESP32, thì \u003cem\u003eESP32-C3\u003c/em\u003e rất yếu.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Compare_ESP32_1.png\"\n  alt=\"So sánh 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKiến trúc các dòng ESP32 cũng khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Compare_ESP32_2.png\"\n  alt=\"So sánh 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNgoài ra cũng search thì dự án Ghost_ESP này có thể dùng ESP32-S3.\u003c/li\u003e\n\u003cli\u003eNên mình lựa chọn test project này trên ESP32-S3. \u003cem\u003e(\u003ca href=\"/docs/ESP32_S3_B_Sch.pdf\"\u003eTham khảo thêm về Schematic ESP32-S3\u003c/a\u003e)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/ESP32-S3.webp\"\n  alt=\"ESP32-S3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu về loại module này:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/WeActStudio/WeActStudio.ESP32S3-AorB\nhttps://github.com/WeActStudio/WeActStudio.ESP32S3-AorB/tree/main/ESP32S3-B/Doc\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"ghost_esp-dùng-mcu-esp32-s3---hướng-dẫnhttpsghostespnet\"\u003eGhost_ESP dùng MCU ESP32-S3 - \u003ca href=\"https://ghostesp.net/\"\u003eHướng dẫn\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrên ESP32 này có 2 cổng Type-C, thiết bị ghi là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1 cổng là USB\n1 cổng UART\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐể nạp đc Firmware, thì cần \u003cstrong\u003ekết nối PC với cổng USB trên ESP32\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eSau đó vào \u003ca href=\"https://espressoflash.com\"\u003eTrang nạp Firmware\u003c/a\u003e, thực hiện theo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVậy là xong, rút nguồn và cắm lại là có thể sử dụng bình thường.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-command-trực-tiếp\"\u003eSử dụng command trực tiếp\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc này sẽ cần kết nối PC với cổng USB \u003cem\u003e\u003cstrong\u003e(hoặc cổng UART)\u003c/strong\u003e\u003c/em\u003e của ESP32.\u003c/li\u003e\n\u003cli\u003eSetup baudrate là \u003cstrong\u003e115200\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eVí dụ dùng command \u003cem\u003e(\u003ca href=\"https://github.com/Spooks4576/Ghost_ESP/wiki/Commands\"\u003etham khảo thêm tại đây\u003c/a\u003e)\u003c/em\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehelp\nhelp all\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"kết-nối-wifi\"\u003eKết nối WiFi\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eESP32 sẽ phát ra một WiFi tên là \u003cstrong\u003eGhostNet\u003c/strong\u003e. Password cùng tên với SSID.\u003c/li\u003e\n\u003cli\u003eVậy thông tin kết nối wifi là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSSID: GhostNet\nPass: GhostNet\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTruy cập link: \u003ccode\u003ehttp://ghostesp.local\u003c/code\u003e, thông tin đăng nhập tương tự như trên.\u003c/li\u003e\n\u003cli\u003eVà đây là kết quả:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Ghost_ESP/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMình có thể sử dụng các tính năng và setting cho ESP32.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"đánh-giá\"\u003eĐánh giá\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi cài xong và test sơ lược và mình thấy công cụ \u003cstrong\u003eGhost_ESP\u003c/strong\u003e này cũng không có gì đặc biệt.\u003c/li\u003e\n\u003cli\u003eCó thể tại thời điểm hiện tại thì mình thấy vậy, nhưng chưa biết sau này sẽ có cải tiến những gì.\u003c/li\u003e\n\u003cli\u003eHoặc mình chưa biết cách tận dụng sức mạnh công cụ này, dẫu sao thì mình cứ document lại những gì đã làm được.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/ghost_esp/",
      "date_published": "30096-30-09T910:3030:00+07:00",
      "date_modified": "30096-30-09T910:3030:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "067e496bcb58c2cc51982c894457589475bfac32",
      "title": "Pentest_API_Tools",
      "summary": "",
      "content_text": "Lụm được một bài viết của Vietnix, bài viết này giới thiệu các công cụ Pentest API.\n",
      "content_html": "\u003cp\u003eLụm được một bài viết của \u003cstrong\u003eVietnix\u003c/strong\u003e, bài viết này giới thiệu các công cụ \u003cstrong\u003ePentest API\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_0.jpg\"\n  alt=\"Hình 0\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_8.jpg\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_9.jpg\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Pentest_API_Tools/Hinh_10.jpg\"\n  alt=\"Hình 10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/pentest_api_tools/",
      "date_published": "25096-25-09T924:2525:00+07:00",
      "date_modified": "25096-25-09T924:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c6b7c2dd257e9b6ff7ac56115d5f0969eca3c6b1",
      "title": "Cau_chi_Oto",
      "summary": "",
      "content_text": " Ngày Mô tả 24/7/2025 Khởi tạo bài viết về cầu chì ô tô 24/9/2025 Bổ sung ghi chú về loại dây chia cầu chì Tham khảo về Cầu chì xe Vậy là trên xe ô tô, mình hay đụng nhất là các loại cầu chì dạng lưỡi dao (Blade fuses) Đôi khi người ta gọi: Standard - Chân to Mini - Chân nhỏ Micro - Chân cụt Một số hình ảnh và kích thước cầu chì: Standard - Chân to: Mini - Chân nhỏ: Micro - Chân cụt: Chia cầu chì: Khi lắp camera mà cần dùng đến Hardware Kit (hay Nguồn ACC), mà để không làm mất zin xe, thì mình có thể sử dụng công cụ Chia cầu chì.\nBộ công cụ test cầu chì Cách sử dụng (tham khảo)\nCách lắp cầu chì chuẩn, an toàn và Câu chuyện về rủi ro B+ -\u0026gt; Ghế điện (An toàn nhất là \u0026#34;ghế điện bên phụ\u0026#34;) (thường trực 12VDC) GND -\u0026gt; Mass sườn xe ACC -\u0026gt; Cầu chì USB (Khi mở máy thì sẽ là 12VDC) Ngoài ra có một số vị trí cũng có điện thường trực hay độ rủi ro sẽ lớn hơn so với vị trí ghế điện.\nVề nguyên tắc thì bất kì món nào mình lắp lên xe và khi xảy ra sự cố thì hãng đều có quyền từ chối bảo hành.\nCho dù có lắp camera hành trình với nguồn tẩu thuốc đi chăng nữa.\nDo đó khi xảy ra xự cố ngoài ý muốn thì chỉ có Thương lượng và tìm cách giải quyết.\nNgày 24/9/2025 Có một số vị trí cầu chì ban đầu tưởng là B+. Nhưng khoảng sau 10 phút hoặc 30 phút thì vị trí này bị mất nguồn \u0026ndash;\u0026gt; Các vị trí này vẫn được tính là ACC. Thành ra nên chọn đúng vị trí B+, luôn luôn có nguồn.\nDây chia cầu chì Trong thực tế, kỹ thuật sẽ dùng 2 loại cầu chì là: cầu chì 2A và 10A.\nNhư hình trên, ở vị trí B sẽ dùng loại cầu chì 2A \u0026ndash;\u0026gt; Để bảo vệ cho camera. Ở vị trí A là dùng cầu chì 10A (hoặc loại cầu chì theo xe) \u0026ndash;\u0026gt; Để bảo vệ cho xe ô tô. Sơ đồ cấu tạo của dây cầu chì Tham khảo bài viết Dựa vào sơ đồ thì khi gắn đúng chiều dòng điện có thể bảo vệ sản phẩm một cách an toàn nhất.\nChiều dòng điện đi vào, xác định bằng cách rút cầu chì trên xe ra và đo tại chân hộp cầu chì:\nLuôn có điện khi tắt-mở chìa khóa -\u0026gt; B+. Có điện 12V và mất điện 12V khi tắt-mở khóa -\u0026gt; ACC. Lắp đúng chiều In/Out:\nLắp sai chiều In/Out:\n",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e24/7/2025\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết về \u003cstrong\u003ecầu chì ô tô\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e24/9/2025\u003c/td\u003e\n\u003ctd\u003eBổ sung ghi chú về loại \u003cstrong\u003edây chia cầu chì\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"tham-khảo-về-cầu-chì-xehttpsotoeduvncau-chi-xe-o-to\"\u003e\u003ca href=\"https://oto.edu.vn/cau-chi-xe-o-to/\"\u003eTham khảo về Cầu chì xe\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVậy là trên xe ô tô, mình hay đụng nhất là các loại cầu chì dạng \u003cstrong\u003elưỡi dao\u003c/strong\u003e \u003cem\u003e(Blade fuses)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_2.webp\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐôi khi người ta gọi:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eStandard - Chân to\nMini - Chân nhỏ\nMicro - Chân cụt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_3.webp\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"một-số-hình-ảnh-và-kích-thước-cầu-chì\"\u003eMột số hình ảnh và kích thước cầu chì:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eStandard - Chân to:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_4.webp\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMini - Chân nhỏ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_5.webp\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMicro - Chân cụt:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_6.webp\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"chia-cầu-chì\"\u003eChia cầu chì:\u003c/h3\u003e\n\u003cp\u003eKhi lắp camera mà cần dùng đến \u003cstrong\u003eHardware Kit\u003c/strong\u003e \u003cem\u003e(hay Nguồn ACC)\u003c/em\u003e, mà để không làm \u003cstrong\u003emất zin\u003c/strong\u003e xe, thì mình có thể sử dụng công cụ \u003cstrong\u003eChia cầu chì\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_7.webp\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"bộ-công-cụ-test-cầu-chì\"\u003eBộ công cụ test cầu chì\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_8.webp\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eCách sử dụng \u003cem\u003e(tham khảo)\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/Hinh_9.webp\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"cách-lắp-cầu-chì-chuẩn-an-toàn-và-câu-chuyện-về-rủi-ro\"\u003eCách lắp cầu chì chuẩn, an toàn và Câu chuyện về rủi ro\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eB+ -\u0026gt; Ghế điện (An toàn nhất là \u0026#34;ghế điện bên phụ\u0026#34;) (thường trực 12VDC)\nGND -\u0026gt; Mass sườn xe\nACC -\u0026gt; Cầu chì USB (Khi mở máy thì sẽ là 12VDC)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNgoài ra có một số vị trí cũng có điện thường trực hay độ rủi ro sẽ lớn hơn so với vị trí ghế điện.\u003c/p\u003e\n\u003cp\u003eVề nguyên tắc thì bất kì món nào mình lắp lên xe và khi xảy ra sự cố thì \u003cstrong\u003ehãng đều có quyền từ chối bảo hành\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCho dù có lắp camera hành trình với nguồn tẩu thuốc đi chăng nữa.\u003c/p\u003e\n\u003cp\u003eDo đó khi xảy ra xự cố ngoài ý muốn thì chỉ có \u003cstrong\u003eThương lượng và tìm cách giải quyết\u003c/strong\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"ngày-2492025\"\u003eNgày 24/9/2025\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eCó một số vị trí \u003cstrong\u003ecầu chì ban đầu tưởng là B+\u003c/strong\u003e. Nhưng khoảng \u003cstrong\u003esau 10 phút hoặc 30 phút\u003c/strong\u003e thì vị trí này bị mất nguồn \u0026ndash;\u0026gt; \u003cstrong\u003eCác vị trí này vẫn được tính là ACC\u003c/strong\u003e\u003c/em\u003e. \u003c/br\u003e\n\u003cem\u003eThành ra nên chọn đúng vị trí B+, luôn luôn có nguồn.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"dây-chia-cầu-chì\"\u003eDây chia cầu chì\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/D%c3%a2y_c%e1%ba%a7u_ch%c3%ac.jpg\"\n  alt=\"Dây chia\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eTrong thực tế, kỹ thuật sẽ dùng 2 loại cầu chì là: \u003cstrong\u003ecầu chì 2A và 10A\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNhư hình trên, ở vị trí B sẽ dùng loại \u003ccode\u003ecầu chì 2A\u003c/code\u003e \u0026ndash;\u0026gt; \u003cstrong\u003eĐể bảo vệ cho camera\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eỞ vị trí A là dùng \u003ccode\u003ecầu chì 10A\u003c/code\u003e \u003cem\u003e(hoặc loại cầu chì theo xe)\u003c/em\u003e \u0026ndash;\u0026gt; \u003cstrong\u003eĐể bảo vệ cho xe ô tô.\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sơ-đồ-cấu-tạo-của-dây-cầu-chì\"\u003eSơ đồ cấu tạo của dây cầu chì\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"https://m.blog.naver.com/callmeho/222131666270\"\u003eTham khảo bài viết\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/S%c6%a1_%c4%91%e1%bb%93_d%c3%a2y.png\"\n  alt=\"Sơ đồ\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eDựa vào sơ đồ thì khi gắn đúng chiều dòng điện có thể bảo vệ sản phẩm một cách an toàn nhất.\u003c/p\u003e\n\u003cp\u003eChiều dòng điện đi vào, xác định bằng cách rút cầu chì trên xe ra và đo tại chân hộp cầu chì:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLuôn có điện khi tắt-mở chìa khóa -\u0026gt; B+.\u003c/li\u003e\n\u003cli\u003eCó điện 12V và mất điện 12V khi tắt-mở khóa -\u0026gt; ACC.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLắp \u003cstrong\u003eđúng\u003c/strong\u003e chiều \u003cstrong\u003eIn/Out\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/L%e1%ba%afp_%c4%91%c3%bang.png\"\n  alt=\"Đúng\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eLắp \u003cstrong\u003esai\u003c/strong\u003e chiều \u003cstrong\u003eIn/Out\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cau_chi_Oto/L%e1%ba%afp_sai.png\"\n  alt=\"Sai\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/cau_chi_oto/",
      "date_published": "24096-24-09T938:2424:00+07:00",
      "date_modified": "24096-24-09T938:2424:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "f993498d7d0ca16ec3327656bd200a0510b683eb",
      "title": "Security_Hardware_Tools",
      "summary": "",
      "content_text": "Về chủ đề Hardware Tools, mình đã có tìm hiểu và nói sơ lược trong khá nhiều bài viết liên quan.\nVí dụ là:\nSuy_nghi_ve_Hardware_Hacking Kali_for_ARM Bluetooth Sniffer Còn với bài viết này, mình vẫn sẽ nói về hardware tools, nhưng sẽ tập trung vào các công cụ có thể tự build được. Những dự án mã nguồn mở cho Hardware.\nBjorn_Raspberry Một công cụ được viết bằng python, giúp scan/attck network dành cho raspberry pi zero 2W. Video youtube: https://www.youtube.com/watch?v=1rKBnZx243o\u0026amp;list=WL\u0026amp;index=2 Project trên github: https://github.com/infinition/Bjorn https://github.com/infinition/Bjorn/blob/main/DEVELOPMENT.md Ghost_ESP Phần cứng ESP32-C3 Tham khảo youtube: https://www.youtube.com/watch?v=6RjM7aI4k4k https://www.youtube.com/watch?v=gYD5HfOBmGg Documents project: https://github.com/Spooks4576/Ghost_ESP https://github.com/jaylikesbunda/Ghost_ESP https://github.com/yaakov/Ghost_ESP_YS_fork Pico-ducky Một dự án tạo BadUSB dùng module raspberry pico. Tham khảo video youtube Documents: https://github.com/dbisu/pico-ducky https://circuitpython.org/board/raspberry_pi_pico/ https://workbook.securityboat.net/Pentesting/Physical/Raspberry%20Pi/usb-rubber-ducky-using-raspberry-pi-pico/ ESP32 Bus Pirate Documents: Github geo-tp/ESP32-Bus-Pirate Dự án này mình có thể dùng ESP32-S3, link sản phẩm tham khảo bên hshop Tài liệu về WeActStudio/WeActStudio.ESP32S3-AorB: ESP32_S3_B_Sch ESP32S3-B/Doc MeowKit Đây là một dự án mã nguồn mở dùng MCU ESP32, dự án đang hướng đến xây dựng một công cụ cạnh tranh trực tiếp với Fliper Zero. Tài liệu tham khảo: https://www.youtube.com/watch?v=_PpiFLb2m3w https://www.kickstarter.com/projects/1915038505/meowkit-versatile-device-for-makers https://github.com/happy-mingo/MeowKit https://espressif.github.io/esp-launchpad/ Công cụ này sẽ có các tính năng như: AI Chat - Xiaozhi BLE BEACON WiFi Spam BadUSB pr3y/Bruce Dự án này có các tính năng cũng tương tự như Flipper Zero, List Cài đặt Firmware online, flasher Bruce PCBs: https://github.com/pr3y/Bruce/tree/main/pcbs) https://bruce.computer/boards Tham khảo thêm tài liệu: https://github.com/pr3y/Bruce/wiki https://www.youtube.com/watch?v=BUwrWKDqtak\u0026amp;list=WL\u0026amp;index=4\u0026amp;pp=gAQBiAQB ",
      "content_html": "\u003cp\u003eVề chủ đề \u003cstrong\u003eHardware Tools\u003c/strong\u003e, mình đã có tìm hiểu và nói sơ lược trong khá nhiều bài viết liên quan.\u003c/p\u003e\n\u003cp\u003eVí dụ là:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/others/suy_nghi_ve_hardware_hacking/\"\u003eSuy_nghi_ve_Hardware_Hacking\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003e\u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/kali_for_arm/\"\u003eKali_for_ARM\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003e\u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/ble_sniffer/\"\u003eBluetooth Sniffer\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Hardware_Hacking.jpg\"\n  alt=\"Hardware Hacking Tools\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eCòn với bài viết này, mình vẫn sẽ nói về \u003cstrong\u003ehardware tools\u003c/strong\u003e, nhưng sẽ tập trung vào các công cụ có thể tự build được.\nNhững dự án mã nguồn mở cho Hardware.\u003c/p\u003e\n\u003ch3 id=\"bjorn_raspberry\"\u003eBjorn_Raspberry\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột công cụ được viết bằng python, giúp \u003cstrong\u003escan/attck network\u003c/strong\u003e dành cho raspberry pi zero 2W.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Tools/Bjorn_Raspberry.png\"\n  alt=\"Bjorn\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVideo youtube:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=1rKBnZx243o\u0026amp;list=WL\u0026amp;index=2\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eProject trên github:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/infinition/Bjorn\nhttps://github.com/infinition/Bjorn/blob/main/DEVELOPMENT.md\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"ghost_esp\"\u003eGhost_ESP\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://hshop.vn/kit-phat-trien-wifi-ble5-risc-v-soc-esp32-c3-super-mini-4mb\"\u003ePhần cứng ESP32-C3\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTham khảo youtube:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=6RjM7aI4k4k\nhttps://www.youtube.com/watch?v=gYD5HfOBmGg\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eDocuments project:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/Spooks4576/Ghost_ESP\nhttps://github.com/jaylikesbunda/Ghost_ESP\nhttps://github.com/yaakov/Ghost_ESP_YS_fork\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"pico-ducky\"\u003ePico-ducky\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột dự án tạo \u003cstrong\u003eBadUSB\u003c/strong\u003e dùng module \u003cstrong\u003eraspberry pico\u003c/strong\u003e. \u003ca href=\"https://www.youtube.com/watch?v=8obUvNkZdwc\"\u003eTham khảo video youtube\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocuments:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/dbisu/pico-ducky\nhttps://circuitpython.org/board/raspberry_pi_pico/\nhttps://workbook.securityboat.net/Pentesting/Physical/Raspberry%20Pi/usb-rubber-ducky-using-raspberry-pi-pico/\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"esp32-bus-piratehttpsgeo-tpgithubioesp32-bus-piratewebflasher\"\u003e\u003ca href=\"https://geo-tp.github.io/ESP32-Bus-Pirate/webflasher/\"\u003eESP32 Bus Pirate\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDocuments: \u003cem\u003e\u003ca href=\"https://github.com/geo-tp/ESP32-Bus-Pirate/wiki\"\u003eGithub \u003ccode\u003egeo-tp/ESP32-Bus-Pirate\u003c/code\u003e\u003c/a\u003e\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eDự án này mình có thể dùng ESP32-S3, \u003ca href=\"https://hshop.vn/kit-phat-trien-wifi-ble-soc-esp32-s3-weact-esp32-s3-b-n16r8-espressif-devkitc-1-compatible\"\u003elink sản phẩm tham khảo bên hshop\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu về \u003ca href=\"https://github.com/WeActStudio/WeActStudio.ESP32S3-AorB\"\u003eWeActStudio/WeActStudio.ESP32S3-AorB\u003c/a\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003ca href=\"/docs/ESP32_Bus_Pirate/ESP32_S3_B_Sch.pdf\"\u003eESP32_S3_B_Sch\u003c/a\u003e\u003c/em\u003e\n\u003cem\u003e\u003ca href=\"https://github.com/WeActStudio/WeActStudio.ESP32S3-AorB/tree/main/ESP32S3-B/Doc\"\u003eESP32S3-B/Doc\u003c/a\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"meowkit\"\u003eMeowKit\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một dự án mã nguồn mở dùng MCU \u003cstrong\u003eESP32\u003c/strong\u003e, dự án đang hướng đến xây dựng một công cụ cạnh tranh trực tiếp với \u003cstrong\u003eFliper Zero\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Tools/MeowKit/MeowKit_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu tham khảo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=_PpiFLb2m3w\nhttps://www.kickstarter.com/projects/1915038505/meowkit-versatile-device-for-makers\nhttps://github.com/happy-mingo/MeowKit\nhttps://espressif.github.io/esp-launchpad/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCông cụ này sẽ có các tính năng như:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eAI Chat - Xiaozhi\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eBLE BEACON\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eWiFi Spam\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eBadUSB\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Tools/MeowKit/MeowKit_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"pr3ybrucehttpsgithubcompr3ybruce\"\u003e\u003ca href=\"https://github.com/pr3y/Bruce\"\u003epr3y/Bruce\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDự án này có các tính năng cũng tương tự như Flipper Zero, \u003ca href=\"https://github.com/pr3y/Bruce?tab=readme-ov-file#computer-list-of-features\"\u003eList\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eCài đặt Firmware online, \u003ca href=\"https://bruce.computer/flasher\"\u003eflasher\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eBruce PCBs:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/pr3y/Bruce/tree/main/pcbs)\nhttps://bruce.computer/boards\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTham khảo thêm tài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/pr3y/Bruce/wiki\nhttps://www.youtube.com/watch?v=BUwrWKDqtak\u0026amp;list=WL\u0026amp;index=4\u0026amp;pp=gAQBiAQB\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/security_hardware_tools/",
      "date_published": "21096-21-09T94:2121:00+07:00",
      "date_modified": "21096-21-09T94:2121:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "0cf7a3bd1347e0a552811c7671d3cfd63b24de0a",
      "title": "Kali_for_ARM",
      "summary": "",
      "content_text": "Kali on ARM Vô tình xem youtube, mình thấy người ta làm công cụ hacking, dựa trên Raspberry.\nhttps://www.youtube.com/watch?v=mPpk8jhAGa4\u0026amp;list=WL\u0026amp;index=3 https://www.youtube.com/watch?v=km81ph7pZz8 Thế là phát hiện ra đã có rất nhiều bản image của Kali dành cho ARM.\nDocument lại để dành, sau này có time sẽ nghiên cứu từ từ.\nDự án Raspberry Pi Zero W P4wnP1 A.L.O.A Đây là dự án dành cho Raspberry Pi Zero W, dự án này có sẵn image. Image này đa dụng, nhưng mục tiêu chính là test HID Script. P4wnP1 Official Wiki Chỉ cần download về và cài đặt là có thể dùng. Tham khảo: https://github.com/RoganDawes/P4wnP1 https://github.com/RoganDawes/P4wnP1_aloa https://github.com/NightRang3r/P4wnP1-A.L.O.A.-Payloads https://drive.google.com/drive/folders/14XCb1sHFjzZa7OnzNZRt5AeTbEyZlZGf Dự án Raspberry Pi-Tail Zero 2 W Dự án này phù hợp cho các tác vụ thực địa như: Giám sát và phân tích mạng Wi-Fi. Kiểm tra bảo mật mạng cơ bản. Pentesting nhanh với các công cụ như wifite, kismet. Lý tưởng khi cần một thiết bị nhỏ gọn, dễ mang theo, tích hợp với điện thoại. ",
      "content_html": "\u003cp\u003e\u003ca href=\"https://www.kali.org/docs/arm/\"\u003eKali on ARM \u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eVô tình xem youtube, mình thấy người ta làm công cụ hacking, dựa trên Raspberry.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=mPpk8jhAGa4\u0026amp;list=WL\u0026amp;index=3\nhttps://www.youtube.com/watch?v=km81ph7pZz8\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThế là phát hiện ra đã có rất nhiều \u003cstrong\u003ebản image của Kali dành cho ARM\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eDocument lại để dành, sau này có time sẽ nghiên cứu từ từ.\u003c/p\u003e\n\u003ch3 id=\"dự-án-raspberry-pi-zero-w-p4wnp1-aloahttpswwwkaliorgdocsarmraspberry-pi-zero-w-p4wnp1-aloa\"\u003eDự án \u003ca href=\"https://www.kali.org/docs/arm/raspberry-pi-zero-w-p4wnp1-aloa/\"\u003eRaspberry Pi Zero W P4wnP1 A.L.O.A\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là dự án dành cho \u003cstrong\u003eRaspberry Pi Zero W\u003c/strong\u003e, dự án này có sẵn image.\u003c/li\u003e\n\u003cli\u003eImage này đa dụng, nhưng mục tiêu chính là test \u003cstrong\u003eHID Script\u003c/strong\u003e. \u003ca href=\"https://p4wnp1.readthedocs.io/en/latest/\"\u003eP4wnP1 Official Wiki\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eChỉ cần download về và cài đặt là có thể dùng. Tham khảo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/RoganDawes/P4wnP1\nhttps://github.com/RoganDawes/P4wnP1_aloa\nhttps://github.com/NightRang3r/P4wnP1-A.L.O.A.-Payloads\nhttps://drive.google.com/drive/folders/14XCb1sHFjzZa7OnzNZRt5AeTbEyZlZGf\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"dự-án-raspberry-pi-tail-zero-2-whttpswwwkaliorgdocsarmraspberry-pi-zero-2-w-pi-tail\"\u003eDự án \u003ca href=\"https://www.kali.org/docs/arm/raspberry-pi-zero-2-w-pi-tail/\"\u003eRaspberry Pi-Tail Zero 2 W\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDự án này phù hợp cho các tác vụ thực địa như:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGiám sát và phân tích mạng Wi-Fi.\nKiểm tra bảo mật mạng cơ bản.\nPentesting nhanh với các công cụ như wifite, kismet.\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eLý tưởng khi cần một thiết bị nhỏ gọn, dễ mang theo, tích hợp với điện thoại.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/kali_for_arm/",
      "date_published": "21096-21-09T923:2121:00+07:00",
      "date_modified": "21096-21-09T923:2121:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d650745ab978a4df02f97fb68f4ef8ea6c16e421",
      "title": "BlueTeam",
      "summary": "",
      "content_text": "Blue-Team Tools Wireshark Filter Threat Intelligence Tools Radware: Live Threat Map Một công cụ online (real-time), để xem các thông tin về các cuộc tấn công mạng trên thế giới. Malware Analysis Malware Analysis là một phần của Blue-Team. Nhưng ở mức độ phức tạp hơn rất nhiều. Malware Analysis (phân tích mã độc) có thể được xem là một nhánh hoặc một ứng dụng của Reverse Engineering (RE) (kỹ nghệ đảo ngược) Ngoài ra, mình cũng có một bài viết về công cụ cho RE, tham khảo thêm RE_Tool_BinaryNinjaFree. Đây là hình mô tả nhiệm vụ của phân tích mã đọc: ",
      "content_html": "\u003ch3 id=\"blue-team-tools\"\u003eBlue-Team Tools\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BlueTeam/Blue_Team_Tools.jpg\"\n  alt=\"Tools\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"wireshark-filter\"\u003eWireshark Filter\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BlueTeam/Wireshark_Filter.jpg\"\n  alt=\"Wireshark_Filter\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"threat-intelligence-tools\"\u003eThreat Intelligence Tools\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BlueTeam/TI_Tools.jfif\"\n  alt=\"TI Tools\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"radware-live-threat-maphttpslivethreatmapradwarecom\"\u003e\u003ca href=\"https://livethreatmap.radware.com/\"\u003eRadware: Live Threat Map\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eMột công cụ online \u003cstrong\u003e(real-time)\u003c/strong\u003e, để xem các thông tin về các cuộc tấn công mạng trên thế giới\u003c/em\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BlueTeam/Radware-Live_Threat_Map.png\"\n  alt=\"Live Threat Map\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"malware-analysis\"\u003eMalware Analysis\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMalware Analysis\u003c/strong\u003e là một phần của \u003cstrong\u003eBlue-Team\u003c/strong\u003e. Nhưng ở mức độ phức tạp hơn rất nhiều.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eMalware Analysis (phân tích mã độc)\u003c/strong\u003e có thể được xem là một nhánh hoặc một ứng dụng của \u003cstrong\u003eReverse Engineering (RE) (kỹ nghệ đảo ngược)\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eNgoài ra, mình cũng có một bài viết về công cụ cho RE, tham khảo thêm \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/re_tool_binaryninjafree/\"\u003eRE_Tool_BinaryNinjaFree\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eĐây là hình mô tả nhiệm vụ của phân tích mã đọc:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BlueTeam/Malware_Analysis.png\"\n  alt=\"Malware Analysis\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/blueteam/",
      "date_published": "16096-16-09T953:1616:00+07:00",
      "date_modified": "16096-16-09T953:1616:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "101ddf258848dd5a99a97fc806696d3b87397047",
      "title": "RedTeam",
      "summary": "",
      "content_text": " Ngày Mô tả 15/6/2024 Khởi tạo bài viết. 16/9/2025 Bổ sung thêm về Kali Cheatsheet và Dark Web 5 free red teaming resources to get you started Red Team Notes Red Teaming Handbook Red Team Tools Red Teaming Toolkit Các giao thức mạng cơ bản: Tổng hợp các công cụ cho Red-Team: Cập nhật 16/9/2025 Kali Cheatsheet Dark Web ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e15/6/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e16/9/2025\u003c/td\u003e\n\u003ctd\u003eBổ sung thêm về \u003cstrong\u003eKali Cheatsheet\u003c/strong\u003e và \u003cstrong\u003eDark Web\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"5-free-red-teaming-resources-to-get-you-startedhttpswwwhelpnetsecuritycom20240416free-red-teaming-resources\"\u003e\u003ca href=\"https://www.helpnetsecurity.com/2024/04/16/free-red-teaming-resources/\"\u003e5 free red teaming resources to get you started\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dmcxblue.gitbook.io/red-team-notes-2-0\"\u003eRed Team Notes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://assets.publishing.service.gov.uk/media/61702155e90e07197867eb93/20210625-Red_Teaming_Handbook.pdf\"\u003eRed Teaming Handbook\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/A-poc/RedTeam-Tools\"\u003eRed Team Tools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/infosecn1nja/Red-Teaming-Toolkit\"\u003eRed Teaming Toolkit\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"các-giao-thức-mạng-cơ-bản\"\u003eCác giao thức mạng cơ bản:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Common_Network_Protocols.jpg\"\n  alt=\"Network Protocols\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tổng-hợp-các-công-cụ-cho-red-team\"\u003eTổng hợp các công cụ cho Red-Team:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Red_Team_Tools.jpg\"\n  alt=\"Red Team Tools\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-1692025\"\u003eCập nhật 16/9/2025\u003c/h2\u003e\n\u003ch3 id=\"kali-cheatsheet\"\u003eKali Cheatsheet\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_1.jpg\"\n  alt=\"Hinh 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_2.jpg\"\n  alt=\"Hinh 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_3.jpg\"\n  alt=\"Hinh 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_4.jpg\"\n  alt=\"Hinh 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_5.jpg\"\n  alt=\"Hinh 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_6.jpg\"\n  alt=\"Hinh 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_7.jpg\"\n  alt=\"Hinh 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Kali_Cheatsheet/Hinh_8.jpg\"\n  alt=\"Hinh 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"dark-web\"\u003eDark Web\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Dark_Web/Hinh_1.jpg\"\n  alt=\"Hinh 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Dark_Web/Hinh_2.jpg\"\n  alt=\"Hinh 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Dark_Web/Hinh_3.jpg\"\n  alt=\"Hinh 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Dark_Web/Hinh_4.jpg\"\n  alt=\"Hinh 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Dark_Web/Hinh_5.jpg\"\n  alt=\"Hinh 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/RedTeam/Dark_Web/Hinh_6.jpg\"\n  alt=\"Hinh 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/redteam/",
      "date_published": "16096-16-09T95:1616:00+07:00",
      "date_modified": "16096-16-09T95:1616:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e6a995aea20bce46ad28ecdc6a25901c5a49dc93",
      "title": "The_nho",
      "summary": "",
      "content_text": "Thẻ nhớ là một trong những phần cứng quan trọng cho các thiết bị như Raspberry Pi, Camera hành trình,\u0026hellip;\nViệc lựa chọn thẻ nhớ phù hợp, tốc độ đọc/ghi cao là yếu tố vô cùng quan trọng để giúp thiết bị hoạt động ổn định nhất.\nBảng so sánh: STT Tiêu chí Thẻ_XC Thẻ_A1 Thẻ_A2 1 Hình minh họa 2 Class hiệu năng Không áp dụng (thẻ gốc cũ) A1 A2 3 UHS Speed Class U1 hoặc U3 tùy loại U1 hoặc U3 tùy loại U3 4 Video Speed Class Có thể không có hoặc V10/V30 V10 hoặc V30 V30 5 Tốc độ ghi tối thiểu 10MB/s (U1), 30MB/s (U3) 10MB/s (U1), 30MB/s (U3) 30MB/s 6 Tốc độ IOPS (Random RW) Không công bố IOPS ≥ 1500 đọc / 500 ghi IOPS ≥ 4000 đọc / 2000 ghi 7 Tốc độ đọc lý thuyết ~80-100MB/s (tuỳ loại UHS) ~100MB/s ~100MB/s 8 Mục đích sử dụng phù hợp Camera hành trình phổ thông, lưu trữ Ứng dụng Android, camera hành trình, game nhẹ Android, camera 4K, app lớn, ghi hình chuyên sâu XC (SDXC): Là chuẩn thẻ hỗ trợ dung lượng \u0026gt;32GB đến 2TB. Không có nghĩa là tốc độ cao, phụ thuộc vào UHS và Video Class. A1 \u0026amp; A2: Là chuẩn dành riêng cho thiết bị Android. A2 vượt trội hơn A1 về tốc độ truy xuất ngẫu nhiên (IOPS) — điều quan trọng khi chạy ứng dụng từ thẻ nhớ. Tài liệu tham khảo: https://www.sdcard.org/developers/sd-standard-overview/capacity-sd-sdhc-sdxc-sduc/ https://www.sdcard.org/developers/sd-standard-overview/speed-class/ https://www.sdcard.org/developers/sd-standard-overview/application-performance-class/ A2 (Application Performance class 2): yêu cầu tối thiểu 4.000 IOPS read và 2.000 IOPS write dùng cho thiết bị chạy app (Android, Linux) V30 (Video Speed Class 30): dành cho quay video 4K, đảm bảo tốc độ ghi liên tục ≥ 30 MB/s CardCamera SpeedClass Thông tin so sánh và cập nhật thêm từ Grok-AI:\nUHD So sánh SDHC và SDXC Phân biệt tốc độ của thẻ Micro SD Định dạng phù hợp chung cho TF-card: Thẻ nhớ TF-card (hay còn gọi là MicroSD card) có thể được định dạng với nhiều file system khác nhau tùy theo dung lượng và mục đích sử dụng. Định dạng phù hợp nhất thường phụ thuộc vào dung lượng thẻ và thiết bị sử dụng (như điện thoại, máy ảnh, máy chơi game). Tài liệu tham khảo: https://www.reddit.com/r/SwitchPirates/comments/10vjb39/what_microsd_format_do_i_need_exfat_or_fat32/ https://www.linkedin.com/pulse/choosing-best-file-format-sd-card-external-hard-drive-dip-sard/ FAT32 Đây là định dạng phổ biến và tương thích cao nhất với hầu hết các thiết bị. Tuy nhiên, nó có giới hạn file size tối đa 4GB và dung lượng phân vùng tối đa lý thuyết 2TB (thực tế thường dùng cho thẻ nhỏ). FAT32 phù hợp nhất cho thẻ MicroSDHC (dung lượng từ 4GB đến 32GB). exFAT Phù hợp hơn cho thẻ dung lượng lớn, hỗ trợ file size lớn hơn 4GB. Hỗ trợ dung lượng lớn và file size không giới hạn thực tế, lý tưởng cho lưu trữ video 4K, file lớn. exFAT phù hợp nhất cho thẻ MicroSDXC (dung lượng từ 64GB trở lên). Đối với camera Đối với camera hành trình thì định dạng thẻ nhớ là FAT32, không phân biệt dung lượng của thẻ. Ví dụ về một thẻ nhớ 64GB, dùng với camera hành trình của Vietmap: Ví dụ về một thẻ nhớ 64GB, dùng với camera hành trình của 70mai: ",
      "content_html": "\u003cp\u003eThẻ nhớ là một trong những phần cứng quan trọng cho các thiết bị như Raspberry Pi, Camera hành trình,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eViệc lựa chọn thẻ nhớ phù hợp, tốc độ đọc/ghi cao là yếu tố vô cùng quan trọng để giúp thiết bị hoạt động ổn định nhất.\u003c/p\u003e\n\u003ch3 id=\"bảng-so-sánh\"\u003eBảng so sánh:\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003eSTT\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eTiêu chí\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eThẻ_XC\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eThẻ_A1\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eThẻ_A2\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eHình minh họa\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cimg\n  src=\"/image/IoT/The_nho/The_SDXC.png\"\n  alt=\"XC\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/td\u003e\n\u003ctd\u003e\u003cimg\n  src=\"/image/IoT/The_nho/The_A1.jpg\"\n  alt=\"A1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/td\u003e\n\u003ctd\u003e\u003cimg\n  src=\"/image/IoT/The_nho/The_A2V30.png\"\n  alt=\"A2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eClass hiệu năng\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eKhông áp dụng (thẻ gốc cũ)\u003c/td\u003e\n\u003ctd\u003eA1\u003c/td\u003e\n\u003ctd\u003eA2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eUHS Speed Class\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eU1 hoặc U3 tùy loại\u003c/td\u003e\n\u003ctd\u003eU1 hoặc U3 tùy loại\u003c/td\u003e\n\u003ctd\u003eU3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eVideo Speed Class\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eCó thể không có hoặc V10/V30\u003c/td\u003e\n\u003ctd\u003eV10 hoặc V30\u003c/td\u003e\n\u003ctd\u003eV30\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eTốc độ ghi tối thiểu\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e10MB/s (U1), 30MB/s (U3)\u003c/td\u003e\n\u003ctd\u003e10MB/s (U1), 30MB/s (U3)\u003c/td\u003e\n\u003ctd\u003e30MB/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eTốc độ IOPS (Random RW)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eKhông công bố\u003c/td\u003e\n\u003ctd\u003eIOPS ≥ 1500 đọc / 500 ghi\u003c/td\u003e\n\u003ctd\u003eIOPS ≥ 4000 đọc / 2000 ghi\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eTốc độ đọc lý thuyết\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e~80-100MB/s (tuỳ loại UHS)\u003c/td\u003e\n\u003ctd\u003e~100MB/s\u003c/td\u003e\n\u003ctd\u003e~100MB/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eMục đích sử dụng phù hợp\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eCamera hành trình phổ thông, lưu trữ\u003c/td\u003e\n\u003ctd\u003eỨng dụng Android, camera hành trình, game nhẹ\u003c/td\u003e\n\u003ctd\u003eAndroid, camera 4K, app lớn, ghi hình chuyên sâu\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eXC (SDXC)\u003c/strong\u003e: Là chuẩn thẻ hỗ trợ dung lượng \u0026gt;32GB đến 2TB. Không có nghĩa là tốc độ cao, phụ thuộc vào UHS và Video Class.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eA1 \u0026amp; A2\u003c/strong\u003e: Là chuẩn dành riêng cho thiết bị Android. A2 vượt trội hơn A1 về tốc độ truy xuất ngẫu nhiên (IOPS) — điều quan trọng khi chạy ứng dụng từ thẻ nhớ.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo\"\u003eTài liệu tham khảo:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.sdcard.org/developers/sd-standard-overview/capacity-sd-sdhc-sdxc-sduc/\nhttps://www.sdcard.org/developers/sd-standard-overview/speed-class/\nhttps://www.sdcard.org/developers/sd-standard-overview/application-performance-class/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003eA2 (Application Performance class 2)\u003c/strong\u003e: yêu cầu tối thiểu 4.000 IOPS read và 2.000 IOPS write dùng cho thiết bị chạy app (Android, Linux)\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eV30 (Video Speed Class 30)\u003c/strong\u003e: dành cho quay video 4K, đảm bảo tốc độ ghi liên tục ≥ 30 MB/s\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003ch4 id=\"cardcamera\"\u003eCardCamera\u003c/h4\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/CardCameraEN.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch4 id=\"speedclass\"\u003eSpeedClass\u003c/h4\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/SpeedClass9.1EN.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eThông tin so sánh và cập nhật thêm từ Grok-AI:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/Hinh_6.png\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch4 id=\"uhd\"\u003eUHD\u003c/h4\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/UHD.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"so-sánh-sdhc-và-sdxc\"\u003eSo sánh SDHC và SDXC\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"phân-biệt-tốc-độ-của-thẻ-micro-sd\"\u003ePhân biệt tốc độ của thẻ Micro SD\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"định-dạng-phù-hợp-chung-cho-tf-card\"\u003eĐịnh dạng phù hợp chung cho TF-card:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThẻ nhớ TF-card \u003cem\u003e(hay còn gọi là MicroSD card)\u003c/em\u003e có thể được định dạng với nhiều file system khác nhau tùy theo dung lượng và mục đích sử dụng.\u003c/li\u003e\n\u003cli\u003eĐịnh dạng phù hợp nhất thường phụ thuộc vào dung lượng thẻ và thiết bị sử dụng (như điện thoại, máy ảnh, máy chơi game).\u003c/li\u003e\n\u003cli\u003eTài liệu tham khảo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.reddit.com/r/SwitchPirates/comments/10vjb39/what_microsd_format_do_i_need_exfat_or_fat32/\nhttps://www.linkedin.com/pulse/choosing-best-file-format-sd-card-external-hard-drive-dip-sard/\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"fat32\"\u003eFAT32\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là định dạng phổ biến và tương thích cao nhất với hầu hết các thiết bị.\u003c/li\u003e\n\u003cli\u003eTuy nhiên, nó có \u003cstrong\u003egiới hạn file size tối đa 4GB\u003c/strong\u003e và \u003cstrong\u003edung lượng phân vùng tối đa lý thuyết 2TB\u003c/strong\u003e (thực tế thường dùng cho thẻ nhỏ).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/FAT32.jpg\"\n  alt=\"FAT32\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFAT32 phù hợp nhất cho thẻ MicroSDHC \u003cem\u003e\u003cstrong\u003e(dung lượng từ 4GB đến 32GB)\u003c/strong\u003e\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"exfat\"\u003eexFAT\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePhù hợp hơn cho thẻ dung lượng lớn, \u003cstrong\u003ehỗ trợ file size lớn hơn 4GB\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHỗ trợ dung lượng lớn và file size không giới hạn thực tế, lý tưởng cho lưu trữ video 4K, file lớn.\u003c/li\u003e\n\u003cli\u003eexFAT phù hợp nhất cho thẻ MicroSDXC \u003cem\u003e\u003cstrong\u003e(dung lượng từ 64GB trở lên)\u003c/strong\u003e\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"đối-với-camera\"\u003eĐối với camera\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐối với camera hành trình thì định dạng thẻ nhớ là \u003cstrong\u003eFAT32\u003c/strong\u003e, không phân biệt dung lượng của thẻ.\u003c/li\u003e\n\u003cli\u003eVí dụ về một thẻ nhớ 64GB, dùng với \u003cstrong\u003ecamera hành trình của Vietmap\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVí dụ về một thẻ nhớ 64GB, dùng với \u003cstrong\u003ecamera hành trình của 70mai\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/The_nho/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/the_nho/",
      "date_published": "11096-11-09T920:1111:00+07:00",
      "date_modified": "11096-11-09T920:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4588559f7713a39e1c12b122392fe9292de604b0",
      "title": "Voice_Command",
      "summary": "",
      "content_text": "Sản phẩm phần cứng Voice Command DFRobot Gravity: Offline Language Learning Voice Recognition Sensor Sản phẩm Giá tham khảo bên Hshop Giá bán: 486.000₫ Mạch nhận dạng giọng nói Offline Voice Recognition VC-02 Kit Ai-thinker Giá bán: 165.000₫ Video Youtube so sánh ",
      "content_html": "\u003ch1 id=\"sản-phẩm-phần-cứng-voice-command\"\u003eSản phẩm phần cứng Voice Command\u003c/h1\u003e\n\u003ch2 id=\"dfrobot-gravity-offline-language-learning-voice-recognition-sensor\"\u003eDFRobot Gravity: Offline Language Learning Voice Recognition Sensor\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://techiesms.com/product/gravity-offline-voice-recognition-sensor-i2c-uart-dfrobot/\"\u003eSản phẩm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGiá tham khảo bên \u003ca href=\"https://hshop.vn/mach-nhan-dang-giong-noi-dfrobot-gravity-offline-language-learning-voice-recognition-sensor\"\u003eHshop\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGiá bán: 486.000₫\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Voice_Command/Hinh_1.webp\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"mạch-nhận-dạng-giọng-nói-offline-voice-recognition-vc-02-kit-ai-thinkerhttpshshopvnmach-nhan-dang-giong-noi-offline-voice-recognition-vc-02-kit-ai-thinker\"\u003e\u003ca href=\"https://hshop.vn/mach-nhan-dang-giong-noi-offline-voice-recognition-vc-02-kit-ai-thinker\"\u003eMạch nhận dạng giọng nói Offline Voice Recognition VC-02 Kit Ai-thinker\u003c/a\u003e\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGiá bán: 165.000₫\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Voice_Command/Hinh_3.webp\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"video-youtube-so-sánhhttpswwwyoutubecomwatchvacy1vwedll8\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=AcY1vWEDll8\"\u003eVideo Youtube so sánh\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Voice_Command/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/voice_command/",
      "date_published": "9096-09-09T90:99:00+07:00",
      "date_modified": "9096-09-09T90:99:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "17d8dcca8b236d6708d2b543b5a83c7c9b328bc5",
      "title": "Speedtest_ARMv7l",
      "summary": "",
      "content_text": "Với những dòng camera sử dụng Linux và có dùng module 4G.\nMình có thể dùng công cụ như speedtest để đo tốc độ mạng trên kiến trúc của chip ARMv7l\nTham khảo thêm từ Grok AI về các libarary cho công cụ speedtest:\nhttps://github.com/librespeed/speedtest-cli https://www.speedtest.net/apps/cli Lưu ý là phải đảm bảo thiết bị có kết nối mạng. Trước khi thực hiện các bước bên dưới.\nDownload công cụ: wget -O speedtest.tgz https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-armhf.tgz tar xzvf speedtest.tgz Kiểm tra xem có work hay không: ./speedtest --version Speedtest và Khắc phục lỗi về Cert Download: wget https://curl.se/ca/cacert.pem Sau đó thực hiện các command: mkdir /etc/ssl mkdir /etc/ssl/certs touch /etc/ssl/certs/ca-certificates.crt mv cacert.pem /etc/ssl/certs/ca-certificates.crt chmod 644 /etc/ssl/certs/ca-certificates.crt export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt Đã chạy lệnh thành công: ./speedtest ",
      "content_html": "\u003cp\u003eVới những dòng camera sử dụng \u003cstrong\u003eLinux\u003c/strong\u003e và có dùng \u003cstrong\u003emodule 4G\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình có thể dùng công cụ như \u003cstrong\u003espeedtest\u003c/strong\u003e để đo tốc độ mạng trên kiến trúc của chip \u003cstrong\u003eARMv7l\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTham khảo thêm từ \u003cstrong\u003eGrok AI\u003c/strong\u003e về các libarary cho công cụ speedtest:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/librespeed/speedtest-cli\nhttps://www.speedtest.net/apps/cli\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003e\u003cstrong\u003eLưu ý là phải đảm bảo thiết bị có kết nối mạng. Trước khi thực hiện các bước bên dưới\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"download-công-cụ\"\u003eDownload công cụ:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewget -O speedtest.tgz https://install.speedtest.net/app/cli/ookla-speedtest-1.2.0-linux-armhf.tgz\ntar xzvf speedtest.tgz\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eKiểm tra xem có work hay không:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./speedtest --version\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Speedtest_ARMv7l/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"speedtest-và-khắc-phục-lỗi-về-cert\"\u003eSpeedtest và Khắc phục lỗi về \u003ccode\u003eCert\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDownload:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewget https://curl.se/ca/cacert.pem\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eSau đó thực hiện các command:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emkdir /etc/ssl\nmkdir /etc/ssl/certs\ntouch /etc/ssl/certs/ca-certificates.crt\nmv cacert.pem /etc/ssl/certs/ca-certificates.crt\nchmod 644 /etc/ssl/certs/ca-certificates.crt\nexport SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐã chạy lệnh thành công:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./speedtest\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Speedtest_ARMv7l/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/speedtest_armv7l/",
      "date_published": "29086-29-09T832:2929:00+07:00",
      "date_modified": "29086-29-09T832:2929:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "842edb3199db1d335485244db5f65c6bbbe2543c",
      "title": "Power_ACC_USB_Type_C",
      "summary": "",
      "content_text": "Changelog Ngày Mô tả 25/6/2025 Bài viết về bộ nguồn ACC (Hardware Kit) 28/8/2025 Thiết bị test và test-case Trong hình là mình có một bộ nguồn ACC kết nối với camera, hỗ trợ chất năng Ghi hình đỗ xe. Tham khảo về thêm về Bộ nguồn trực tiếp ACC Mình đã thử nghiên cứu thì đánh giá như sau: Nguyên tắc hoạt động chính: Là chuyển đổi mức điện áp từ 12VDC -\u0026gt; 5VDC.\nSử dụng một board nhỏ của USB Type C ra chân Kiểm tra và đọc thêm tài liệu An Engineer\u0026rsquo;s Guide to USB Type-C (có thể dùng bản online ở đây) Thiết bị camera sẽ có chân đọc tín hiệu digital của ACC \u0026ndash;\u0026gt; Từ đó nhận diện đc trạng thái. Vị trí tương ứng: Dây USB Type C pintout B+ (5VDC) A4, A9, B4, B9 GND A1, A12, B1, B12 ACC (5VDC) A5, B5 Note: USB Type C pintout chân A5 và B5 chính là CC2.\nCập nhật ngày 28/8/2025 Thiết bị test Mô tả Thiết bị có đồng hồ nhỏ, luôn đo điện áp đầu ra của cổng type C. Khi trạng thái ACC ON, bóng đèn led nhỏ sẽ sáng lên. Test-case Chuẩn bị một bộ nguồn điều chỉnh điện áp. Một bộ giả lập trạng thái ACC. Một bộ dây nguồn ACC (Hardware Kit). Và thiết bị test (như hình trên) Mức điện áp 12VDC ACC Điện áp Trạng thái thiết bị test ACC ON \u0026gt; 11.5VDC Thiết bị có điện áp và đèn sáng ACC OFF \u0026gt; 11.5VDC Thiết bị có điện áp, đèn không sáng ACC OFF \u0026lt;= 11.5VDC Thiết bị ban đầu có điện áp, sau 3s sẽ không còn đo điện áp, đèn không sáng ACC ON \u0026lt;= 11.5VDC Thiết bị có điện áp trở lại và đèn sáng Mức điện áp 24VDC Lưu ý: Cần tắt hết tất cả các thiết bị, và chọn đúng mức điện áp ngay từ đầu là 24VDC. Để tránh bộ HW kit nhận sai mức điện áp. ACC Điện áp Trạng thái thiết bị test ACC ON \u0026gt; 23.5VDC Thiết bị có điện áp và đèn sáng ACC OFF \u0026gt; 23.5VDC Thiết bị có điện áp, đèn không sáng ACC OFF \u0026lt;= 23.5VDC Thiết bị ban đầu có điện áp, sau 3s sẽ không còn đo điện áp, đèn không sáng ACC ON \u0026lt;= 23.5VDC Thiết bị có điện áp trở lại và đèn sáng =\u0026gt; Bộ Hardware Kit ở ngưỡng 12VDC và 24VDC đã hoạt động đúng chức năng Khi ACC ON thì sẽ luôn có điện áp, cho camera luôn hoạt động Còn khi ACC OFF và mức điện áp dưới ngưỡng, HW kit sẽ tự động ngắt nguồn để bảo vệ bình ắc-quy.\n",
      "content_html": "\u003ch2 id=\"changelog\"\u003eChangelog\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e25/6/2025\u003c/td\u003e\n\u003ctd\u003eBài viết về \u003cstrong\u003ebộ nguồn ACC\u003c/strong\u003e \u003cem\u003e(Hardware Kit)\u003c/em\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e28/8/2025\u003c/td\u003e\n\u003ctd\u003eThiết bị test và test-case\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Power_ACC_USB_Type_C/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong hình là mình có một bộ nguồn ACC kết nối với camera, hỗ trợ chất năng \u003cstrong\u003eGhi hình đỗ xe\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTham khảo về thêm về \u003ca href=\"https://www.youtube.com/watch?v=RfN08YqmJwU\"\u003eBộ nguồn trực tiếp ACC\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMình đã thử nghiên cứu thì đánh giá như sau:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eNguyên tắc hoạt động chính: Là \u003cstrong\u003echuyển đổi mức điện áp từ 12VDC -\u0026gt; 5VDC\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"sử-dụng-một-board-nhỏ-của-usb-type-c-ra-chânhttpsshopeevnme1baa1ch-ra-chc3a2n-hc3a0n-ce1bb95ng-usb-31-type-c-sang-dip-24pin-i151012458826531551404xptdk375e62e1-f176-43d2-967a-59548adc26cf\"\u003eSử dụng một board nhỏ của \u003ca href=\"https://shopee.vn/M%E1%BA%A1ch-Ra-Ch%C3%A2n-(h%C3%A0n)-C%E1%BB%95ng-USB-3.1-Type-C-Sang-DIP-24pin-i.1510124588.26531551404?xptdk=375e62e1-f176-43d2-967a-59548adc26cf\"\u003eUSB Type C ra chân\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Power_ACC_USB_Type_C/Hinh_2.webp\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKiểm tra và đọc thêm tài liệu \u003ca href=\"/docs/An_Engineer_Guide_to_USB_Type-C.pdf\"\u003eAn Engineer\u0026rsquo;s Guide to USB Type-C\u003c/a\u003e \u003cem\u003e(có thể dùng bản \u003ca href=\"https://www.ti.com/lit/eb/slyy228/slyy228.pdf?HQS=app-ipp-pwr-denusbc-bhp-ebook-null-de\"\u003eonline ở đây\u003c/a\u003e)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Power_ACC_USB_Type_C/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eThiết bị camera sẽ có chân đọc tín hiệu digital của ACC\u003c/strong\u003e \u0026ndash;\u0026gt; Từ đó nhận diện đc trạng thái.\u003c/li\u003e\n\u003cli\u003eVị trí tương ứng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eDây\u003c/th\u003e\n\u003cth\u003eUSB Type C pintout\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eB+ (5VDC)\u003c/td\u003e\n\u003ctd\u003eA4, A9, B4, B9\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGND\u003c/td\u003e\n\u003ctd\u003eA1, A12, B1, B12\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC (5VDC)\u003c/td\u003e\n\u003ctd\u003eA5, B5\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eNote:\u003c/strong\u003e \u003ccode\u003eUSB Type C pintout\u003c/code\u003e chân \u003cstrong\u003eA5\u003c/strong\u003e và \u003cstrong\u003eB5\u003c/strong\u003e chính là \u003cstrong\u003eCC2\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-ngày-2882025\"\u003eCập nhật ngày 28/8/2025\u003c/h2\u003e\n\u003ch3 id=\"thiết-bị-test\"\u003eThiết bị test\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Power_ACC_USB_Type_C/Hinh_4.jpg\"\n  alt=\"Thiết bị\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"mô-tả\"\u003eMô tả\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThiết bị có đồng hồ nhỏ, luôn đo \u003cstrong\u003eđiện áp đầu ra của cổng type C\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eKhi trạng thái \u003cstrong\u003eACC ON\u003c/strong\u003e, bóng đèn led nhỏ sẽ sáng lên.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"test-case\"\u003eTest-case\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eChuẩn bị một bộ nguồn điều chỉnh điện áp.\u003c/li\u003e\n\u003cli\u003eMột bộ giả lập trạng thái ACC.\u003c/li\u003e\n\u003cli\u003eMột bộ dây nguồn ACC \u003cem\u003e(Hardware Kit)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eVà thiết bị test \u003cem\u003e(như hình trên)\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mức-điện-áp-12vdc\"\u003eMức điện áp \u003ccode\u003e12VDC\u003c/code\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eACC\u003c/th\u003e\n\u003cth\u003eĐiện áp\u003c/th\u003e\n\u003cth\u003eTrạng thái thiết bị test\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC ON\u003c/td\u003e\n\u003ctd\u003e\u0026gt; 11.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị có điện áp và đèn sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC OFF\u003c/td\u003e\n\u003ctd\u003e\u0026gt; 11.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị có điện áp, đèn không sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC OFF\u003c/td\u003e\n\u003ctd\u003e\u0026lt;= 11.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị ban đầu có điện áp, \u003cstrong\u003esau 3s\u003c/strong\u003e sẽ không còn đo điện áp, đèn không sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC ON\u003c/td\u003e\n\u003ctd\u003e\u0026lt;= 11.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị có điện áp trở lại và đèn sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"mức-điện-áp-24vdc\"\u003eMức điện áp \u003ccode\u003e24VDC\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLưu ý: Cần tắt hết tất cả các thiết bị, và chọn đúng mức điện áp ngay từ đầu là 24VDC.\u003c/li\u003e\n\u003cli\u003eĐể tránh bộ HW kit nhận sai mức điện áp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eACC\u003c/th\u003e\n\u003cth\u003eĐiện áp\u003c/th\u003e\n\u003cth\u003eTrạng thái thiết bị test\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC ON\u003c/td\u003e\n\u003ctd\u003e\u0026gt; 23.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị có điện áp và đèn sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC OFF\u003c/td\u003e\n\u003ctd\u003e\u0026gt; 23.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị có điện áp, đèn không sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC OFF\u003c/td\u003e\n\u003ctd\u003e\u0026lt;= 23.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị ban đầu có điện áp, \u003cstrong\u003esau 3s\u003c/strong\u003e sẽ không còn đo điện áp, đèn không sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eACC ON\u003c/td\u003e\n\u003ctd\u003e\u0026lt;= 23.5VDC\u003c/td\u003e\n\u003ctd\u003eThiết bị có điện áp trở lại và đèn sáng\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003e=\u0026gt; Bộ Hardware Kit ở ngưỡng 12VDC và 24VDC đã hoạt động đúng chức năng\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eKhi ACC ON thì sẽ luôn có điện áp, cho camera luôn hoạt động\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eCòn khi ACC OFF và mức điện áp dưới ngưỡng, HW kit sẽ tự động ngắt nguồn để bảo vệ bình ắc-quy\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/power_acc_usb_type_c/",
      "date_published": "28086-28-09T840:2828:00+07:00",
      "date_modified": "28086-28-09T840:2828:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e056d249e7fc46743d7a29efa2140793d6a808ec",
      "title": "Fabric_AI",
      "summary": "",
      "content_text": "Hiện tại thời điểm này (8/2025) mình đang dùng ChatGPT plus, chi phí hàng tháng là 20$. và đã dùng được 4 tháng.\nMình thì thấy bản thân dùng GPT cũng không nhiều, chưa tận dụng được hết các tính năng của GPT (như chế độ tác nhân, giao tiếp qua âm thanh,\u0026hellip;)\nNên mình muốn hạn chế phần chi phí này, và đang nghĩ đến dùng Fabric AI + OpenAI API. Mục tiêu là để tạo ra một ứng dụng có WebUI có chức năng gần giống như chatGPT.\nFabric Tài liệu tham khảo: https://danielmiessler.com/blog/fabric-origin-story https://www.youtube.com/watch?v=lEXd6TXPw7E Điểm mạnh của Fabric chính là các prompt có sẵn, ngoài ra còn phù hợp với nhiều loại mô hình AI khác. Mình đã cài thử Fabric, có thử tạo prompt test cho riêng mình và dùng API của OpenAI. Kết quả cũng OK. Note Cái này cần thời gian để kiểm chứng, kiểm chứng về sự tiện lợi. Và trên hết là chi phí, để xem dùng API có giúp mình tiết kiệm hay không. Ngoài ra, khi dùng API của OpenAI thì cần phải sử dụng model mới nhất, để có dữ liệu cập nhật mới nhất. ",
      "content_html": "\u003cp\u003eHiện tại thời điểm này (8/2025) mình đang dùng \u003cstrong\u003eChatGPT plus\u003c/strong\u003e, chi phí hàng tháng là \u003cstrong\u003e20$\u003c/strong\u003e. và đã dùng được 4 tháng.\u003c/p\u003e\n\u003cp\u003eMình thì thấy bản thân dùng GPT cũng không nhiều, chưa tận dụng được hết các tính năng của GPT \u003cem\u003e(như \u003cstrong\u003echế độ tác nhân\u003c/strong\u003e, \u003cstrong\u003egiao tiếp qua âm thanh\u003c/strong\u003e,\u0026hellip;)\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eNên mình muốn hạn chế phần chi phí này, và đang nghĩ đến dùng \u003cstrong\u003eFabric AI + OpenAI API\u003c/strong\u003e. Mục tiêu là để tạo ra một ứng dụng có WebUI có chức năng gần giống như chatGPT.\u003c/p\u003e\n\u003ch3 id=\"fabrichttpsgithubcomdanielmiesslerfabric\"\u003e\u003ca href=\"https://github.com/danielmiessler/Fabric\"\u003eFabric\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Fabric_AI/Hinh_1.webp\"\n  alt=\"Logo Fabric\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu tham khảo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://danielmiessler.com/blog/fabric-origin-story\nhttps://www.youtube.com/watch?v=lEXd6TXPw7E\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐiểm mạnh của \u003cstrong\u003eFabric\u003c/strong\u003e chính là các prompt có sẵn, ngoài ra còn phù hợp với nhiều loại mô hình AI khác.\u003c/li\u003e\n\u003cli\u003eMình đã cài thử Fabric, có thử tạo prompt test cho riêng mình và dùng API của OpenAI.\u003c/li\u003e\n\u003cli\u003eKết quả cũng OK.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Fabric_AI/Hinh_2.png\"\n  alt=\"Kết quả test Fabric\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCái này cần thời gian để kiểm chứng, kiểm chứng về sự tiện lợi.\u003c/li\u003e\n\u003cli\u003eVà trên hết là chi phí, để xem dùng API có giúp mình tiết kiệm hay không.\u003c/li\u003e\n\u003cli\u003eNgoài ra, khi dùng API của OpenAI thì cần phải sử dụng model mới nhất, để có dữ liệu cập nhật mới nhất.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Fabric_AI/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/fabric_ai/",
      "date_published": "9086-09-09T829:99:00+07:00",
      "date_modified": "9086-09-09T829:99:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "ef86db82f2f6fefa5a2d07bb267fab8234800ad0",
      "title": "Android_Xiaomi",
      "summary": "",
      "content_text": "Android Xiaomi, người ta nói nó như là Apple Trung Quốc vậy.\nNên có những tính năng mà điện thoại này có đi theo hệ sinh thái của nó.\nMình sẽ tìm và note thêm những tính năng hay ho khác của xiaomi phone.\nTính năng Ghi màn hình Mình dùng Redmi Note 11 vẫn hỗ trợ Ghi màn hình. Không cần cài đặt app thứ 3 bên ngoài. Ứng dụng ShareMe - Tham khảo youtube Ứng dụng này cũng có sẵn trên Xiaomi. Ứng dụng cho phép mình kết nối và chia sẻ dữ liệu giữa PC và Mobile thông qua WiFi (cùng mạng cục bộ) Mình đã thử và cho thể truy cập vào kho dữ liệu của thiết bị (share qua giao thức FTP). ",
      "content_html": "\u003cp\u003e\u003cstrong\u003eAndroid Xiaomi\u003c/strong\u003e, người ta nói nó như là \u003cstrong\u003eApple Trung Quốc\u003c/strong\u003e vậy.\u003c/p\u003e\n\u003cp\u003eNên có những tính năng mà điện thoại này có đi theo \u003cstrong\u003ehệ sinh thái\u003c/strong\u003e của nó.\u003c/p\u003e\n\u003cp\u003eMình sẽ tìm và note thêm những tính năng hay ho khác của \u003cem\u003exiaomi phone\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"tính-năng-ghi-màn-hìnhhttpswwwmicomvnsupportfaqdetailska-504379\"\u003eTính năng \u003ca href=\"https://www.mi.com/vn/support/faq/details/KA-504379/\"\u003eGhi màn hình\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình dùng \u003cstrong\u003eRedmi Note 11\u003c/strong\u003e vẫn hỗ trợ \u003cstrong\u003eGhi màn hình\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eKhông cần cài đặt app thứ 3 bên ngoài.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Android_Xiaomi/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ứng-dụng-shareme---tham-khảo-youtubehttpswwwyoutubecomwatchv0zsyeduvet4\"\u003eỨng dụng ShareMe - \u003ca href=\"https://www.youtube.com/watch?v=0zSYedUveT4\"\u003eTham khảo youtube\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eỨng dụng này cũng có sẵn trên Xiaomi.\u003c/li\u003e\n\u003cli\u003eỨng dụng cho phép mình kết nối và chia sẻ dữ liệu giữa PC và Mobile thông qua WiFi \u003cem\u003e(cùng mạng cục bộ)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eMình đã thử và cho thể truy cập vào kho dữ liệu của thiết bị \u003cem\u003e(share qua giao thức FTP)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Android_Xiaomi/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/android_xiaomi/",
      "date_published": "8086-08-09T85:88:00+07:00",
      "date_modified": "8086-08-09T85:88:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "58b0ff98ab19672dd4c471a9f2c29f79daff103d",
      "title": "Cloud_Sim",
      "summary": "",
      "content_text": "Trong quá trình test về camera có module sim, mình gặp tình trạng lạ là không có sim, nhưng thiết bị vẫn online bỉnh thường.\nNhững tính năng online đều hoạt động được, sau khi tham khảo và tìm hiểu thì có thể module sim đang dùng tính năng Cloud Sim.\nTham khảo video: https://www.youtube.com/watch?v=xu6-P9lm3H4 Tham khảo chatGPT ",
      "content_html": "\u003cp\u003eTrong quá trình test về camera có module sim, mình gặp tình trạng lạ là \u003cstrong\u003ekhông có sim, nhưng thiết bị vẫn online bỉnh thường\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNhững tính năng online đều hoạt động được, sau khi tham khảo và tìm hiểu thì có thể module sim đang dùng tính năng \u003cstrong\u003eCloud Sim\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"tham-khảo-video-httpswwwyoutubecomwatchvxu6-p9lm3h4\"\u003eTham khảo video: \u003ca href=\"https://www.youtube.com/watch?v=xu6-P9lm3H4\"\u003ehttps://www.youtube.com/watch?v=xu6-P9lm3H4\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tham-khảo-chatgpt\"\u003eTham khảo chatGPT\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cloud_Sim/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cloud_Sim/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cloud_Sim/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Cloud_Sim/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/cloud_sim/",
      "date_published": "26076-26-09T75:2626:00+07:00",
      "date_modified": "26076-26-09T75:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "f7e60b0a4141adf8a485f262304b9bb76be17af4",
      "title": "SSh_ARMv7",
      "summary": "",
      "content_text": "Tải Dropbear bản đã biên dịch sẵn cho ARM Trên PC, mình chạy command: wget https://bitfab.org/dropbear-static-builds/dropbear-v2020.81-arm-none-linux-gnueabi-static.tgz tar xzf dropbear-v2020.81-arm-none-linux-gnueabi-static.tgz Do mình dùng wsl, nên để biết được thư mục lưu trữ nằm ở đâu, thì dùng thêm command: explorer.exe . Sau đó mình sẽ thấy thư mục chứa file dropbearmulti, và mình sẽ copy nó vào camera. Thông tin về file dropbearmulti: File thu được là dropbearmulti, tham khảo chatGPT thì:\nĐây là file đa chức năng (multi-binary), có thể đóng vai trò như: dropbear (SSH server) dropbearkey (tạo host key) dbclient (SSH client) scp (copy file qua SSH) Kết nối Camera thông qua cổng UART của thiết bị: Thực hiện một số command: mkdir -p /usr/sbin /etc/dropbear cp dropbearmulti /usr/sbin/ chmod +x /usr/sbin/dropbearmulti Tạo symlink để sử dụng từng chức năng: ln -s /usr/sbin/dropbearmulti /usr/bin/dropbear ln -s /usr/sbin/dropbearmulti /usr/bin/dropbearkey ln -s /usr/sbin/dropbearmulti /usr/bin/dbclient ln -s /usr/sbin/dropbearmulti /usr/bin/scp Tạo SSH host key: dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key Run: dropbear -r /etc/dropbear/dropbear_rsa_host_key Note: SSH yêu cầu khi kết nối cần password, do đó mình có thể thay đổi password cho camera bằng command: passwd Bây giờ quay lại PC, kết nối ssh với camera: ssh root@192.168.1.254 ",
      "content_html": "\u003ch3 id=\"tải-dropbear-bản-đã-biên-dịch-sẵn-cho-armhttpsmattuccasnaudropbeardropbearhtml\"\u003e\u003ca href=\"https://matt.ucc.asn.au/dropbear/dropbear.html\"\u003eTải \u003ccode\u003eDropbear\u003c/code\u003e bản đã biên dịch sẵn cho ARM\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrên PC, mình chạy command:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ewget https://bitfab.org/dropbear-static-builds/dropbear-v2020.81-arm-none-linux-gnueabi-static.tgz\ntar xzf dropbear-v2020.81-arm-none-linux-gnueabi-static.tgz\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eDo mình dùng \u003cstrong\u003ewsl\u003c/strong\u003e, nên để biết được thư mục lưu trữ nằm ở đâu, thì dùng thêm command:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eexplorer.exe .\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eSau đó mình sẽ thấy thư mục chứa file \u003cstrong\u003edropbearmulti\u003c/strong\u003e, và mình sẽ copy nó vào camera.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"thông-tin-về-file-dropbearmulti\"\u003eThông tin về file \u003ccode\u003edropbearmulti\u003c/code\u003e:\u003c/h3\u003e\n\u003cp\u003eFile thu được là \u003ccode\u003edropbearmulti\u003c/code\u003e, tham khảo chatGPT thì:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eĐây là file \u003cstrong\u003eđa chức năng (multi-binary)\u003c/strong\u003e, có thể đóng vai trò như:\u003c/em\u003e \u003c/br\u003e\n\u003ccode\u003edropbear\u003c/code\u003e (SSH server) \u003c/br\u003e\n\u003ccode\u003edropbearkey\u003c/code\u003e (tạo host key) \u003c/br\u003e\n\u003ccode\u003edbclient\u003c/code\u003e (SSH client) \u003c/br\u003e\n\u003ccode\u003escp\u003c/code\u003e (copy file qua SSH) \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"kết-nối-camera-thông-qua-cổng-uart-của-thiết-bị\"\u003eKết nối Camera thông qua cổng UART của thiết bị:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThực hiện một số command:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emkdir -p /usr/sbin /etc/dropbear\ncp dropbearmulti /usr/sbin/\nchmod +x /usr/sbin/dropbearmulti\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTạo \u003cstrong\u003esymlink\u003c/strong\u003e để sử dụng từng chức năng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eln -s /usr/sbin/dropbearmulti /usr/bin/dropbear\nln -s /usr/sbin/dropbearmulti /usr/bin/dropbearkey\nln -s /usr/sbin/dropbearmulti /usr/bin/dbclient\nln -s /usr/sbin/dropbearmulti /usr/bin/scp\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/SSH_ARMv7/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTạo SSH host key:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eRun:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edropbear -r /etc/dropbear/dropbear_rsa_host_key\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/SSH_ARMv7/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSSH yêu cầu khi kết nối cần password, do đó mình có thể thay đổi password cho camera bằng command:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epasswd\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eBây giờ quay lại PC, kết nối ssh với camera:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003essh root@192.168.1.254\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/ssh_armv7/",
      "date_published": "1076-01-09T758:11:00+07:00",
      "date_modified": "1076-01-09T758:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "b836b3296b3bd5206a05f9f97fbf1f56b82bd5d2",
      "title": "WiFi_EIRP",
      "summary": "",
      "content_text": " Mình làm về camera hành trình, và các chiếc camera này thường có tính năng phát wifi local để xem video. Do đó phải cần đăng kiểm đo EIRP để có thể lưu hành sản phẩm. Tiện thể tìm hiểu thêm về sóng Radio của WiFi. Thiết bị Aruba Hình trên là của Aruba, mình thấy có thông số power mà mình không rõ là gì. Hỏi chatGPT thì biết rằng đó là thể hiện công suất phát (transmit power) của từng băng tần Wi-Fi trên mỗi Access Point. Lúc này mình có hỏi và so sánh 2 khái niệm về TX Power (Transmit Power) và EIRP (Equivalent Isotropically Radiated Power) TX Power (Transmit Power) là công suất đầu ra của radio, tại cổng kết nối với anten. EIRP (Equivalent Isotropically Radiated Power) là công suất phát hiệu dụng, đây mới là giá trị mà thiết bị thực sự \u0026ldquo;bức xạ ra môi trường\u0026rdquo;.\nNote Nhưng mà thiết bị camera của mình thì đâu có show công suất ra như vậy (mặc dù thiết bị cũng chạy linux, nhưng mình đã thử các command và không check được). Do đó, mình đã đưa ra bài toán để chatGPT giải: Nếu tôi có một thiết bị phát wifi A, rồi tôi dung thiết bị B để thu tín hiệu wifi. Vậy từ thiết bị B này tôi có thể biết được công suất phát của A hay không? Câu trả lời là: Bạn không thể biết chính xác \u0026ldquo;công suất phát (TX Power)\u0026rdquo; của thiết bị A chỉ bằng cách dùng thiết bị B để thu tín hiệu. Tuy nhiên, bạn có thể ước lượng tương đối thông qua một số phép đo và giả định\nHình trên là công thức chatGPT đưa ra. Tức nhiên cái này chỉ là để tham khảo. Chứ nếu muốn đo thì cần một thiết bị chuyên dụng (có thể mua loại rẻ tiền thôi cũng được) =]] ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eMình làm về camera hành trình, và các chiếc camera này thường có tính năng phát wifi local để xem video.\u003c/li\u003e\n\u003cli\u003eDo đó phải cần đăng kiểm \u003cstrong\u003eđo EIRP\u003c/strong\u003e để có thể lưu hành sản phẩm.\u003c/li\u003e\n\u003cli\u003eTiện thể tìm hiểu thêm về sóng Radio của WiFi.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"thiết-bị-aruba\"\u003eThiết bị Aruba\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/WiFi_EIRP/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHình trên là của Aruba, mình thấy có thông số power mà mình không rõ là gì.\u003c/li\u003e\n\u003cli\u003eHỏi chatGPT thì biết rằng đó là \u003cstrong\u003ethể hiện công suất phát (transmit power) của từng băng tần Wi-Fi trên mỗi Access Point\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLúc này mình có hỏi và so sánh 2 khái niệm về \u003cstrong\u003eTX Power (Transmit Power)\u003c/strong\u003e và \u003cstrong\u003eEIRP (Equivalent Isotropically Radiated Power)\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTX Power (Transmit Power)\u003c/strong\u003e là \u003cstrong\u003ecông suất đầu ra của radio\u003c/strong\u003e, tại cổng kết nối với anten. \u003c/br\u003e\n\u003cstrong\u003eEIRP (Equivalent Isotropically Radiated Power)\u003c/strong\u003e là \u003cstrong\u003ecông suất phát hiệu dụng\u003c/strong\u003e, đây mới là giá trị mà thiết bị thực sự \u0026ldquo;bức xạ ra môi trường\u0026rdquo;.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/WiFi_EIRP/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNhưng mà thiết bị camera của mình thì đâu có show công suất ra như vậy \u003cem\u003e(mặc dù thiết bị cũng chạy linux, nhưng mình đã thử các command và không check được)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eDo đó, mình đã đưa ra bài toán để chatGPT giải:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eNếu tôi có một thiết bị phát wifi A, rồi tôi dung thiết bị B để thu tín hiệu wifi. Vậy từ thiết bị B này tôi có thể biết được công suất phát của A hay không?\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eCâu trả lời là: \u003cstrong\u003eBạn không thể biết chính xác \u0026ldquo;công suất phát (TX Power)\u0026rdquo; của thiết bị A chỉ bằng cách dùng thiết bị B để thu tín hiệu.\u003c/strong\u003e\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eTuy nhiên, bạn có thể ước lượng tương đối thông qua một số phép đo và giả định\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/WiFi_EIRP/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHình trên là công thức chatGPT đưa ra.\u003c/li\u003e\n\u003cli\u003eTức nhiên cái này chỉ là để tham khảo.\u003c/li\u003e\n\u003cli\u003eChứ nếu muốn đo thì cần một thiết bị chuyên dụng \u003cem\u003e(có thể mua loại rẻ tiền thôi cũng được)\u003c/em\u003e =]]\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/wifi_eirp/",
      "date_published": "24066-24-09T634:2424:00+07:00",
      "date_modified": "24066-24-09T634:2424:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "f1395ae15b46a6d3e7acb6742ed9b7298bb952b3",
      "title": "BLE_Sniffer",
      "summary": "",
      "content_text": "Bluetooth Sniffer Tài liệu: https://github.com/nccgroup/Sniffle https://media.defcon.org/DEF%20CON%2032/DEF%20CON%2032%20villages/DEF%20CON%2032%20-%20Car%20Hacking%20Village%20-%20Kevin%20Mitchell%20-%20Bluetooth%20Blues%20-%20Unmasking%20CVE%202023-52709%20-%20The%20TI%20BLE5-Stack%20Attack.pdf https://github.com/StealthIQ/Bluestrike https://blog.attify.com/btlejuice-mitm-attack-smart-bulb/ https://blog.attify.com/exploiting-iot-enabled-ble-smart-bulb-security/ Ban đầu cứ ngỡ là chỉ có một cách để lấy thông tin gói, nhưng sau khi xem xong video I Hacked my Smart Grill - Unauthenticated Temp Readings thì có đến 2 cách: Dùng công cụ bắt gói tin. Dùng app Android. Công cụ bắt gói tin Đây là thủ thuật kết hợp giữa phần cứng và phần mềm. Phần cứng là sẽ dùng các công cụ BLE, để bắt gói. Còn phần mềm thì là sẽ dùng Wireshark. nRF52840 Dongle USB Dongle based on nRF52840 CC26x2R - LAUNCHXL-CC26X2R1 CC2652R wireless MCU Tài liệu về sản phẩm: https://e2e.ti.com/support/wireless-connectivity/bluetooth-group/bluetooth/f/bluetooth-forum/843338/cc2652r-sniffle-sniffer-for-bluetooth-5 https://docs.nordicsemi.com/bundle/ncs-2.1.2/page/zephyr/boards/arm/cc26x2r1_launchxl/doc/index.html https://www.ti.com/lit/ml/swpb024/swpb024.pdf?ts=1744281342974\u0026amp;ref_url=https%253A%252F%252Fwww.google.com%252F https://software-dl.ti.com/simplelink/esd/simplelink_cc13x2_26x2_sdk/3.10.01.11/exports/docs/zigbee/html/zigbee/packet_sniffer.html https://dev.ti.com/tirex/explore/node?node=A__AOhWCvEMSJlyxXbKsikrYw__cc26xx_devtools__FUz-xrs__LATEST https://www.ti.com/product/CC2652R Protocols\tBluetooth 5.2 Low Energy, Thread, Zigbee 3.0 App Android Tức là nếu một sản phẩm có kết nối BLE thông qua app trên Android thì mới dùng đc cách này. Trên Android, bật chế độ Nhà phát triển (Develop Mode) \u0026ndash;\u0026gt; Enable Bluetooth stack log Khi này log thu được sẽ có thông tin tương tự như dùng công cụ phần cứng đề sniffer. Mình dùng điện thoại Xoaimi Note 11, thao tác như sau: Trong phần Cài đặt -\u0026gt; Giới thiệu điện thoại, sau đó nhấn liên tục vào phần có nội dung Phiên bản OS. Lúc này chế độ Nhà phát triển đã bật, sau đó quay lại vào Cài đặt bổ sung, kéo xuống và chọn Tùy chọn nhà phát triển.\nTiếp theo đến phần Nhật ký gói dữ liệu HCI Bluetooth, bật lên.\nDùng ADB Command Mình dùng các câu lệnh trong video thì không được, do điện thoại Android của mình không vào được root. Nên có tham khảo chatGPT và research trên google, thì có đến 2 cách để lấy thông tin về log của Bluetooth. Cách 1 là dùng logcat và lọc những thông tin liên quan Bluetooth. Cách 2 là lấy toàn bộ log của Android. Cách 1 (cách này là tham khảo từ chatGPT) Cách này có nhược điểm là không lấy đc thông tin log của HCI Bluetooth. Xài cách này ko được, nhưng mình vẫn note lại. adb logcat -v time \u0026gt; ble_debug_log.txt Lọc với câu lệnh Linux: grep Bluetooth ble_debug_log.txt Trên powershell: Select-String -Path ble_debug_log.txt -Pattern \u0026#34;Bluetooth\u0026#34; Ngoài ra khi mình bật Wireshark, thì thấy các kết nối của điện thoại Android của mình. Theo chatGPT thì các tính năng này của Wireshark cũng dùng logcat, nhưng có filter thôi. Cách 2 (cách này là search gg về cách lấy log HCI Bluetooth) Tham khảo video: https://www.youtube.com/watch?v=Z3HH6pOZjlA Dùng command: adb bugreport BTLogs Sau đó giải nén, thì mình sẽ thấy log của HCI Bluetooth. Nhưng để được log này thì cần mở bằng Wireshark. Vậy là mình đã có thể lấy log kết nối Bluetooth. ",
      "content_html": "\u003ch1 id=\"bluetooth-sniffer\"\u003eBluetooth Sniffer\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/nccgroup/Sniffle\nhttps://media.defcon.org/DEF%20CON%2032/DEF%20CON%2032%20villages/DEF%20CON%2032%20-%20Car%20Hacking%20Village%20-%20Kevin%20Mitchell%20-%20Bluetooth%20Blues%20-%20Unmasking%20CVE%202023-52709%20-%20The%20TI%20BLE5-Stack%20Attack.pdf\nhttps://github.com/StealthIQ/Bluestrike\nhttps://blog.attify.com/btlejuice-mitm-attack-smart-bulb/\nhttps://blog.attify.com/exploiting-iot-enabled-ble-smart-bulb-security/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eBan đầu cứ ngỡ là chỉ có một cách để lấy thông tin gói, nhưng sau khi xem xong video \u003ca href=\"https://www.youtube.com/watch?v=-tH6VU6chEc\"\u003eI Hacked my Smart Grill - Unauthenticated Temp Readings\u003c/a\u003e thì có đến 2 cách:\n\u003cul\u003e\n\u003cli\u003eDùng công cụ bắt gói tin.\u003c/li\u003e\n\u003cli\u003eDùng app Android.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"công-cụ-bắt-gói-tin\"\u003eCông cụ bắt gói tin\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là thủ thuật kết hợp giữa phần cứng và phần mềm.\u003c/li\u003e\n\u003cli\u003ePhần cứng là sẽ dùng các công cụ BLE, để bắt gói.\u003c/li\u003e\n\u003cli\u003eCòn phần mềm thì là sẽ dùng \u003cstrong\u003eWireshark\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nrf52840-dongle-usb-dongle-based-on-nrf52840httpswwwproevnnrf52840-dongle-usb-dongle-based-on-nrf52840\"\u003e\u003ca href=\"https://www.proe.vn/nrf52840-dongle-usb-dongle-based-on-nrf52840\"\u003enRF52840 Dongle USB Dongle based on nRF52840\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"cc26x2r---launchxl-cc26x2r1-cc2652r-wireless-mcuhttpswwwproevnlaunchxl-cc26x2r1-cc2652r-wireless-mcu\"\u003eCC26x2R - \u003ca href=\"https://www.proe.vn/launchxl-cc26x2r1-cc2652r-wireless-mcu\"\u003eLAUNCHXL-CC26X2R1 CC2652R wireless MCU\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu về sản phẩm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://e2e.ti.com/support/wireless-connectivity/bluetooth-group/bluetooth/f/bluetooth-forum/843338/cc2652r-sniffle-sniffer-for-bluetooth-5\nhttps://docs.nordicsemi.com/bundle/ncs-2.1.2/page/zephyr/boards/arm/cc26x2r1_launchxl/doc/index.html\nhttps://www.ti.com/lit/ml/swpb024/swpb024.pdf?ts=1744281342974\u0026amp;ref_url=https%253A%252F%252Fwww.google.com%252F\nhttps://software-dl.ti.com/simplelink/esd/simplelink_cc13x2_26x2_sdk/3.10.01.11/exports/docs/zigbee/html/zigbee/packet_sniffer.html\nhttps://dev.ti.com/tirex/explore/node?node=A__AOhWCvEMSJlyxXbKsikrYw__cc26xx_devtools__FUz-xrs__LATEST\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.ti.com/product/CC2652R\"\u003ehttps://www.ti.com/product/CC2652R\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eProtocols\tBluetooth 5.2 Low Energy, Thread, Zigbee 3.0\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"app-android\"\u003eApp Android\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTức là nếu một sản phẩm có kết nối BLE thông qua app trên Android thì mới dùng đc cách này.\u003c/li\u003e\n\u003cli\u003eTrên Android, bật \u003cstrong\u003echế độ Nhà phát triển (Develop Mode)\u003c/strong\u003e \u0026ndash;\u0026gt; \u003cstrong\u003eEnable Bluetooth stack log\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eKhi này log thu được sẽ có thông tin tương tự như dùng công cụ phần cứng đề sniffer.\u003c/li\u003e\n\u003cli\u003eMình dùng điện thoại Xoaimi Note 11, thao tác như sau:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTrong phần \u003cstrong\u003eCài đặt\u003c/strong\u003e -\u0026gt; \u003cstrong\u003eGiới thiệu điện thoại\u003c/strong\u003e, sau đó nhấn liên tục vào phần có nội dung \u003cstrong\u003ePhiên bản OS\u003c/strong\u003e. \u003c/br\u003e\nLúc này chế độ Nhà phát triển đã bật, sau đó quay lại vào \u003cstrong\u003eCài đặt bổ sung\u003c/strong\u003e, kéo xuống và chọn \u003cstrong\u003eTùy chọn nhà phát triển\u003c/strong\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BLE_Sniffer/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTiếp theo đến phần \u003cstrong\u003eNhật ký gói dữ liệu HCI Bluetooth\u003c/strong\u003e, bật lên.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BLE_Sniffer/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"dùng-adb-command\"\u003eDùng ADB Command\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình dùng các câu lệnh trong video thì không được, do điện thoại Android của mình không vào được \u003cstrong\u003eroot\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNên có tham khảo chatGPT và research trên google, thì có đến 2 cách để lấy thông tin về log của Bluetooth.\u003c/li\u003e\n\u003cli\u003eCách 1 là dùng \u003cstrong\u003elogcat\u003c/strong\u003e và lọc những thông tin liên quan Bluetooth.\u003c/li\u003e\n\u003cli\u003eCách 2 là lấy toàn bộ log của Android.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"cách-1-cách-này-là-tham-khảo-từ-chatgpt\"\u003eCách 1 \u003cem\u003e(cách này là tham khảo từ chatGPT)\u003c/em\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eCách này có nhược điểm là không lấy đc thông tin log của \u003cstrong\u003eHCI Bluetooth\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eXài cách này ko được, nhưng mình vẫn note lại.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eadb logcat -v time \u0026gt; ble_debug_log.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eLọc với câu lệnh Linux:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrep Bluetooth ble_debug_log.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTrên powershell:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSelect-String -Path ble_debug_log.txt -Pattern \u0026#34;Bluetooth\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eNgoài ra khi mình bật Wireshark, thì thấy các kết nối của điện thoại Android của mình.\u003c/em\u003e \u003c/br\u003e\n\u003cem\u003eTheo chatGPT thì các tính năng này của Wireshark cũng dùng \u003cstrong\u003elogcat\u003c/strong\u003e, nhưng có filter thôi.\u003c/em\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BLE_Sniffer/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch4 id=\"cách-2-cách-này-là-search-gg-về-cách-lấy-log-hci-bluetooth\"\u003eCách 2 \u003cem\u003e(cách này là search gg về cách lấy log HCI Bluetooth)\u003c/em\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eTham khảo video: \u003ccode\u003ehttps://www.youtube.com/watch?v=Z3HH6pOZjlA\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eDùng command:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eadb bugreport BTLogs\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BLE_Sniffer/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau đó giải nén, thì mình sẽ thấy \u003cstrong\u003elog của HCI Bluetooth\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhưng để được log này thì cần mở bằng Wireshark.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/BLE_Sniffer/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVậy là mình đã có thể lấy log kết nối Bluetooth.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/ble_sniffer/",
      "date_published": "4066-04-09T64:44:00+07:00",
      "date_modified": "4066-04-09T64:44:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "bd0eff431fd00da6dc21d30d71ad04939a7344d8",
      "title": "CCTV_Dashcam",
      "summary": "",
      "content_text": "Đây là cuộc trao đổi giữa mình với Grok 3.\nVề so sánh giữa CCTV với Dashcam\nCâu hỏi 1: grok, theo bạn nghĩ thì sensor camera dùng cho CCTV và thiết bị ghi hình cho xe ô tô khác biệt thế nào ? Phản hồi từ Grok: Cảm biến camera dùng cho CCTV và thiết bị ghi hình xe ô tô (dashcam) có một số điểm khác biệt chính, chủ yếu do mục đích sử dụng và môi trường hoạt động.\nMôi trường hoạt động: CCTV: Thường được lắp cố định, hoạt động trong điều kiện ánh sáng ổn định hơn (trong nhà hoặc ngoài trời với đèn hỗ trợ). Cảm biến được tối ưu cho độ chi tiết cao và giám sát liên tục. Dashcam: Phải hoạt động trong điều kiện ánh sáng thay đổi nhanh (ngày/đêm, nắng/mưa, đường hầm), rung lắc mạnh, và nhiệt độ khắc nghiệt. Cảm biến cần khả năng thích nghi nhanh với ánh sáng và chống nhiễu tốt. Góc nhìn và tiêu cự: CCTV: Thường có góc nhìn cố định hoặc điều chỉnh, tập trung vào khu vực cụ thể (ví dụ: cửa ra vào, hành lang). Cảm biến có thể ưu tiên độ phân giải cao hơn góc rộng. Dashcam: Yêu cầu góc nhìn rộng (thường 120-170 độ) để ghi lại toàn cảnh phía trước xe. Cảm biến được tối ưu để bao quát hơn là chi tiết ở khoảng cách xa. Khả năng xử lý ánh sáng: CCTV: Nhiều model dùng cảm biến CMOS với công nghệ WDR (Wide Dynamic Range) hoặc HDR để xử lý chênh lệch sáng tối, nhưng thường không cần tốc độ phản hồi quá nhanh. Dashcam: Cần cảm biến có WDR/HDR mạnh hơn và tốc độ phản hồi nhanh để xử lý ánh sáng thay đổi đột ngột (ví dụ: từ bóng râm ra ánh nắng). Một số dashcam dùng cảm biến Sony STARVIS để cải thiện hiệu suất trong điều kiện thiếu sáng. Độ bền và thiết kế: CCTV: Cảm biến ít phải chịu rung động, nhưng cần bền với thời tiết nếu dùng ngoài trời. Dashcam: Cảm biến phải chịu được rung lắc liên tục, nhiệt độ cao/thấp trong xe, và thường được tích hợp trong thiết kế nhỏ gọn. Tốc độ khung hình và lưu trữ: CCTV: Thường ghi liên tục với tốc độ khung hình trung bình (15-30 fps), ưu tiên lưu trữ lâu dài. Dashcam: Cần tốc độ khung hình cao hơn (30-60 fps) để ghi lại chi tiết khi xe di chuyển nhanh, nhưng thường ghi vòng lặp, ưu tiên dung lượng lưu trữ nhỏ. Tóm lại, cảm biến cho dashcam đòi hỏi khả năng thích nghi linh hoạt hơn với môi trường động, trong khi cảm biến CCTV tập trung vào độ chi tiết và ổn định trong điều kiện cố định.\nCâu hỏi 2: khoan, tôi đang thắc mắc nếu CCTV cần độ rõ nét thì sao tôi thấy trên thị trường sản phẩm CCTV FullHD rất nhiều, 2K thì ít. Tuy nhiên với dòng dashcam thì lại đa dạng từ 2K -\u0026gt; 4K ? Phản hồi: Bạn đặt một câu hỏi rất thú vị, liên quan đến sự khác biệt về độ phân giải giữa CCTV và dashcam trên thị trường. Dưới đây là một số lý do giải thích tại sao CCTV phổ biến ở FullHD (1080p) trong khi dashcam có xu hướng cung cấp độ phân giải cao hơn như 2K hoặc 4K:\nMục đích sử dụng và yêu cầu chi tiết hình ảnh: CCTV: Mục tiêu chính của CCTV là giám sát tổng thể một khu vực (nhà, văn phòng, cửa hàng). Độ phân giải FullHD (1080p) thường đủ để nhận diện khuôn mặt hoặc hành vi ở khoảng cách gần đến trung bình, đặc biệt khi kết hợp với ống kính phù hợp. Các hệ thống CCTV ưu tiên tính ổn định, lưu trữ lâu dài và chi phí thấp, nên FullHD là lựa chọn phổ biến vì cân bằng giữa chất lượng và hiệu quả kinh tế. Độ phân giải 2K hoặc 4K ít phổ biến hơn do chi phí cao và nhu cầu thực tế không quá cấp thiết ở nhiều tình huống giám sát. Dashcam: Dashcam cần ghi lại chi tiết trong các tình huống chuyển động nhanh, như tai nạn giao thông hoặc biển số xe ở khoảng cách xa. Độ phân giải cao hơn (2K, 4K) giúp cải thiện khả năng nhìn rõ các chi tiết nhỏ, đặc biệt khi phóng to hình ảnh để làm bằng chứng. Thị trường dashcam cạnh tranh mạnh về chất lượng hình ảnh, nên các nhà sản xuất đẩy mạnh độ phân giải cao để thu hút người dùng. Nhu cầu thị trường và tâm lý người dùng: CCTV: Người dùng CCTV (chủ yếu là doanh nghiệp hoặc gia đình) thường ưu tiên hệ thống giá rẻ, dễ lắp đặt và lưu trữ lâu dài. FullHD đáp ứng tốt nhu cầu này mà không làm tăng chi phí phần cứng hoặc dung lượng lưu trữ. Các hệ thống 2K/4K thường chỉ xuất hiện ở phân khúc cao cấp, như CCTV cho ngân hàng, sòng bạc, hoặc khu vực cần độ chi tiết cực cao. Dashcam: Người dùng dashcam (chủ yếu là tài xế cá nhân) coi thiết bị này như một công cụ bảo vệ pháp lý trong trường hợp tai nạn. Độ phân giải cao (2K, 4K) mang lại cảm giác an tâm hơn khi cần trích xuất chi tiết từ video. Ngoài ra, dashcam là sản phẩm tiêu dùng cá nhân, dễ tiếp cận với các cải tiến công nghệ mới, nên các nhà sản xuất liên tục nâng cấp độ phân giải để cạnh tranh. Yêu cầu lưu trữ và băng thông: CCTV: Hệ thống CCTV thường ghi liên tục 24/7 và lưu trữ nhiều ngày/tháng, đòi hỏi dung lượng lưu trữ lớn. Độ phân giải FullHD tạo ra file video có kích thước vừa phải, dễ quản lý trên ổ cứng hoặc đám mây mà không làm tăng chi phí quá nhiều. Các hệ thống 2K/4K cần ổ cứng dung lượng cao hơn và băng thông lớn hơn nếu truyền video qua mạng, điều này làm tăng chi phí vận hành. Dashcam: Dashcam ghi vòng lặp (loop recording), chỉ lưu trữ trong thời gian ngắn (vài giờ đến vài ngày) trước khi ghi đè. Do đó, file video 2K/4K không gây áp lực lớn về lưu trữ. Thẻ nhớ microSD dung lượng cao (128GB-256GB) hiện nay cũng đủ để đáp ứng nhu cầu, giúp dashcam dễ dàng hỗ trợ độ phân giải cao hơn. Tiến bộ công nghệ và chi phí sản xuất: CCTV: Thị trường CCTV có xu hướng chậm đổi mới hơn vì các hệ thống thường được thiết kế để tương thích ngược với cơ sở hạ tầng cũ (như cáp đồng trục, DVR). Cảm biến FullHD đã được tối ưu hóa về chi phí, trong khi cảm biến 2K/4K đòi hỏi phần cứng và phần mềm mới hơn, làm tăng giá thành. Dashcam: Là sản phẩm tiêu dùng cá nhân, dashcam được hưởng lợi từ các tiến bộ nhanh trong công nghệ cảm biến (như Sony IMX series) và chip xử lý. Cảm biến 2K/4K ngày càng rẻ, cho phép các nhà sản xuất tích hợp vào dashcam mà không làm tăng giá bán quá nhiều. Ống kính và chất lượng thực tế: CCTV: Độ rõ nét của CCTV không chỉ phụ thuộc vào cảm biến mà còn vào ống kính và điều kiện ánh sáng. Nhiều CCTV FullHD dùng ống kính chất lượng cao, đủ để cung cấp hình ảnh rõ nét trong phạm vi giám sát. Việc nâng cấp lên 2K/4K không phải lúc nào cũng mang lại cải thiện đáng kể nếu ống kính hoặc ánh sáng không tương xứng. Dashcam: Dashcam thường được tối ưu với ống kính góc rộng và cảm biến hiện đại, giúp tận dụng tốt độ phân giải cao để ghi lại chi tiết trong điều kiện ánh sáng thay đổi nhanh. Độ phân giải cao cũng giúp dashcam cạnh tranh về mặt tiếp thị. Tóm lại: CCTV phổ biến ở FullHD do nhu cầu giám sát cơ bản, chi phí thấp và yêu cầu lưu trữ lâu dài, trong khi dashcam ưu tiên 2K/4K để đáp ứng nhu cầu chi tiết hình ảnh trong các tình huống giao thông và cạnh tranh thị trường. Nếu bạn cần CCTV với độ phân giải cao hơn, các sản phẩm 2K/4K vẫn tồn tại nhưng thường ở phân khúc chuyên dụng hoặc cao cấp.\nCâu hỏi 3: vậy bạn nghĩ sao nếu tôi dùng dashcam thay thế cho các loại CCTV ? Lợi và hại ? Phản hồi: Sử dụng dashcam thay thế cho CCTV là một ý tưởng sáng tạo, nhưng nó có cả lợi ích và hạn chế do sự khác biệt về thiết kế và mục đích sử dụng. Dưới đây là phân tích chi tiết về lợi và hại của việc này:\nLợi ích khi dùng dashcam thay cho CCTV Độ phân giải cao và chất lượng hình ảnh tốt: Dashcam thường có độ phân giải từ 2K đến 4K, cao hơn nhiều CCTV phổ thông (FullHD). Điều này giúp ghi lại chi tiết rõ nét hơn, như khuôn mặt, biển số xe, hoặc các vật thể nhỏ, đặc biệt hữu ích trong các tình huống cần bằng chứng pháp lý. Nhiều dashcam sử dụng cảm biến hiện đại (như Sony STARVIS) với khả năng xử lý ánh sáng tốt, phù hợp cho cả ngày và đêm. Góc nhìn rộng: Dashcam thường có góc nhìn từ 120-170 độ, lý tưởng để bao quát một khu vực rộng, như sân trước nhà, bãi đỗ xe, hoặc cửa ra vào, tương tự như nhiều camera CCTV. Khả năng thích nghi với điều kiện ánh sáng thay đổi: Dashcam được thiết kế để hoạt động trong môi trường ánh sáng động (ngày/đêm, nắng/mưa), với công nghệ WDR/HDR mạnh mẽ. Điều này có thể vượt trội so với một số CCTV giá rẻ trong việc xử lý chênh lệch sáng tối. Tính di động và dễ lắp đặt: Dashcam nhỏ gọn, dễ lắp đặt (thường dùng băng dính hoặc giá đỡ hút chân không), không cần đi dây phức tạp như nhiều hệ thống CCTV. Bạn có thể dễ dàng tháo lắp hoặc di chuyển đến vị trí khác. Một số dashcam hỗ trợ pin hoặc nguồn USB, giúp sử dụng linh hoạt hơn ở những nơi không có nguồn điện cố định. Chi phí hợp lý: Một chiếc dashcam chất lượng tốt (2K/4K) thường có giá từ 2-5 triệu VND, rẻ hơn so với hệ thống CCTV cao cấp (bao gồm camera, DVR, ổ cứng, và công lắp đặt). Nếu bạn chỉ cần một camera đơn lẻ, dashcam là lựa chọn tiết kiệm. Tính năng bổ sung: Nhiều dashcam có các tính năng như ghi vòng lặp, cảm biến va chạm (G-sensor), hoặc kết nối Wi-Fi để xem video trực tiếp trên điện thoại. Những tính năng này có thể thay thế hoặc bổ sung cho các chức năng của CCTV. Hạn chế khi dùng dashcam thay cho CCTV Thiết kế không tối ưu cho giám sát liên tục: Dashcam được thiết kế để ghi hình ngắn hạn và ghi vòng lặp (loop recording), tự động xóa dữ liệu cũ khi thẻ nhớ đầy. Điều này không phù hợp với CCTV, vốn cần lưu trữ video dài ngày (hàng tuần hoặc tháng) để phục vụ giám sát an ninh. Dung lượng thẻ nhớ của dashcam (thường 32GB-256GB) nhỏ hơn nhiều so với ổ cứng của hệ thống CCTV (hàng TB), khiến việc lưu trữ lâu dài bị hạn chế. Không hỗ trợ hệ thống giám sát đa camera: CCTV thường được thiết kế để hoạt động trong hệ thống nhiều camera, kết nối với DVR/NVR để quản lý tập trung. Dashcam hoạt động độc lập, không dễ tích hợp vào một hệ thống giám sát phức tạp hoặc xem đồng thời nhiều góc quay. Thiếu tính năng giám sát chuyên dụng: CCTV thường có các tính năng như phát hiện chuyển động, cảnh báo thời gian thực, hoặc tích hợp với hệ thống báo động. Dashcam hiếm khi có những tính năng này hoặc chỉ hỗ trợ ở mức cơ bản (ví dụ: chế độ parking mode). Một số dashcam không hỗ trợ xem trực tiếp từ xa qua internet, trong khi CCTV thường có ứng dụng hoặc phần mềm để giám sát từ xa. Độ bền và khả năng hoạt động liên tục: Dashcam được thiết kế để hoạt động trong xe, nhưng không phải lúc nào cũng chịu được điều kiện thời tiết khắc nghiệt (mưa, nắng lâu dài) nếu lắp ngoài trời. CCTV ngoài trời thường có chuẩn chống nước/bụi (IP66, IP67) tốt hơn. Dashcam có thể quá nóng hoặc giảm tuổi thọ nếu hoạt động liên tục 24/7, vì chúng không được thiết kế cho việc ghi hình không ngừng nghỉ như CCTV. Nguồn điện và lắp đặt cố định: Dashcam thường lấy điện từ cổng USB hoặc ổ cắm 12V trong xe, không phù hợp cho các vị trí cố định trong nhà hoặc ngoài trời (yêu cầu nguồn 220V hoặc PoE). Việc cấp nguồn liên tục cho dashcam có thể phức tạp hơn so với hệ thống CCTV. Dashcam không có cơ chế gắn cố định chắc chắn như CCTV, dễ bị tháo trộm hoặc dịch chuyển nếu dùng ở nơi công cộng. Hạn chế về phần mềm và tích hợp: CCTV thường đi kèm phần mềm quản lý chuyên dụng (như Hikvision, Dahua) để xem lại, tìm kiếm, hoặc xuất video dễ dàng. Dashcam chủ yếu dựa vào ứng dụng di động hoặc xem trực tiếp trên thẻ nhớ, không thuận tiện cho việc quản lý video dài hạn. Dashcam không hỗ trợ tích hợp với các hệ thống smarthome hoặc thiết bị an ninh khác, trong khi CCTV có thể kết nối với cảm biến, chuông báo, hoặc trợ lý ảo. Kết luận và khuyến nghị Khi nào nên dùng dashcam thay CCTV? Nếu bạn cần một giải pháp giám sát đơn giản, chi phí thấp cho một khu vực nhỏ (như bãi đỗ xe, cửa trước nhà) và không cần lưu trữ video lâu dài. Nếu bạn muốn tận dụng độ phân giải cao và khả năng ghi hình trong điều kiện ánh sáng thay đổi. Nếu bạn cần một thiết bị di động, dễ tháo lắp để sử dụng ở nhiều vị trí. Khi nào không nên dùng dashcam thay CCTV? Nếu bạn cần một hệ thống giám sát liên tục 24/7, lưu trữ video dài hạn, hoặc quản lý nhiều camera cùng lúc. Nếu bạn cần các tính năng an ninh nâng cao như phát hiện chuyển động, xem từ xa, hoặc tích hợp với hệ thống báo động. Nếu camera phải lắp ngoài trời hoặc ở vị trí cố định lâu dài, nơi yêu cầu độ bền cao và chống chịu thời tiết. Đề xuất: Kết hợp cả hai: Bạn có thể dùng dashcam như một camera bổ sung cho các khu vực cụ thể (ví dụ: giám sát xe trong bãi đỗ) và sử dụng CCTV cho các khu vực cần giám sát liên tục hoặc chuyên sâu hơn. Chọn dashcam phù hợp: Nếu muốn dùng dashcam cho mục đích CCTV, hãy chọn model có chế độ parking mode, hỗ trợ thẻ nhớ dung lượng lớn, và khả năng xem từ xa qua Wi-Fi. Ví dụ: các dòng từ Viofo, BlackVue, hoặc Thinkware. Nâng cấp hệ thống CCTV: Nếu bạn muốn độ phân giải cao như dashcam, hãy xem xét các dòng CCTV 2K/4K từ các thương hiệu như Hikvision, Dahua, hoặc Reolink, dù chi phí sẽ cao hơn. ",
      "content_html": "\u003cp\u003eĐây là cuộc trao đổi giữa mình với \u003cstrong\u003eGrok 3\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eVề so sánh giữa \u003cmark\u003eCCTV\u003c/mark\u003e với \u003cmark\u003eDashcam\u003c/mark\u003e\u003c/p\u003e\n\u003ch2 id=\"câu-hỏi-1\"\u003eCâu hỏi 1:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrok, theo bạn nghĩ thì sensor camera dùng cho CCTV và thiết bị ghi hình cho xe ô tô khác biệt thế nào ?\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"phản-hồi-từ-grok\"\u003ePhản hồi từ Grok:\u003c/h3\u003e\n\u003cp\u003eCảm biến camera dùng cho CCTV và thiết bị ghi hình xe ô tô (dashcam) có một số điểm khác biệt chính, chủ yếu do mục đích sử dụng và môi trường hoạt động.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMôi trường hoạt động:\n\u003cul\u003e\n\u003cli\u003eCCTV: Thường được lắp cố định, hoạt động trong điều kiện ánh sáng ổn định hơn (trong nhà hoặc ngoài trời với đèn hỗ trợ). \u003cstrong\u003eCảm biến được tối ưu cho độ chi tiết cao và giám sát liên tục\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDashcam: Phải hoạt động trong \u003cstrong\u003eđiều kiện ánh sáng thay đổi nhanh\u003c/strong\u003e (ngày/đêm, nắng/mưa, đường hầm), \u003cstrong\u003erung lắc mạnh\u003c/strong\u003e, và \u003cstrong\u003enhiệt độ khắc nghiệt\u003c/strong\u003e. \u003cstrong\u003eCảm biến cần khả năng thích nghi nhanh với ánh sáng và chống nhiễu tốt\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eGóc nhìn và tiêu cự:\n\u003cul\u003e\n\u003cli\u003eCCTV: Thường có góc nhìn cố định hoặc điều chỉnh, tập trung vào khu vực cụ thể (ví dụ: cửa ra vào, hành lang). Cảm biến có thể ưu tiên độ phân giải cao hơn góc rộng.\u003c/li\u003e\n\u003cli\u003eDashcam: Yêu cầu góc nhìn rộng (thường 120-170 độ) để ghi lại toàn cảnh phía trước xe. Cảm biến được tối ưu để bao quát hơn là chi tiết ở khoảng cách xa.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eKhả năng xử lý ánh sáng:\n\u003cul\u003e\n\u003cli\u003eCCTV: Nhiều model dùng cảm biến CMOS với công nghệ WDR (Wide Dynamic Range) hoặc HDR để xử lý chênh lệch sáng tối, nhưng thường không cần tốc độ phản hồi quá nhanh.\u003c/li\u003e\n\u003cli\u003eDashcam: \u003cstrong\u003eCần cảm biến có WDR/HDR mạnh hơn và tốc độ phản hồi nhanh để xử lý ánh sáng thay đổi đột ngột\u003c/strong\u003e (ví dụ: từ bóng râm ra ánh nắng). Một số dashcam dùng cảm biến Sony STARVIS để cải thiện hiệu suất trong điều kiện thiếu sáng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐộ bền và thiết kế:\n\u003cul\u003e\n\u003cli\u003eCCTV: Cảm biến ít phải chịu rung động, nhưng cần bền với thời tiết nếu dùng ngoài trời.\u003c/li\u003e\n\u003cli\u003eDashcam: Cảm biến phải chịu được rung lắc liên tục, nhiệt độ cao/thấp trong xe, và thường được tích hợp trong thiết kế nhỏ gọn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTốc độ khung hình và lưu trữ:\n\u003cul\u003e\n\u003cli\u003eCCTV: Thường ghi liên tục với tốc độ khung hình trung bình (15-30 fps), ưu tiên lưu trữ lâu dài.\u003c/li\u003e\n\u003cli\u003eDashcam: Cần tốc độ khung hình cao hơn (30-60 fps) để ghi lại chi tiết khi xe di chuyển nhanh, nhưng thường ghi vòng lặp, ưu tiên dung lượng lưu trữ nhỏ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eTóm lại, cảm biến cho dashcam đòi hỏi khả năng thích nghi linh hoạt hơn với môi trường động, trong khi cảm biến CCTV tập trung vào độ chi tiết và ổn định trong điều kiện cố định.\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"câu-hỏi-2\"\u003eCâu hỏi 2:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ekhoan, tôi đang thắc mắc nếu CCTV cần độ rõ nét thì sao tôi thấy trên thị trường sản phẩm CCTV FullHD rất nhiều, 2K thì ít. Tuy nhiên với dòng dashcam thì lại đa dạng từ 2K -\u0026gt; 4K ?\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"phản-hồi\"\u003ePhản hồi:\u003c/h3\u003e\n\u003cp\u003eBạn đặt một câu hỏi rất thú vị, liên quan đến sự khác biệt về độ phân giải giữa CCTV và dashcam trên thị trường. Dưới đây là một số lý do giải thích tại sao CCTV phổ biến ở FullHD (1080p) trong khi dashcam có xu hướng cung cấp độ phân giải cao hơn như 2K hoặc 4K:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMục đích sử dụng và yêu cầu chi tiết hình ảnh:\n\u003cul\u003e\n\u003cli\u003eCCTV: \u003cstrong\u003eMục tiêu chính của CCTV là giám sát tổng thể một khu vực (nhà, văn phòng, cửa hàng)\u003c/strong\u003e. Độ phân giải FullHD (1080p) thường đủ để nhận diện khuôn mặt hoặc hành vi ở khoảng cách gần đến trung bình, đặc biệt khi kết hợp với ống kính phù hợp. Các hệ thống CCTV ưu tiên tính ổn định, lưu trữ lâu dài và chi phí thấp, nên FullHD là lựa chọn phổ biến vì cân bằng giữa chất lượng và hiệu quả kinh tế. Độ phân giải 2K hoặc 4K ít phổ biến hơn do chi phí cao và nhu cầu thực tế không quá cấp thiết ở nhiều tình huống giám sát.\u003c/li\u003e\n\u003cli\u003eDashcam: Dashcam cần ghi lại chi tiết trong các tình huống chuyển động nhanh, như tai nạn giao thông hoặc biển số xe ở khoảng cách xa. \u003cstrong\u003eĐộ phân giải cao hơn (2K, 4K) giúp cải thiện khả năng nhìn rõ các chi tiết nhỏ, đặc biệt khi phóng to hình ảnh để làm bằng chứng\u003c/strong\u003e. Thị trường dashcam cạnh tranh mạnh về chất lượng hình ảnh, nên các nhà sản xuất đẩy mạnh độ phân giải cao để thu hút người dùng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eNhu cầu thị trường và tâm lý người dùng:\n\u003cul\u003e\n\u003cli\u003eCCTV: Người dùng CCTV (chủ yếu là doanh nghiệp hoặc gia đình) thường ưu tiên hệ thống giá rẻ, dễ lắp đặt và lưu trữ lâu dài. FullHD đáp ứng tốt nhu cầu này mà không làm tăng chi phí phần cứng hoặc dung lượng lưu trữ. Các hệ thống 2K/4K thường chỉ xuất hiện ở phân khúc cao cấp, như CCTV cho ngân hàng, sòng bạc, hoặc khu vực cần độ chi tiết cực cao.\u003c/li\u003e\n\u003cli\u003eDashcam: Người dùng dashcam (chủ yếu là tài xế cá nhân) coi thiết bị này như một công cụ bảo vệ pháp lý trong trường hợp tai nạn. Độ phân giải cao (2K, 4K) mang lại cảm giác an tâm hơn khi cần trích xuất chi tiết từ video. Ngoài ra, dashcam là sản phẩm tiêu dùng cá nhân, dễ tiếp cận với các cải tiến công nghệ mới, nên các nhà sản xuất liên tục nâng cấp độ phân giải để cạnh tranh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eYêu cầu lưu trữ và băng thông:\n\u003cul\u003e\n\u003cli\u003eCCTV: Hệ thống CCTV thường ghi liên tục 24/7 và lưu trữ nhiều ngày/tháng, đòi hỏi dung lượng lưu trữ lớn. Độ phân giải FullHD tạo ra file video có kích thước vừa phải, dễ quản lý trên ổ cứng hoặc đám mây mà không làm tăng chi phí quá nhiều. Các hệ thống 2K/4K cần ổ cứng dung lượng cao hơn và băng thông lớn hơn nếu truyền video qua mạng, điều này làm tăng chi phí vận hành.\u003c/li\u003e\n\u003cli\u003eDashcam: Dashcam ghi vòng lặp (loop recording), chỉ lưu trữ trong thời gian ngắn (vài giờ đến vài ngày) trước khi ghi đè. Do đó, file video 2K/4K không gây áp lực lớn về lưu trữ. Thẻ nhớ microSD dung lượng cao (128GB-256GB) hiện nay cũng đủ để đáp ứng nhu cầu, giúp dashcam dễ dàng hỗ trợ độ phân giải cao hơn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTiến bộ công nghệ và chi phí sản xuất:\n\u003cul\u003e\n\u003cli\u003eCCTV: \u003cstrong\u003eThị trường CCTV có xu hướng chậm đổi mới hơn vì các hệ thống thường được thiết kế để tương thích ngược với cơ sở hạ tầng cũ (như cáp đồng trục, DVR)\u003c/strong\u003e. Cảm biến FullHD đã được tối ưu hóa về chi phí, trong khi cảm biến 2K/4K đòi hỏi phần cứng và phần mềm mới hơn, làm tăng giá thành.\u003c/li\u003e\n\u003cli\u003eDashcam: Là sản phẩm tiêu dùng cá nhân, dashcam được hưởng lợi từ các tiến bộ nhanh trong công nghệ cảm biến (như Sony IMX series) và chip xử lý. Cảm biến 2K/4K ngày càng rẻ, cho phép các nhà sản xuất tích hợp vào dashcam mà không làm tăng giá bán quá nhiều.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eỐng kính và chất lượng thực tế:\n\u003cul\u003e\n\u003cli\u003eCCTV: \u003cstrong\u003eĐộ rõ nét của CCTV không chỉ phụ thuộc vào cảm biến mà còn vào ống kính và điều kiện ánh sáng\u003c/strong\u003e. Nhiều CCTV FullHD dùng \u003cstrong\u003eống kính chất lượng cao, đủ để cung cấp hình ảnh rõ nét trong phạm vi giám sát\u003c/strong\u003e. Việc nâng cấp lên 2K/4K không phải lúc nào cũng mang lại cải thiện đáng kể nếu ống kính hoặc ánh sáng không tương xứng.\u003c/li\u003e\n\u003cli\u003eDashcam: Dashcam thường được tối ưu với ống kính góc rộng và cảm biến hiện đại, giúp tận dụng tốt độ phân giải cao để ghi lại chi tiết trong điều kiện ánh sáng thay đổi nhanh. Độ phân giải cao cũng giúp dashcam cạnh tranh về mặt tiếp thị.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eTóm lại: CCTV phổ biến ở FullHD do nhu cầu giám sát cơ bản, chi phí thấp và yêu cầu lưu trữ lâu dài, trong khi dashcam ưu tiên 2K/4K để đáp ứng nhu cầu chi tiết hình ảnh trong các tình huống giao thông và cạnh tranh thị trường. Nếu bạn cần CCTV với độ phân giải cao hơn, các sản phẩm 2K/4K vẫn tồn tại nhưng thường ở phân khúc chuyên dụng hoặc cao cấp.\u003c/strong\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"câu-hỏi-3\"\u003eCâu hỏi 3:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evậy bạn nghĩ sao nếu tôi dùng dashcam thay thế cho các loại CCTV ? Lợi và hại ?\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"phản-hồi-1\"\u003ePhản hồi:\u003c/h3\u003e\n\u003cp\u003eSử dụng dashcam thay thế cho CCTV là một ý tưởng sáng tạo, nhưng nó có cả lợi ích và hạn chế do sự khác biệt về thiết kế và mục đích sử dụng. Dưới đây là phân tích chi tiết về lợi và hại của việc này:\u003c/p\u003e\n\u003ch4 id=\"lợi-ích-khi-dùng-dashcam-thay-cho-cctv\"\u003eLợi ích khi dùng dashcam thay cho CCTV\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eĐộ phân giải cao và chất lượng hình ảnh tốt:\n\u003cul\u003e\n\u003cli\u003eDashcam thường có độ phân giải từ 2K đến 4K, cao hơn nhiều CCTV phổ thông (FullHD). Điều này giúp ghi lại chi tiết rõ nét hơn, như khuôn mặt, biển số xe, hoặc các vật thể nhỏ, đặc biệt hữu ích trong các tình huống cần bằng chứng pháp lý.\u003c/li\u003e\n\u003cli\u003eNhiều dashcam sử dụng cảm biến hiện đại (như Sony STARVIS) với khả năng xử lý ánh sáng tốt, phù hợp cho cả ngày và đêm.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eGóc nhìn rộng: Dashcam thường có góc nhìn từ 120-170 độ, lý tưởng để bao quát một khu vực rộng, như sân trước nhà, bãi đỗ xe, hoặc cửa ra vào, tương tự như nhiều camera CCTV.\u003c/li\u003e\n\u003cli\u003eKhả năng thích nghi với điều kiện ánh sáng thay đổi: Dashcam được thiết kế để hoạt động trong môi trường ánh sáng động (ngày/đêm, nắng/mưa), với công nghệ WDR/HDR mạnh mẽ. Điều này có thể vượt trội so với một số CCTV giá rẻ trong việc xử lý chênh lệch sáng tối.\u003c/li\u003e\n\u003cli\u003eTính di động và dễ lắp đặt:\n\u003cul\u003e\n\u003cli\u003eDashcam nhỏ gọn, dễ lắp đặt (thường dùng băng dính hoặc giá đỡ hút chân không), không cần đi dây phức tạp như nhiều hệ thống CCTV. Bạn có thể dễ dàng tháo lắp hoặc di chuyển đến vị trí khác.\u003c/li\u003e\n\u003cli\u003eMột số dashcam hỗ trợ pin hoặc nguồn USB, giúp sử dụng linh hoạt hơn ở những nơi không có nguồn điện cố định.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eChi phí hợp lý: Một chiếc dashcam chất lượng tốt (2K/4K) thường có giá từ 2-5 triệu VND, rẻ hơn so với hệ thống CCTV cao cấp (bao gồm camera, DVR, ổ cứng, và công lắp đặt). Nếu bạn chỉ cần một camera đơn lẻ, dashcam là lựa chọn tiết kiệm.\u003c/li\u003e\n\u003cli\u003eTính năng bổ sung: Nhiều dashcam có các tính năng như ghi vòng lặp, cảm biến va chạm (G-sensor), hoặc kết nối Wi-Fi để xem video trực tiếp trên điện thoại. Những tính năng này có thể thay thế hoặc bổ sung cho các chức năng của CCTV.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"hạn-chế-khi-dùng-dashcam-thay-cho-cctv\"\u003eHạn chế khi dùng dashcam thay cho CCTV\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eThiết kế không tối ưu cho giám sát liên tục:\n\u003cul\u003e\n\u003cli\u003eDashcam được thiết kế để ghi hình ngắn hạn và ghi vòng lặp (loop recording), tự động xóa dữ liệu cũ khi thẻ nhớ đầy. Điều này không phù hợp với CCTV, vốn cần lưu trữ video dài ngày (hàng tuần hoặc tháng) để phục vụ giám sát an ninh.\u003c/li\u003e\n\u003cli\u003eDung lượng thẻ nhớ của dashcam (thường 32GB-256GB) nhỏ hơn nhiều so với ổ cứng của hệ thống CCTV (hàng TB), khiến việc lưu trữ lâu dài bị hạn chế.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eKhông hỗ trợ hệ thống giám sát đa camera: CCTV thường được thiết kế để hoạt động trong hệ thống nhiều camera, \u003ccode\u003ekết nối với DVR/NVR để quản lý tập trung\u003c/code\u003e. \u003cstrong\u003eDashcam hoạt động độc lập, không dễ tích hợp vào một hệ thống giám sát phức tạp hoặc xem đồng thời nhiều góc quay\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eThiếu tính năng giám sát chuyên dụng:\n\u003cul\u003e\n\u003cli\u003eCCTV thường có các tính năng như phát hiện chuyển động, cảnh báo thời gian thực, hoặc tích hợp với hệ thống báo động. Dashcam hiếm khi có những tính năng này hoặc chỉ hỗ trợ ở mức cơ bản (ví dụ: chế độ parking mode).\u003c/li\u003e\n\u003cli\u003eMột số dashcam không hỗ trợ xem trực tiếp từ xa qua internet, trong khi CCTV thường có ứng dụng hoặc phần mềm để giám sát từ xa.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐộ bền và khả năng hoạt động liên tục:\n\u003cul\u003e\n\u003cli\u003eDashcam được thiết kế để hoạt động trong xe, nhưng không phải lúc nào cũng chịu được điều kiện thời tiết khắc nghiệt (mưa, nắng lâu dài) nếu lắp ngoài trời. CCTV ngoài trời thường có chuẩn chống nước/bụi (IP66, IP67) tốt hơn.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDashcam có thể quá nóng hoặc giảm tuổi thọ nếu hoạt động liên tục 24/7\u003c/strong\u003e, vì chúng không được thiết kế cho việc ghi hình không ngừng nghỉ như CCTV.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eNguồn điện và lắp đặt cố định:\n\u003cul\u003e\n\u003cli\u003eDashcam thường lấy điện từ cổng USB hoặc ổ cắm 12V trong xe, không phù hợp cho các vị trí cố định trong nhà hoặc ngoài trời (yêu cầu nguồn 220V hoặc PoE). Việc cấp nguồn liên tục cho dashcam có thể phức tạp hơn so với hệ thống CCTV.\u003c/li\u003e\n\u003cli\u003eDashcam không có cơ chế gắn cố định chắc chắn như CCTV, dễ bị tháo trộm hoặc dịch chuyển nếu dùng ở nơi công cộng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHạn chế về phần mềm và tích hợp:\n\u003cul\u003e\n\u003cli\u003eCCTV thường đi kèm phần mềm quản lý chuyên dụng (như Hikvision, Dahua) để xem lại, tìm kiếm, hoặc xuất video dễ dàng. Dashcam chủ yếu dựa vào ứng dụng di động hoặc xem trực tiếp trên thẻ nhớ, không thuận tiện cho việc quản lý video dài hạn.\u003c/li\u003e\n\u003cli\u003eDashcam không hỗ trợ tích hợp với các hệ thống smarthome hoặc thiết bị an ninh khác, trong khi CCTV có thể kết nối với cảm biến, chuông báo, hoặc trợ lý ảo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kết-luận-và-khuyến-nghị\"\u003eKết luận và khuyến nghị\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi nào \u003ccode\u003enên\u003c/code\u003e dùng dashcam thay CCTV?\n\u003cul\u003e\n\u003cli\u003eNếu bạn cần một giải pháp giám sát đơn giản, chi phí thấp cho một khu vực nhỏ (như bãi đỗ xe, cửa trước nhà) và không cần lưu trữ video lâu dài.\u003c/li\u003e\n\u003cli\u003eNếu bạn muốn tận dụng độ phân giải cao và khả năng ghi hình trong điều kiện ánh sáng thay đổi.\u003c/li\u003e\n\u003cli\u003eNếu bạn cần một thiết bị di động, dễ tháo lắp để sử dụng ở nhiều vị trí.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eKhi nào \u003ccode\u003ekhông nên\u003c/code\u003e dùng dashcam thay CCTV?\n\u003cul\u003e\n\u003cli\u003eNếu bạn cần một hệ thống giám sát liên tục 24/7, lưu trữ video dài hạn, hoặc quản lý nhiều camera cùng lúc.\u003c/li\u003e\n\u003cli\u003eNếu bạn cần các tính năng an ninh nâng cao như phát hiện chuyển động, xem từ xa, hoặc tích hợp với hệ thống báo động.\u003c/li\u003e\n\u003cli\u003eNếu camera phải lắp ngoài trời hoặc ở vị trí cố định lâu dài, nơi yêu cầu độ bền cao và chống chịu thời tiết.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"đề-xuất\"\u003eĐề xuất:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKết hợp cả hai: Bạn có thể dùng dashcam như một camera bổ sung cho các khu vực cụ thể (ví dụ: giám sát xe trong bãi đỗ) và sử dụng CCTV cho các khu vực cần giám sát liên tục hoặc chuyên sâu hơn.\u003c/li\u003e\n\u003cli\u003eChọn dashcam phù hợp: Nếu muốn dùng dashcam cho mục đích CCTV, hãy chọn model có chế độ parking mode, hỗ trợ thẻ nhớ dung lượng lớn, và khả năng xem từ xa qua Wi-Fi. Ví dụ: các dòng từ Viofo, BlackVue, hoặc Thinkware.\u003c/li\u003e\n\u003cli\u003eNâng cấp hệ thống CCTV: Nếu bạn muốn độ phân giải cao như dashcam, hãy xem xét các dòng CCTV 2K/4K từ các thương hiệu như Hikvision, Dahua, hoặc Reolink, dù chi phí sẽ cao hơn.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/cctv_dashcam/",
      "date_published": "1056-01-09T52:11:00+07:00",
      "date_modified": "1056-01-09T52:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "3acc24843a3da86467f708a0615c31b7acd3d5cd",
      "title": "EMQK_Broker",
      "summary": "",
      "content_text": "Đây là nội dung mà mình hỏi chatGPT về EMQX\nVà làm bài so sánh cũng như phân tích khả năng kết hợp.\nKết hợp EMQX và ThingsBoard ✅ Câu trả lời ngắn gọn: Có, hoàn toàn có thể kết hợp EMQX và ThingsBoard trong cùng một hệ thống IoT, và cách kết hợp này thực tế rất phổ biến trong các dự án lớn.\n1. Kết hợp EMQX và ThingsBoard như thế nào? EMQX sẽ làm nhiệm vụ broker — chịu trách nhiệm nhận tất cả kết nối MQTT từ thiết bị (sensor, gateway, device). ThingsBoard sẽ làm nhiệm vụ backend — xử lý dữ liệu từ EMQX gửi lên, lưu trữ, xử lý logic (rules), hiển thị dashboard. Mô hình kiến trúc đơn giản Thiết bị sẽ publish MQTT message tới EMQX. ThingsBoard sẽ kết nối với EMQX với vai trò MQTT Client hoặc MQTT Integration, để: Subscribe những topic cần thiết. Parse data. Lưu dữ liệu vào hệ thống (database). Visualize dữ liệu lên dashboard. 2. Có cần chỉnh cấu hình gì không? Có, cần lưu ý 2 bước:\nBước Nội dung cần làm 1. Cấu hình EMQX - Cho phép ThingsBoard connect đến EMQX.\n- Nếu cần, set ACL để ThingsBoard có quyền subscribe/publish topic phù hợp. 2. Cấu hình ThingsBoard - Tạo Integration dạng MQTT.\n- Chỉ định địa chỉ EMQX (host, port, username, password).\n- Mapping topic/telemetry vào thiết bị ThingsBoard. Tài liệu tham khảo:\nEMQX - How to Allow External MQTT Clients ThingsBoard - MQTT Integration Guide 3. Những điểm lưu ý khi kết hợp Vấn đề Giải thích QoS EMQX và ThingsBoard đều hỗ trợ QoS 0/1/2, nên cần match QoS config nếu cần đảm bảo độ tin cậy cao. Authentication EMQX hỗ trợ nhiều dạng auth (username/password, cert), ThingsBoard nên dùng cơ chế bảo mật phù hợp. Topic format Cần thống nhất định dạng topic giữa thiết bị và ThingsBoard.\nVí dụ: devices/\u0026lt;device_id\u0026gt;/telemetry Performance Nếu lượng thiết bị lớn (\u0026gt;10k devices), nên tuning EMQX để tối ưu connection pool, và ThingsBoard để optimize db storage. Scaling EMQX scale riêng, ThingsBoard scale riêng (ThingsBoard có phiên bản Edge để chạy local gần thiết bị). 4. Khi nào nên kết hợp? Trường hợp Nên kết hợp? Hệ thống có hàng ngàn đến triệu thiết bị IoT ✅ Cần broker riêng để tối ưu hiệu suất, bảo mật ✅ Cần phân chia rõ nhiệm vụ: hạ tầng giao tiếp vs xử lý ứng dụng ✅ Cần tận dụng tính năng chuyên sâu của từng nền tảng ✅ 5. Minh họa sơ đồ ➔ Nếu cần, có thể thêm các services như Kafka, DB, Alert System\u0026hellip; phía sau EMQX hoặc ThingsBoard.\n6. Tài liệu gốc tham khảo EMQX - Best Practices with MQTT Broker ThingsBoard - Integrating with External MQTT Broker Example - How to Integrate EMQX and ThingsBoard 👉 Tóm lại ✔ EMQX = broker chuyên trách dữ liệu\n✔ ThingsBoard = platform xử lý dữ liệu + hiển thị + quản lý thiết bị\n✔ Kết hợp lại = xây dựng hệ thống IoT lớn, chuyên nghiệp, dễ mở rộng.\n",
      "content_html": "\u003cp\u003eĐây là nội dung mà mình hỏi chatGPT về \u003cstrong\u003eEMQX\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eVà làm bài so sánh cũng như phân tích khả năng kết hợp.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"kết-hợp-emqx-và-thingsboard\"\u003eKết hợp EMQX và ThingsBoard\u003c/h1\u003e\n\u003cp\u003e✅ \u003cstrong\u003eCâu trả lời ngắn gọn\u003c/strong\u003e: \u003cstrong\u003eCó\u003c/strong\u003e, hoàn toàn có thể \u003cstrong\u003ekết hợp EMQX và ThingsBoard\u003c/strong\u003e trong cùng một hệ thống IoT, và cách kết hợp này thực tế \u003cstrong\u003erất phổ biến\u003c/strong\u003e trong các dự án lớn.\u003c/p\u003e\n\u003ch2 id=\"1-kết-hợp-emqx-và-thingsboard-như-thế-nào\"\u003e1. Kết hợp EMQX và ThingsBoard như thế nào?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eEMQX\u003c/strong\u003e sẽ \u003cstrong\u003elàm nhiệm vụ broker\u003c/strong\u003e — chịu trách nhiệm nhận tất cả kết nối MQTT từ thiết bị (sensor, gateway, device).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eThingsBoard\u003c/strong\u003e sẽ \u003cstrong\u003elàm nhiệm vụ backend\u003c/strong\u003e — xử lý dữ liệu từ EMQX gửi lên, lưu trữ, xử lý logic (rules), hiển thị dashboard.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mô-hình-kiến-trúc-đơn-giản\"\u003eMô hình kiến trúc đơn giản\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://docs.emqx.com/assets/100m-benckmark.k0vOTtqJ.png\"\n  alt=\"EMQX\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThiết bị sẽ \u003cstrong\u003epublish MQTT message tới EMQX\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eThingsBoard\u003c/strong\u003e sẽ kết nối với EMQX với vai trò \u003cstrong\u003eMQTT Client\u003c/strong\u003e hoặc \u003cstrong\u003eMQTT Integration\u003c/strong\u003e, để:\n\u003cul\u003e\n\u003cli\u003eSubscribe những topic cần thiết.\u003c/li\u003e\n\u003cli\u003eParse data.\u003c/li\u003e\n\u003cli\u003eLưu dữ liệu vào hệ thống (database).\u003c/li\u003e\n\u003cli\u003eVisualize dữ liệu lên dashboard.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2-có-cần-chỉnh-cấu-hình-gì-không\"\u003e2. Có cần chỉnh cấu hình gì không?\u003c/h2\u003e\n\u003cp\u003eCó, cần lưu ý 2 bước:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eBước\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eNội dung cần làm\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003e1. Cấu hình EMQX\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e- Cho phép ThingsBoard connect đến EMQX.\u003cbr\u003e - Nếu cần, set ACL để ThingsBoard có quyền subscribe/publish topic phù hợp.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003e2. Cấu hình ThingsBoard\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e- Tạo Integration dạng \u003cstrong\u003eMQTT\u003c/strong\u003e.\u003cbr\u003e - Chỉ định địa chỉ EMQX (host, port, username, password).\u003cbr\u003e - Mapping topic/telemetry vào thiết bị ThingsBoard.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eTài liệu tham khảo:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.emqx.io/docs/en/latest/mqtt/mqtt-connection.html\"\u003eEMQX - How to Allow External MQTT Clients\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://thingsboard.io/docs/user-guide/integrations/mqtt/\"\u003eThingsBoard - MQTT Integration Guide\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-những-điểm-lưu-ý-khi-kết-hợp\"\u003e3. Những điểm lưu ý khi kết hợp\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eVấn đề\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eGiải thích\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003eQoS\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eEMQX và ThingsBoard đều hỗ trợ QoS 0/1/2, nên cần match QoS config nếu cần đảm bảo độ tin cậy cao.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003eAuthentication\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eEMQX hỗ trợ nhiều dạng auth (username/password, cert), ThingsBoard nên dùng cơ chế bảo mật phù hợp.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003eTopic format\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eCần thống nhất định dạng topic giữa thiết bị và ThingsBoard.\u003cbr\u003eVí dụ: \u003ccode\u003edevices/\u0026lt;device_id\u0026gt;/telemetry\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eNếu lượng thiết bị lớn (\u0026gt;10k devices), nên tuning EMQX để tối ưu connection pool, và ThingsBoard để optimize db storage.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003eScaling\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eEMQX scale riêng, ThingsBoard scale riêng (ThingsBoard có phiên bản Edge để chạy local gần thiết bị).\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"4-khi-nào-nên-kết-hợp\"\u003e4. Khi nào nên kết hợp?\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eTrường hợp\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eNên kết hợp?\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eHệ thống có hàng ngàn đến triệu thiết bị IoT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e✅\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCần broker riêng để tối ưu hiệu suất, bảo mật\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e✅\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCần phân chia rõ nhiệm vụ: hạ tầng giao tiếp vs xử lý ứng dụng\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e✅\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCần tận dụng tính năng chuyên sâu của từng nền tảng\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e✅\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"5-minh-họa-sơ-đồ\"\u003e5. Minh họa sơ đồ\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://docs.emqx.com/assets/clickhouse_architecture.obob927B.png\"\n  alt=\"Architecture\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e➔ Nếu cần, có thể thêm các services như Kafka, DB, Alert System\u0026hellip; phía sau EMQX hoặc ThingsBoard.\u003c/p\u003e\n\u003ch2 id=\"6-tài-liệu-gốc-tham-khảo\"\u003e6. Tài liệu gốc tham khảo\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.emqx.io/docs/en/latest/best-practices/mqtt-best-practices.html\"\u003eEMQX - Best Practices with MQTT Broker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://thingsboard.io/docs/user-guide/integrations/mqtt/\"\u003eThingsBoard - Integrating with External MQTT Broker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.emqx.io/blog/integrate-thingsboard-with-emqx-mqtt-broker\"\u003eExample - How to Integrate EMQX and ThingsBoard\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"-tóm-lại\"\u003e👉 Tóm lại\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e✔ EMQX = broker chuyên trách dữ liệu\u003cbr\u003e\n✔ ThingsBoard = platform xử lý dữ liệu + hiển thị + quản lý thiết bị\u003cbr\u003e\n✔ Kết hợp lại = xây dựng hệ thống IoT lớn, chuyên nghiệp, dễ mở rộng.\u003c/p\u003e\n\u003c/blockquote\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/emqk_broker/",
      "date_published": "1056-01-09T547:11:00+07:00",
      "date_modified": "1056-01-09T547:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "f0c967fae584da16ebf61fc2cfa9b8c9d2b83b5b",
      "title": "Bo_giam_ap",
      "summary": "",
      "content_text": "Có một hôm đang kiểm tra một mạch điện cảm biến ánh sáng.\nVô tình trong lúc cấp nguồn, mình để dây dương và dây âm chập với nhau.\nNguồn tổ ong bị nổ, làm sập luôn hệ thống wifi mesh, camera (vì nguồn này cấp 12VDC cho Aruba và Camera IP).\nThế là phải mất cả buổi để làm lại cấp tốc một bộ giảm áp. (Hôm đó là Chủ nhật, không ra Nhật Tảo mua nguồn tổ ong 12VDC được, nên phải dùng nguồn 24VDC).\nSơ đồ của bộ đo Volt và Ampe Mạch hoàn thành Đây là góc làm việc nhỏ của mình, với cả đống dây nhợ =]]\nĐây là cận cạnh bộ mạch đã hoàn tất.\n",
      "content_html": "\u003cp\u003eCó một hôm đang kiểm tra một mạch điện \u003cstrong\u003ecảm biến ánh sáng\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eVô tình trong lúc cấp nguồn, mình để \u003cem\u003edây dương\u003c/em\u003e và \u003cem\u003edây âm\u003c/em\u003e \u003cstrong\u003echập với nhau\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNguồn tổ ong bị \u003cmark\u003enổ\u003c/mark\u003e, làm sập luôn hệ thống \u003cstrong\u003ewifi mesh, camera\u003c/strong\u003e \u003cem\u003e(vì nguồn này cấp 12VDC cho Aruba và Camera IP)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThế là phải mất cả buổi để làm lại \u003cstrong\u003ecấp tốc\u003c/strong\u003e một bộ giảm áp. \u003cem\u003e(Hôm đó là Chủ nhật, không ra Nhật Tảo mua nguồn tổ ong 12VDC được, nên phải dùng nguồn 24VDC)\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"sơ-đồ-của-bộ-đo-volt-và-ampe\"\u003eSơ đồ của bộ đo Volt và Ampe\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Bo_giam_ap/Hinh_0.webp\"\n  alt=\"Sơ đồ\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"mạch-hoàn-thành\"\u003eMạch hoàn thành\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Bo_giam_ap/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐây là góc làm việc nhỏ của mình, với cả đống \u003cem\u003edây nhợ\u003c/em\u003e =]]\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Bo_giam_ap/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐây là cận cạnh bộ mạch đã hoàn tất.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/bo_giam_ap/",
      "date_published": "1056-01-09T534:11:00+07:00",
      "date_modified": "1056-01-09T534:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "6495e1381afe31a96302ee0e21b55529ca8e8ade",
      "title": "Slidev",
      "summary": "",
      "content_text": "Video: Mình trở thành “Nạn Nhân” của AI… Sau khi mình xem xong video của anh Hoàng, mình bị ấn tượng bởi công cụ Slidev.\nĐây sẽ là một công cụ giúp mình hoàn thành nhanh một powerpoint bằng các ghi chú dạng markdown.\nMình làm ban đầu rất mất thời gian, vì để làm slides đẹp thì không chỉ dùng các syntax markdown đơn giản.\nMà còn phải dùng đến HTML. Nhưng cuối cùng cũng xong.\nĐã có format, thì sau này mình sẽ làm ppt nhanh hơn.\nTài liệu về Slidev: https://sli.dev/guide/ https://sli.dev/demo/starter/2 https://sli.dev/builtin/cli#dev https://sli.dev/guide/hosting https://github.com/slidevjs/slidev https://github.com/slidevjs/slidev/tree/main/demo Note Hiện tại mình có thể build ra folder để chạy web, thuật ngữ SPA (Single-page application). Và build web này ở local dùng docker. Một số công cụ khác: Đây là một số công cụ mình thấy cũng hay ho khác.\nGradio Một công cụ tạo code nhanh cho front-end https://github.com/gradio-app/gradio markitdown Mình dùng công cụ này để lấy nội dung text trong 1 file bất kỳ. Nội dung được lấy ra sẽ được lưu ở định dạng markdown. ",
      "content_html": "\u003ch2 id=\"video-mình-trở-thành-nạn-nhân-của-aihttpswwwyoutubecomwatchvnpe3rlcen1a\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=nPE3rLcEN1A\"\u003eVideo: Mình trở thành “Nạn Nhân” của AI…\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Slidev/Noi_dung_Video.png\"\n  alt=\"Tổng hợp\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eSau khi mình xem xong video của anh Hoàng, mình bị ấn tượng bởi công cụ \u003cstrong\u003eSlidev\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐây sẽ là một công cụ giúp mình hoàn thành nhanh một \u003cstrong\u003epowerpoint\u003c/strong\u003e bằng các ghi chú dạng \u003cstrong\u003emarkdown\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình làm ban đầu rất mất thời gian, vì để làm slides đẹp thì không chỉ dùng các \u003cem\u003esyntax markdown\u003c/em\u003e đơn giản.\u003c/p\u003e\n\u003cp\u003eMà còn phải dùng đến \u003cstrong\u003eHTML\u003c/strong\u003e. Nhưng cuối cùng cũng xong.\u003c/p\u003e\n\u003cp\u003eĐã có format, thì sau này mình sẽ làm \u003cstrong\u003eppt\u003c/strong\u003e nhanh hơn.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Slidev/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tài-liệu-về-slidev\"\u003eTài liệu về Slidev:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://sli.dev/guide/\nhttps://sli.dev/demo/starter/2\nhttps://sli.dev/builtin/cli#dev\nhttps://sli.dev/guide/hosting\nhttps://github.com/slidevjs/slidev\nhttps://github.com/slidevjs/slidev/tree/main/demo\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiện tại mình có thể build ra folder để chạy web, thuật ngữ \u003cstrong\u003eSPA (Single-page application)\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà build web này ở local dùng docker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"một-số-công-cụ-khác\"\u003eMột số công cụ khác:\u003c/h2\u003e\n\u003cp\u003eĐây là một số công cụ mình thấy cũng hay ho khác.\u003c/p\u003e\n\u003ch3 id=\"gradiohttpswwwgradioappguidesquickstart\"\u003e\u003ca href=\"https://www.gradio.app/guides/quickstart\"\u003eGradio\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột công cụ tạo code nhanh cho front-end\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gradio-app/gradio\"\u003ehttps://github.com/gradio-app/gradio\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"markitdownhttpsgithubcommicrosoftmarkitdown\"\u003e\u003ca href=\"https://github.com/microsoft/markitdown\"\u003emarkitdown\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình dùng công cụ này để lấy nội dung text trong 1 file bất kỳ.\u003c/li\u003e\n\u003cli\u003eNội dung được lấy ra sẽ được lưu ở định dạng markdown.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/slidev/",
      "date_published": "30046-30-09T47:3030:00+07:00",
      "date_modified": "30046-30-09T47:3030:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "2ded02eee05a1e6698bcb02ea67c77a1003f305e",
      "title": "ConvoC2",
      "summary": "",
      "content_text": "Video: ms teams is now a C2 (command-and-control) Github: cxnturi0n / convoC2 Một số tài liệu khác: https://logon-int.com/blog/convoc2/ https://gbhackers.com/convoc2-a-red-teamers-tool/ GitHub - C2 infrastructure over Microsoft Teams technijian.com - convoC2 the new red team tool leveraging Microsoft Teams logon-int.com - ConvoC2 A Red Teamer\u0026#39;s Tool to Exploit Microsoft Teams gbhackers.com - ConvoC2 A Red Teamers Tool To Execute Commands on Hacked Hosts Via Microsoft Teams Polymer - Unveiling Microsoft Teams vulnerabilities risks and protections The Daily Swig - Multiple vulnerabilities in Microsoft Teams could spoof URLs leak IP addresses Ngoài ra mình còn tham khảo ý kiến của Grok 3 và đây là các thông tin mà Grok cung cấp: Hiện tại, không có thông tin chính thức nào từ Microsoft xác nhận rằng đã có bản vá cụ thể cho lỗ hổng liên quan đến ConvoC2 trong Microsoft Teams tính đến ngày 12 tháng 4 năm 2025. ConvoC2 là một công cụ khai thác mới được công bố vào cuối năm 2024, tận dụng các tin nhắn Teams để thực thi lệnh từ xa mà không kích hoạt các biện pháp bảo mật thông thường. Nó không dựa vào một lỗ hổng phần mềm truyền thống (như lỗi mã hóa) mà lợi dụng cách Teams xử lý tin nhắn và nhật ký, khiến việc vá khó khăn hơn.\nTình hình hiện tại:\nThiếu bản vá cụ thể: Microsoft chưa công bố bản cập nhật nào nhắm trực tiếp đến ConvoC2. Điều này có thể do công cụ này khai thác các tính năng hợp pháp của Teams (như tin nhắn ẩn và webhook) thay vì một lỗi rõ ràng. Khuyến nghị bảo mật: Microsoft và các chuyên gia bảo mật khuyến nghị: Giám sát nhật ký Teams: Kiểm tra thường xuyên các hoạt động bất thường trong Teams, đặc biệt là các tin nhắn hoặc webhook đáng nghi. Triển khai EDR: Sử dụng các công cụ phát hiện và phản hồi điểm cuối (Endpoint Detection and Response) để phát hiện hành vi bất thường. Hạn chế truy cập: Đảm bảo chỉ những người dùng đáng tin cậy có quyền truy cập vào các kênh Teams và webhook. Cộng đồng bảo mật: ConvoC2 được công khai trên GitHub để khuyến khích nghiên cứu và phòng thủ, nhưng không có dấu hiệu Microsoft đã thay đổi giao thức Teams để vô hiệu hóa phương thức tấn công này. Dự đoán:\nMicrosoft có thể không phát hành một \u0026ldquo;bản vá\u0026rdquo; theo nghĩa truyền thống mà thay vào đó sẽ cập nhật các biện pháp bảo mật trong Teams, như tăng cường kiểm tra tin nhắn hoặc giới hạn cách dữ liệu ẩn được xử lý. Tuy nhiên, vì ConvoC2 dựa vào các tính năng cốt lõi của Teams, việc chặn hoàn toàn có thể làm gián đoạn chức năng thông thường, khiến việc xử lý trở nên phức tạp. Nếu bạn muốn theo dõi sát sao, hãy kiểm tra các bản cập nhật bảo mật hàng tháng của Microsoft (Patch Tuesday) hoặc liên hệ trực tiếp với đội ngũ hỗ trợ của Microsoft để hỏi về các biện pháp phòng thủ cụ thể.\nLỗ hổng trên Microsoft Teams cho Android: ConvoC2 chủ yếu được thiết kế cho PC (Windows), không có bằng chứng rõ ràng về việc hỗ trợ Android hoặc thiết bị di động. Nghiên cứu cho thấy công cụ này hoạt động trên Windows 10 và 11, nhưng không đề cập đến Android. Có khả năng lý thuyết ConvoC2 hoạt động trên Android nếu Teams xử lý tin nhắn tương tự, nhưng chưa được xác nhận. ",
      "content_html": "\u003ch3 id=\"video-ms-teams-is-now-a-c2-command-and-controlhttpswwwyoutubecomwatchvfqzim6vp7xmlistwlindex5t45s\"\u003eVideo: \u003ca href=\"https://www.youtube.com/watch?v=FqZIm6vP7XM\u0026amp;list=WL\u0026amp;index=5\u0026amp;t=45s\"\u003ems teams is now a C2 (command-and-control)\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"github-cxnturi0n--convoc2httpsgithubcomcxnturi0nconvoc2\"\u003eGithub: \u003ca href=\"https://github.com/cxnturi0n/convoC2\"\u003ecxnturi0n / convoC2\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"một-số-tài-liệu-khác\"\u003eMột số tài liệu khác:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://logon-int.com/blog/convoc2/\"\u003ehttps://logon-int.com/blog/convoc2/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gbhackers.com/convoc2-a-red-teamers-tool/\"\u003ehttps://gbhackers.com/convoc2-a-red-teamers-tool/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGitHub - C2 infrastructure over Microsoft Teams\ntechnijian.com - convoC2 the new red team tool leveraging Microsoft Teams\nlogon-int.com - ConvoC2 A Red Teamer\u0026#39;s Tool to Exploit Microsoft Teams\ngbhackers.com - ConvoC2 A Red Teamers Tool To Execute Commands on Hacked Hosts Via Microsoft Teams\nPolymer - Unveiling Microsoft Teams vulnerabilities risks and protections\nThe Daily Swig - Multiple vulnerabilities in Microsoft Teams could spoof URLs leak IP addresses\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://github.com/user-attachments/assets/d126a4cb-dc62-4a18-8b89-3501a4319d6e\"\n  alt=\"convoC2-Architecture\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ngoài-ra-mình-còn-tham-khảo-ý-kiến-của-grok-3-và-đây-là-các-thông-tin-mà-grok-cung-cấp\"\u003eNgoài ra mình còn tham khảo ý kiến của Grok 3 và đây là các thông tin mà Grok cung cấp:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiện tại, không có thông tin chính thức nào từ Microsoft xác nhận rằng đã có bản vá cụ thể cho lỗ hổng liên quan đến ConvoC2 trong Microsoft Teams tính đến ngày 12 tháng 4 năm 2025.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eConvoC2\u003c/strong\u003e là một công cụ khai thác mới được công bố vào cuối năm 2024, tận dụng các tin nhắn Teams để thực thi lệnh từ xa mà không kích hoạt các biện pháp bảo mật thông thường. \u003c/br\u003e\nNó không dựa vào một lỗ hổng phần mềm truyền thống (như lỗi mã hóa) mà \u003cstrong\u003elợi dụng cách Teams xử lý tin nhắn và nhật ký\u003c/strong\u003e, khiến việc vá khó khăn hơn.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTình hình hiện tại:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThiếu bản vá cụ thể: Microsoft chưa công bố bản cập nhật nào nhắm trực tiếp đến ConvoC2. Điều này có thể do công cụ này khai thác các tính năng hợp pháp của Teams (như tin nhắn ẩn và webhook) thay vì một lỗi rõ ràng.\u003c/li\u003e\n\u003cli\u003eKhuyến nghị bảo mật: Microsoft và các chuyên gia bảo mật khuyến nghị:\u003c/li\u003e\n\u003cli\u003eGiám sát nhật ký Teams: Kiểm tra thường xuyên các hoạt động bất thường trong Teams, đặc biệt là các tin nhắn hoặc webhook đáng nghi.\u003c/li\u003e\n\u003cli\u003eTriển khai EDR: Sử dụng các công cụ phát hiện và phản hồi điểm cuối (Endpoint Detection and Response) để phát hiện hành vi bất thường.\u003c/li\u003e\n\u003cli\u003eHạn chế truy cập: Đảm bảo chỉ những người dùng đáng tin cậy có quyền truy cập vào các kênh Teams và webhook.\u003c/li\u003e\n\u003cli\u003eCộng đồng bảo mật: ConvoC2 được công khai trên GitHub để khuyến khích nghiên cứu và phòng thủ, nhưng không có dấu hiệu Microsoft đã thay đổi giao thức Teams để vô hiệu hóa phương thức tấn công này.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDự đoán:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMicrosoft có thể không phát hành một \u0026ldquo;bản vá\u0026rdquo; theo nghĩa truyền thống mà thay vào đó sẽ \u003cem\u003ecập nhật các biện pháp bảo mật trong Teams\u003c/em\u003e, như tăng cường kiểm tra tin nhắn hoặc giới hạn cách dữ liệu ẩn được xử lý. \u003c/br\u003e\nTuy nhiên, vì \u003cstrong\u003eConvoC2 dựa vào các tính năng cốt lõi của Teams\u003c/strong\u003e, việc chặn hoàn toàn có thể làm gián đoạn chức năng thông thường, khiến việc xử lý trở nên phức tạp. \u003c/br\u003e\nNếu bạn muốn theo dõi sát sao, hãy kiểm tra các bản cập nhật bảo mật hàng tháng của Microsoft (Patch Tuesday) hoặc liên hệ trực tiếp với đội ngũ hỗ trợ của Microsoft để hỏi về các biện pháp phòng thủ cụ thể.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eLỗ hổng trên Microsoft Teams cho Android:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eConvoC2 chủ yếu được thiết kế cho PC (Windows), không có bằng chứng rõ ràng về việc hỗ trợ Android hoặc thiết bị di động.  \nNghiên cứu cho thấy công cụ này hoạt động trên Windows 10 và 11, nhưng không đề cập đến Android.  \nCó khả năng lý thuyết ConvoC2 hoạt động trên Android nếu Teams xử lý tin nhắn tương tự, nhưng chưa được xác nhận.\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/convoc2/",
      "date_published": "13046-13-09T47:1313:00+07:00",
      "date_modified": "13046-13-09T47:1313:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "3f5edd49dc92af5be0ccc6dd7a1874a6db9b41c2",
      "title": "HeyGen_AI",
      "summary": "",
      "content_text": "Đây là một công cụ tạo video bằng AI\nTạo tài khoản free bằng google, một tháng được 3 lần tạo video.\nTài liệu:\nhttps://app.heygen.com/get-started https://docs.heygen.com/docs/create-video Các tính năng của HeyGen:\nHỗ trợ đến +175 ngôn ngữ. Tạo video: Avatar Video. Video Translation. Mình đã test thử:\nMột số API như List language: https://docs.heygen.com/reference/list-supported-languages\nTham khảo thêm tại đây.\n",
      "content_html": "\u003cp\u003eĐây là một công cụ tạo video bằng AI\u003c/p\u003e\n\u003cp\u003eTạo tài khoản free bằng google, một tháng được 3 lần tạo video.\u003c/p\u003e\n\u003cp\u003eTài liệu:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://app.heygen.com/get-started\nhttps://docs.heygen.com/docs/create-video\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCác tính năng của \u003cstrong\u003eHeyGen\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHỗ trợ đến \u003cstrong\u003e+175 ngôn ngữ\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTạo video:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAvatar Video\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVideo Translation\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMình đã test thử:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/HeyGen_Video.jpg\"\n  alt=\"HeyGen_Video\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMột số API như \u003cstrong\u003eList language\u003c/strong\u003e: \u003ca href=\"https://docs.heygen.com/reference/list-supported-languages\"\u003ehttps://docs.heygen.com/reference/list-supported-languages\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTham khảo thêm \u003ca href=\"https://docs.heygen.com/reference/authentication\"\u003etại đây\u003c/a\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/heygen_ai/",
      "date_published": "12046-12-09T416:1212:00+07:00",
      "date_modified": "12046-12-09T416:1212:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "5154903511a94330a332d17e6f745b7ee4470442",
      "title": "Gia_lap_sut_ap_ACC",
      "summary": "",
      "content_text": "Mình nhận được một đề bài đó là làm \u0026ldquo;Một bộ giả lập sụt áp, mất nguồn ACC\u0026rdquo;.\nMô tả như sau tình trạng như sau:\nTrên xe ô tô, khi mở khóa ACC \u0026mdash;\u0026gt; các thiết bị hoạt động. Khi đạp thắng và nổ máy \u0026mdash;\u0026gt; Nguồn bị sụt áp, các thiết bị điện trên bị tắt tạm thời, và sau đó áp tăng lên đột ngột. Dựa vào mô tả này, mình đã code lại dựa trên ngôn ngữ Ladder (một ngôn ngữ lập trình cho PLC).\nRồi từ đây, mình mua module cần thiết và bắt đầu lắp ghép mạch trên bảng điện.\nSau khi đã lắp hoàn thiện, mình cho chạy thử. Và đã chạy thành công, giống với nội dung được yêu cầu.\nNguồn video: https://www.facebook.com/share/v/1BJo6tVgVR/\n",
      "content_html": "\u003cp\u003eMình nhận được một đề bài đó là làm \u0026ldquo;Một bộ giả lập sụt áp, mất nguồn ACC\u0026rdquo;.\u003c/p\u003e\n\u003cp\u003eMô tả như sau tình trạng như sau:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTrên xe ô tô, khi mở khóa ACC \u0026mdash;\u0026gt; các thiết bị hoạt động. \u003c/br\u003e\nKhi \u003cstrong\u003eđạp thắng\u003c/strong\u003e và \u003cstrong\u003enổ máy\u003c/strong\u003e \u0026mdash;\u0026gt; Nguồn bị sụt áp, các thiết bị điện trên bị tắt tạm thời, và sau đó áp tăng lên đột ngột. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eDựa vào mô tả này, mình đã \u003cstrong\u003ecode\u003c/strong\u003e lại dựa trên \u003cstrong\u003engôn ngữ Ladder\u003c/strong\u003e \u003cem\u003e(một ngôn ngữ lập trình cho \u003cstrong\u003ePLC\u003c/strong\u003e)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Sut_ap_ACC/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eRồi từ đây, mình mua module cần thiết và bắt đầu lắp ghép mạch trên bảng điện.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Sut_ap_ACC/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eSau khi đã lắp hoàn thiện, mình cho chạy thử. Và đã chạy thành công, giống với nội dung được yêu cầu.\u003c/p\u003e\n\u003cp\u003eNguồn video: \u003ca href=\"https://www.facebook.com/share/v/1BJo6tVgVR/\"\u003ehttps://www.facebook.com/share/v/1BJo6tVgVR/\u003c/a\u003e\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/gia_lap_sut_ap_acc/",
      "date_published": "11046-11-09T49:1111:00+07:00",
      "date_modified": "11046-11-09T49:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "07bfeb01dbc5be2aa15dbd7a9924ef38ead2a813",
      "title": "Hop_do_choi_AI",
      "summary": "",
      "content_text": "Trend \u0026ldquo;Hộp đồ chơi AI\u0026rdquo; Video tham khảo: https://www.youtube.com/watch?v=oCdrHlM5TNs A full-figure action figure of a [giới tính - woman/man/person] displayed in its original blister pack packaging. 3D toy style. On the top packaging card, the name \u0026#39;[TÊN_NGƯỜI_DÙNG]\u0026#39; is written prominently, with the role \u0026#39;[NGHỀ_NGHIỆP]\u0026#39; written below it. The figure represents [TÊN_NGƯỜI_DÙNG] and is wearing [mô tả trang phục phù hợp với nghề nghiệp]. Inside the blister pack, next to the figure, are the following accessories: [liệt kê các phụ kiện liên quan đến nghề nghiệp]. The packaging card has a [mô tả phong cách thiết kế bao bì, màu sắc, hình ảnh]. Tạo ảnh thì mình sẽ dùng ChatGPT, còn đoạn văn miêu tả thì mình qua hỏi Grok 3 nhờ giúp\nSau khi đó mình đã có hỏi grok, thì mình có format này và nhờ nó phiên dịch thành tiếng anh.\nHình 1 và Hình 2 là do ChatGPT tạo.\nGiới tính: Man (Nam). Tên người dùng: Vincent Lin. Nghề nghiệp: R\u0026amp;D Executive. Mô tả trang phục: Mặc áo dài tay Cotton in chữ \u0026#34;IoT/Hardware\u0026#34;, quần kaki xám, và giày thể thao đen. Phụ kiện: Một chiếc laptop, PC Workstation, một đồng hồ vạn năng, một hardware hacking toolkit, bản mạch điện tử, một camera an ninh, router, thiết bị GPS, và các loại dây cáp. Phong cách thiết kế bao bì: Bao bì màu đen và xanh neon, với hình ảnh các dòng code nhị phân (0 và 1) làm nền. Đoạn văn sau khi nhờ grok dịch:\nA full-figure action figure of a man displayed in its original blister pack packaging. 3D toy style. On the top packaging card, the name \u0026lsquo;Vincent Lin\u0026rsquo; is written prominently, with the role \u0026lsquo;R\u0026amp;D Specialist\u0026rsquo; written below it. The figure represents Vincent Lin and is wearing a long-sleeve cotton shirt with \u0026lsquo;IoT/Hardware\u0026rsquo; text, grey khaki pants, and black sneakers. Inside the blister pack, next to the figure, are the following accessories: a laptop, a PC Workstation, a multimeter, a hardware hacking toolkit, electronic circuit boards, a security camera, a router, and various cables. The packaging card has a black and neon green design with a background of binary code (0s and 1s). Hình 2 là mình thấy ưng ý nhất.\nMình cũng thử nhờ grok tạo ảnh (như hình 3 và hình 4), mà thấy ảnh nhìn kỳ quá, không hợp.\nHình 3: Hình 4: Note: Dùng bản free trên ChatGPT và Grok 3 thì bị giới hạn về số lần tạo ảnh trong ngày.\n👉 Ngoài ra còn có trend Tạo mô hình 3D thu nhỏ nữa. =]]\n",
      "content_html": "\u003ch2 id=\"trend-hộp-đồ-chơi-ai\"\u003eTrend \u0026ldquo;Hộp đồ chơi AI\u0026rdquo;\u003c/h2\u003e\n\u003ch3 id=\"video-tham-khảo-httpswwwyoutubecomwatchvocdrhlm5tns\"\u003eVideo tham khảo: \u003ca href=\"https://www.youtube.com/watch?v=oCdrHlM5TNs\"\u003ehttps://www.youtube.com/watch?v=oCdrHlM5TNs\u003c/a\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eA full-figure action figure of a [giới tính - woman/man/person] displayed in its original blister pack packaging. 3D toy style. On the top packaging card, the name \u0026#39;[TÊN_NGƯỜI_DÙNG]\u0026#39; is written prominently, with the role \u0026#39;[NGHỀ_NGHIỆP]\u0026#39; written below it. The figure represents [TÊN_NGƯỜI_DÙNG] and is wearing [mô tả trang phục phù hợp với nghề nghiệp]. Inside the blister pack, next to the figure, are the following accessories: [liệt kê các phụ kiện liên quan đến nghề nghiệp]. The packaging card has a [mô tả phong cách thiết kế bao bì, màu sắc, hình ảnh].\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTạo ảnh thì mình sẽ dùng \u003cstrong\u003eChatGPT\u003c/strong\u003e, còn đoạn văn miêu tả thì mình qua hỏi \u003cstrong\u003eGrok 3\u003c/strong\u003e nhờ giúp\u003c/p\u003e\n\u003cp\u003eSau khi đó mình đã có hỏi grok, thì mình có format này và nhờ nó phiên dịch thành tiếng anh.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHình 1\u003c/strong\u003e và \u003cstrong\u003eHình 2\u003c/strong\u003e là do ChatGPT tạo.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Hop_do_choi_AI/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eGiới tính: Man (Nam).\n\nTên người dùng: Vincent Lin.\n\nNghề nghiệp: R\u0026amp;D Executive.\n\nMô tả trang phục: Mặc áo dài tay Cotton in chữ \u0026#34;IoT/Hardware\u0026#34;, quần kaki xám, và giày thể thao đen.\n\nPhụ kiện: Một chiếc laptop, PC Workstation, một đồng hồ vạn năng, một hardware hacking toolkit, bản mạch điện tử, một camera an ninh, router, thiết bị GPS, và các loại dây cáp.\n\nPhong cách thiết kế bao bì: Bao bì màu đen và xanh neon, với hình ảnh các dòng code nhị phân (0 và 1) làm nền.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eĐoạn văn sau khi nhờ grok dịch:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA full-figure action figure of a man displayed in its original blister pack packaging. 3D toy style. On the top packaging card, the name \u0026lsquo;Vincent Lin\u0026rsquo; is written prominently, with the role \u0026lsquo;R\u0026amp;D Specialist\u0026rsquo; written below it. The figure represents Vincent Lin and is wearing a long-sleeve cotton shirt with \u0026lsquo;IoT/Hardware\u0026rsquo; text, grey khaki pants, and black sneakers. Inside the blister pack, next to the figure, are the following accessories: a laptop, a PC Workstation, a multimeter, a hardware hacking toolkit, electronic circuit boards, a security camera, a router, and various cables. The packaging card has a black and neon green design with a background of binary code (0s and 1s). \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eHình 2\u003c/strong\u003e là mình thấy ưng ý nhất.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/Hop_do_choi_AI/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMình cũng thử nhờ grok tạo ảnh \u003cem\u003e(như \u003cstrong\u003ehình 3\u003c/strong\u003e và \u003cstrong\u003ehình 4\u003c/strong\u003e)\u003c/em\u003e, mà thấy ảnh nhìn kỳ quá, không hợp.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHình 3:\n\u003cimg\n  src=\"/image/Others/Hop_do_choi_AI/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHình 4:\n\u003cimg\n  src=\"/image/Others/Hop_do_choi_AI/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: Dùng bản free trên ChatGPT và Grok 3 thì bị giới hạn về số lần tạo ảnh trong ngày.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e👉 Ngoài ra còn có trend \u003ca href=\"https://quantrimang.com/cach-tao-nha-bup-be-voi-chatgpt-tao-mo-hinh-3d-thu-nho-voi-chatgpt-208379\"\u003eTạo mô hình 3D thu nhỏ\u003c/a\u003e nữa. =]]\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/hop_do_choi_ai/",
      "date_published": "5046-05-09T49:55:00+07:00",
      "date_modified": "5046-05-09T49:55:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "6f64022fc318c36de669f016d8b1302ffbb711c5",
      "title": "Web_Crawler",
      "summary": "",
      "content_text": "Changelog 9/3/2025: Khởi tạo bài viết Ghi chú về Web Crawler 12/3/2025: Bổ sung một công cụ AI Crawler Web crawler (hay còn gọi là web spider, bot, hoặc crawler) là một chương trình hoặc phần mềm tự động được thiết kế để duyệt qua các trang web trên internet, thu thập thông tin và lập chỉ mục dữ liệu từ các trang đó. Web crawler hoạt động bằng cách truy cập một trang web, đọc nội dung, tìm các liên kết (link) trên trang, sau đó tiếp tục truy cập các liên kết đó để khám phá thêm các trang khác. Quá trình này thường được thực hiện một cách có hệ thống và liên tục.\nMục đích của Web Crawler Công cụ tìm kiếm: Các crawler như Googlebot (của Google) thu thập dữ liệu từ hàng tỷ trang web để lập chỉ mục, giúp người dùng tìm kiếm thông tin dễ dàng. Thu thập dữ liệu (Web Scraping): Lấy thông tin cụ thể như giá sản phẩm, bài viết, hoặc dữ liệu nghiên cứu. Giám sát web: Kiểm tra cập nhật nội dung, phát hiện lỗi liên kết, hoặc theo dõi thay đổi trên các trang. Phân tích dữ liệu: Thu thập dữ liệu lớn (big data) để phân tích xu hướng, thị trường, hoặc hành vi người dùng. So sánh giữa Web Crawling và Web Scraping Công cụ Firecrawl Đây là một công cụ mã nguồn mở, có thể vào cả việc crawl và scraping. Theo tài liệu thì công cụ này có thể selft-hosted hoặc đăng ký sử dụng free API (bị giới hạn crawl khoảng 500 trang web và một số tính năng khác). Tính năng nổi bật của Firecrawl: Xử lý nội dung động: Nếu website dùng JavaScript (ví dụ: SPA - Single Page Application), Firecrawl tự động render và lấy dữ liệu Đầu ra sạch: Dữ liệu được loại bỏ quảng cáo, menu, footer Crawl tự động: Chỉ cần đưa URL gốc, Firecrawl sẽ tự tìm và crawl tất cả subpages mà không cần sitemap. Xác định nhu cầu khi sử dụng Firecrawl Muốn crawl toàn bộ website hay chỉ scrape một vài trang ?\nCrawl: Lấy toàn bộ nội dung từ một domain (ví dụ: tất cả bài viết trên một blog).\nScrape: Lấy dữ liệu cụ thể từ một hoặc vài trang (ví dụ: giá sản phẩm từ trang chi tiết).\nDữ liệu đầu ra cần định dạng gì ?\nMarkdown: Phù hợp để dùng trực tiếp cho LLM (cho việc huấn luyện AI).\nJSON: Dữ liệu có cấu trúc (structured data) như danh sách sản phẩm, bài viết, v.v.\nCập nhật: 12/3/2025 AI Web Scraper: Thunderbit Tham khảo video: Cào Mọi Thông Tin trên Website chỉ 2 Click bằng AI - Không code - Thunderbit công cụ này mình có thể cài đặt, hoặc add thêm extension cho Chrome. Mình xem video thì thấy công cụ này khá hay, dùng cho những người không chuyên quá nhiều về kỹ thuật. Xem pricing thì bản free chỉ cho phép cào tối đa 6 trang web trong tháng. ",
      "content_html": "\u003ch3 id=\"changelog\"\u003eChangelog\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e9/3/2025: Khởi tạo bài viết Ghi chú về Web Crawler\n12/3/2025: Bổ sung một công cụ AI Crawler\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003eWeb crawler (hay còn gọi là web spider, bot, hoặc crawler) là một chương trình hoặc phần mềm tự động được thiết kế để duyệt qua các trang web trên internet, thu thập thông tin và lập chỉ mục dữ liệu từ các trang đó. Web crawler hoạt động bằng cách truy cập một trang web, đọc nội dung, tìm các liên kết (link) trên trang, sau đó tiếp tục truy cập các liên kết đó để khám phá thêm các trang khác. \u003c/br\u003e\nQuá trình này thường được thực hiện một cách có hệ thống và liên tục.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"mục-đích-của-web-crawler\"\u003eMục đích của Web Crawler\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCông cụ tìm kiếm:\u003c/strong\u003e Các crawler như Googlebot (của Google) thu thập dữ liệu từ hàng tỷ trang web để lập chỉ mục, giúp người dùng tìm kiếm thông tin dễ dàng.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eThu thập dữ liệu (Web Scraping):\u003c/strong\u003e Lấy thông tin cụ thể như giá sản phẩm, bài viết, hoặc dữ liệu nghiên cứu.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGiám sát web:\u003c/strong\u003e Kiểm tra cập nhật nội dung, phát hiện lỗi liên kết, hoặc theo dõi thay đổi trên các trang.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePhân tích dữ liệu:\u003c/strong\u003e Thu thập dữ liệu lớn (big data) để phân tích xu hướng, thị trường, hoặc hành vi người dùng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"so-sánh-giữa-web-crawling-và-web-scrapinghttpsvietnixvncrawler-la-giso-sanh-giua-web-crawling-va-web-scraping\"\u003e\u003ca href=\"https://vietnix.vn/crawler-la-gi/#so-sanh-giua-web-crawling-va-web-scraping\"\u003eSo sánh giữa Web Crawling và Web Scraping\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Web_Crawler/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Web_Crawler/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"công-cụ-firecrawlhttpsgithubcommendableaifirecrawl\"\u003eCông cụ \u003ca href=\"https://github.com/mendableai/firecrawl\"\u003eFirecrawl\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ mã nguồn mở, có thể vào cả việc \u003cstrong\u003ecrawl\u003c/strong\u003e và \u003cstrong\u003escraping\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTheo tài liệu thì công cụ này có thể \u003cstrong\u003eselft-hosted\u003c/strong\u003e hoặc đăng ký sử dụng free API \u003cem\u003e(bị giới hạn crawl khoảng 500 trang web và một số tính năng khác)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eTính năng nổi bật của Firecrawl:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eXử lý nội dung động:\u003c/strong\u003e Nếu website dùng JavaScript (ví dụ: SPA - Single Page Application), Firecrawl tự động render và lấy dữ liệu\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eĐầu ra sạch:\u003c/strong\u003e Dữ liệu được loại bỏ quảng cáo, menu, footer\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCrawl tự động:\u003c/strong\u003e Chỉ cần đưa URL gốc, Firecrawl sẽ tự tìm và crawl tất cả subpages mà không cần sitemap.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"xác-định-nhu-cầu-khi-sử-dụng-firecrawl\"\u003eXác định nhu cầu khi sử dụng Firecrawl\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eMuốn crawl toàn bộ website hay chỉ scrape một vài trang ?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCrawl:\u003c/strong\u003e Lấy toàn bộ nội dung từ một domain (ví dụ: tất cả bài viết trên một blog).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eScrape:\u003c/strong\u003e Lấy dữ liệu cụ thể từ một hoặc vài trang (ví dụ: giá sản phẩm từ trang chi tiết).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eDữ liệu đầu ra cần định dạng gì ?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eMarkdown:\u003c/strong\u003e Phù hợp để dùng trực tiếp cho LLM \u003cem\u003e(cho việc huấn luyện AI)\u003c/em\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eJSON:\u003c/strong\u003e Dữ liệu có cấu trúc (structured data) như danh sách sản phẩm, bài viết, v.v.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-1232025\"\u003eCập nhật: \u003ccode\u003e12/3/2025\u003c/code\u003e\u003c/h2\u003e\n\u003ch3 id=\"ai-web-scraper-thunderbithttpsthunderbitcom\"\u003eAI Web Scraper: \u003ca href=\"https://thunderbit.com/\"\u003eThunderbit\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTham khảo video: \u003ca href=\"https://www.youtube.com/watch?v=qUTGm_uneLU\u0026amp;list=WL\u0026amp;index=2\"\u003eCào Mọi Thông Tin trên Website chỉ 2 Click bằng AI - Không code - Thunderbit\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ecông cụ này mình có thể cài đặt, hoặc \u003cstrong\u003eadd thêm extension cho Chrome\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình xem video thì thấy công cụ này khá hay, dùng cho những người không chuyên quá nhiều về kỹ thuật.\u003c/li\u003e\n\u003cli\u003eXem \u003ca href=\"https://thunderbit.com/pricing\"\u003epricing\u003c/a\u003e thì bản free chỉ cho phép cào tối đa 6 trang web trong tháng.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/web_crawler/",
      "date_published": "12036-12-09T316:1212:00+07:00",
      "date_modified": "12036-12-09T316:1212:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "216ffb76e0e57ede5a5dec0c8349503645fc1496",
      "title": "USB_Boot",
      "summary": "",
      "content_text": "Trong quá trình sử dụng Windows (hoặc đối với một người IT Support) thì việc xử lý lỗi về máy tính là rất cần thiết.\nVề phần mềm hoặc OS thì việc tạo một USB-Boot (hay USB cứu hộ) là vô cùng quan trọng.\nSẵn việc tìm hiểu lại cách tạo USB-Boot (do cần phải sửa lỗi máy tính), nên mình sẽ documents lại những gì mình đã tìm hiểu được.\nDownload Win10 (ISO File) Theo các trang thao khảo thì hiện tại Win 10 không cho tải trực tiếp file ISO trên PC, mà chỉ có thể tải trên điện thoai. Nên mình sẽ cần thực hiện một số thủ thuật để có thể tải file ISO; tham khảo Truy cập đường dẫn đến trang chủ Windows 10, download ISO Mình thiết lập là Safari - iPad, lúc này chọn tiếp theo hướng dẫn. Mình đã có thể download được file ISO. WinAIO Maker Professional Đây là phần mềm giúp mình gộp hoặc lựa chọn nhiều file ISO Win vào một file ISO duy nhất. Download phần mềm, taimienphi Tài liệu: https://www.youtube.com/watch?v=PvS7AaxA4PY\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=2 https://blogchiasekienthuc.com/thu-thuat-may-tinh/cach-tao-bo-cai-windows-aio.html AnhDV Boot Download Anhdv Boot Sử dụng bản free Pass: anhdvboot.com Đây là một phần mềm cứu hộ máy tính, được rất nhiều người tin dùng. Khi đã giải nén xong, mình chạy file _One_Click_USB_HDD_Anhdv_Boot.bat dưới quyền Admin để thực hiện tạo USB-Boot. Khi tạo xong mình sẽ có 2 phân vùng: Phân vùng Boot (đình dạng FAT32) Phân vùng DATA (định dạng NTFS): Phân vùng này là để chép các file ISO (nhờ có định dạng NTFS nên mới có thể chép các file có dung lượng lớn) Tài liệu: https://anh-dv.com/winpe/tao-usb-boot-uefi-legacy-cuu-ho-may-tinh-chuyen https://www.youtube.com/watch?v=l-ZzuBV-HKg\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=3\u0026amp;pp=gAQBiAQB https://www.youtube.com/watch?v=A2zYziFCgf0\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=4\u0026amp;pp=gAQBiAQB https://www.youtube.com/watch?v=g2tDjh7v-Ok\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=6\u0026amp;pp=gAQBiAQB QemuBootTester Sau khi tạo xong USB Boot thì mình có thể dùng phần mềm này để test USB-Boot. Tham khảo tài liệu: https://www.phukienusb.com/2021/03/download-phan-mem-test-kha-nang-boot-tu.html https://quantrimang.com/cong-nghe/lam-the-nao-de-kiem-tra-usb-boot-da-duoc-tao-thanh-cong-hay-chua-133082#google_vignette Tài liệu tham khảo khác: Phím tắt vào BIOS và Boot Options của các hãng máy tính Tổng hợp những lỗi cài đặt windows (lỗi cài Win) và cách khắc phục ",
      "content_html": "\u003cp\u003eTrong quá trình sử dụng Windows (hoặc đối với một người IT Support) thì việc xử lý lỗi về máy tính là rất cần thiết.\u003c/p\u003e\n\u003cp\u003eVề phần mềm hoặc OS thì việc tạo một USB-Boot \u003cem\u003e(hay USB cứu hộ)\u003c/em\u003e là vô cùng quan trọng.\u003c/p\u003e\n\u003cp\u003eSẵn việc tìm hiểu lại cách tạo USB-Boot \u003cem\u003e(do cần phải sửa lỗi máy tính)\u003c/em\u003e, nên mình sẽ documents lại những gì mình đã tìm hiểu được.\u003c/p\u003e\n\u003ch3 id=\"download-win10-iso-file\"\u003eDownload Win10 \u003cem\u003e(ISO File)\u003c/em\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo các trang thao khảo thì hiện tại Win 10 không cho tải trực tiếp file ISO trên PC, mà chỉ có thể tải trên điện thoai.\u003c/li\u003e\n\u003cli\u003eNên mình sẽ cần thực hiện một số thủ thuật để có thể tải file ISO; \u003ca href=\"https://www.anphatpc.com.vn/tai-windows-10-file-iso-sach-nguyen-goc-nhanh-muot.html\"\u003etham khảo\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTruy cập đường dẫn đến trang chủ Windows 10, \u003ca href=\"https://www.microsoft.com/en-au/software-download/windows10\"\u003edownload ISO\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/USB_Boot/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMình thiết lập là \u003cstrong\u003eSafari - iPad\u003c/strong\u003e, lúc này chọn tiếp theo hướng dẫn.\u003c/li\u003e\n\u003cli\u003eMình đã có thể download được file ISO.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"winaio-maker-professional\"\u003eWinAIO Maker Professional\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là phần mềm giúp mình \u003cstrong\u003egộp hoặc lựa chọn nhiều file ISO Win\u003c/strong\u003e vào một file ISO duy nhất.\u003c/li\u003e\n\u003cli\u003eDownload phần mềm, \u003ca href=\"https://taimienphi.vn/download-winaio-maker-professional-16781/taive\"\u003etaimienphi\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=PvS7AaxA4PY\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=2\nhttps://blogchiasekienthuc.com/thu-thuat-may-tinh/cach-tao-bo-cai-windows-aio.html\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"anhdv-boothttpsanhdvbootcom\"\u003e\u003ca href=\"https://anhdvboot.com/\"\u003eAnhDV Boot\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDownload \u003ca href=\"https://anhdvboot.com/tai-ve/\"\u003eAnhdv Boot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSử dụng bản free\nPass: anhdvboot.com\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐây là một \u003cstrong\u003ephần mềm cứu hộ máy tính\u003c/strong\u003e, được rất nhiều người tin dùng.\u003c/li\u003e\n\u003cli\u003eKhi đã giải nén xong, mình chạy file \u003ccode\u003e_One_Click_USB_HDD_Anhdv_Boot.bat\u003c/code\u003e dưới quyền \u003cstrong\u003eAdmin\u003c/strong\u003e để thực hiện tạo USB-Boot.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/USB_Boot/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKhi tạo xong mình sẽ có 2 phân vùng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePhân vùng Boot (đình dạng FAT32)\nPhân vùng DATA (định dạng NTFS): Phân vùng này là để chép các file ISO (nhờ có định dạng NTFS nên mới có thể chép các file có dung lượng lớn)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://anh-dv.com/winpe/tao-usb-boot-uefi-legacy-cuu-ho-may-tinh-chuyen\nhttps://www.youtube.com/watch?v=l-ZzuBV-HKg\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=3\u0026amp;pp=gAQBiAQB\nhttps://www.youtube.com/watch?v=A2zYziFCgf0\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=4\u0026amp;pp=gAQBiAQB\nhttps://www.youtube.com/watch?v=g2tDjh7v-Ok\u0026amp;list=PL7Gq3F-DZa6mb_RutcFzSVQhYvi1QAxiZ\u0026amp;index=6\u0026amp;pp=gAQBiAQB\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"qemuboottester\"\u003eQemuBootTester\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi tạo xong USB Boot thì mình có thể dùng phần mềm này để test USB-Boot.\u003c/li\u003e\n\u003cli\u003eTham khảo tài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.phukienusb.com/2021/03/download-phan-mem-test-kha-nang-boot-tu.html\nhttps://quantrimang.com/cong-nghe/lam-the-nao-de-kiem-tra-usb-boot-da-duoc-tao-thanh-cong-hay-chua-133082#google_vignette\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"tài-liệu-tham-khảo-khác\"\u003eTài liệu tham khảo khác:\u003c/h2\u003e\n\u003ch3 id=\"phím-tắt-vào-bios-và-boot-options-của-các-hãng-máy-tínhhttpsanh-dvcomthu-thuat-hayphim-tat-vao-bios-va-boot-options-cac-hang-may-tinh\"\u003e\u003ca href=\"https://anh-dv.com/thu-thuat-hay/phim-tat-vao-bios-va-boot-options-cac-hang-may-tinh\"\u003ePhím tắt vào BIOS và Boot Options của các hãng máy tính\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-những-lỗi-cài-đặt-windows-lỗi-cài-win-và-cách-khắc-phụchttpsanh-dvcomos-windowsloi-cai-dat-windows-va-cach-khac-phuc\"\u003e\u003ca href=\"https://anh-dv.com/os-windows/loi-cai-dat-windows-va-cach-khac-phuc\"\u003eTổng hợp những lỗi cài đặt windows (lỗi cài Win) và cách khắc phục\u003c/a\u003e\u003c/h3\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/usb_boot/",
      "date_published": "11036-11-09T311:1111:00+07:00",
      "date_modified": "11036-11-09T311:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "aa015b2ad8757648a3b4ba49c0bf5631a9164c5e",
      "title": "Backup_Tools",
      "summary": "",
      "content_text": "Đây sẽ là những công cụ giúp mình backup dữ liệu, có thể lưu trên NAS, Cloud,\u0026hellip;\nCác công cụ này có thể cài đặt trên máy tính cá nhân, hoặc server để backup dữ liệu.\nMình thấy giống như việc mình có một tài khoản Google-Drive (lúc này mình có khoảng 15GB lưu trữ).\nNếu mình không muốn cứ phải thực hiện sao lưu thủ công, thì mình có thể cài đặt phần mềm Google Drive for Desktop để thực hiện backup (sao lưu) và sync (đồng bộ hóa) thư mục.\nTương tự như vậy, mình có NAS (OMV) là nơi lưu trữ, bây giờ mình muốn có một tool để tự động thực hiện sao lưu thì có thể dùng Kopia hoặc Duplicati.\n(Kopia hay Duplicati là công cụ sao lưu (backup) thôi, chứ không phải đồng bộ hóa (sync). Thuật ngữ backup và sync mang ý nghĩa khác nhau).\nKopia Kopia là một công cụ sao lưu (backup tool) mã nguồn mở, được thiết kế để sao lưu và khôi phục dữ liệu từ nhiều nguồn khác nhau (máy tính, máy chủ, đám mây). Chức năng chính: Sao lưu dữ liệu: Kopia có thể sao lưu tệp từ máy tính cá nhân hoặc máy chủ lên nhiều đích đến như ổ cứng cục bộ, NAS, hoặc dịch vụ đám mây (Google Drive, Amazon S3, Backblaze, v.v.). Nén và mã hóa: Dữ liệu được nén để tiết kiệm dung lượng và mã hóa để bảo mật. Tăng tốc độ: Kopia nổi bật với tốc độ sao lưu nhanh nhờ cơ chế xử lý song song và chống trùng lặp dữ liệu (deduplication). Snapshot: Hỗ trợ tạo snapshot (ảnh chụp dữ liệu tại thời điểm cụ thể) để khôi phục phiên bản cũ của tệp. Tài liệu tham khảo: https://voz.vn/t/kopia-cong-cu-backup-du-lieu-ma-nguon-mo.993353/ https://www.youtube.com/watch?v=a6GfQy9wZfA\u0026amp;list=WL\u0026amp;index=4 Duplicati Youtube: Backup in Linux Servers - Docker Volumes, and Databases Theo như video, thì ở đây sử dụng một open-source tên là duplicati Documents của Duplicati Cài đặt Duplicati bằng Docker linuxserver/duplicati duplicati-tutorial Script thực hiện việc auto-backup Tham khảo khác So sánh Kopia và Duplicati Kopia: Tập trung vào hiệu suất và chống trùng lặp dữ liệu mạnh mẽ, nhưng thiếu hỗ trợ VSS, giới hạn khả năng sao lưu tệp đang sử dụng trên Windows. Duplicati: Hỗ trợ VSS (Volume Shadow Copy Service) trên Windows, cho phép sao lưu dữ liệu đang mở (như Outlook PST), và có danh sách đích đến đám mây rộng hơn. Chọn Kopia nếu: Bạn cần sao lưu nhanh, hiệu suất cao với dữ liệu lớn. Bạn không cần sao lưu tệp đang sử dụng trên Windows (VSS). Bạn thoải mái với CLI hoặc cần công cụ nhẹ cho máy chủ. Ví dụ: Sao lưu máy chủ Linux, NAS, hoặc dữ liệu không thay đổi thường xuyên. Chọn Duplicati nếu: Bạn muốn giao diện dễ dùng và không cần nhiều kiến thức kỹ thuật. Bạn cần sao lưu tệp đang sử dụng trên Windows (như Outlook, cơ sở dữ liệu). Bạn muốn tích hợp với nhiều dịch vụ đám mây phổ biến. Ví dụ: Sao lưu máy tính cá nhân, dữ liệu đám mây cho gia đình. ",
      "content_html": "\u003cp\u003eĐây sẽ là những công cụ giúp mình backup dữ liệu, có thể lưu trên NAS, Cloud,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eCác công cụ này có thể cài đặt trên máy tính cá nhân, hoặc server để backup dữ liệu.\u003c/p\u003e\n\u003cp\u003eMình thấy giống như việc mình có một tài khoản Google-Drive \u003cem\u003e(lúc này mình có khoảng 15GB lưu trữ)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eNếu mình không muốn cứ phải thực hiện sao lưu thủ công, thì mình có thể cài đặt phần mềm \u003cstrong\u003eGoogle Drive for Desktop\u003c/strong\u003e để thực hiện \u003cstrong\u003ebackup (sao lưu) và sync (đồng bộ hóa)\u003c/strong\u003e thư mục.\u003c/p\u003e\n\u003cp\u003eTương tự như vậy, mình có NAS (OMV) là nơi lưu trữ, bây giờ mình muốn có một tool để tự động thực hiện \u003cstrong\u003esao lưu\u003c/strong\u003e thì có thể dùng \u003cstrong\u003eKopia\u003c/strong\u003e hoặc \u003cstrong\u003eDuplicati\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e(Kopia hay Duplicati là công cụ sao lưu (backup) thôi, chứ không phải đồng bộ hóa (sync). Thuật ngữ backup và sync mang ý nghĩa khác nhau)\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"kopiahttpsgithubcomkopiakopia\"\u003e\u003ca href=\"https://github.com/kopia/kopia\"\u003eKopia\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eKopia là một \u003cstrong\u003ecông cụ sao lưu (backup tool) mã nguồn mở\u003c/strong\u003e, được thiết kế để sao lưu và khôi phục dữ liệu từ nhiều nguồn khác nhau (máy tính, máy chủ, đám mây).\u003c/li\u003e\n\u003cli\u003eChức năng chính:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSao lưu dữ liệu:\u003c/strong\u003e Kopia có thể sao lưu tệp từ máy tính cá nhân hoặc máy chủ lên nhiều đích đến như ổ cứng cục bộ, NAS, hoặc dịch vụ đám mây (Google Drive, Amazon S3, Backblaze, v.v.).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNén và mã hóa:\u003c/strong\u003e Dữ liệu được nén để tiết kiệm dung lượng và mã hóa để bảo mật.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTăng tốc độ:\u003c/strong\u003e Kopia nổi bật với tốc độ sao lưu nhanh nhờ cơ chế xử lý song song và chống trùng lặp dữ liệu (deduplication).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSnapshot:\u003c/strong\u003e Hỗ trợ tạo snapshot (ảnh chụp dữ liệu tại thời điểm cụ thể) để khôi phục phiên bản cũ của tệp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTài liệu tham khảo:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://voz.vn/t/kopia-cong-cu-backup-du-lieu-ma-nguon-mo.993353/\nhttps://www.youtube.com/watch?v=a6GfQy9wZfA\u0026amp;list=WL\u0026amp;index=4\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"duplicati\"\u003eDuplicati\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=JoA6Bezgk1c\u0026amp;list=WL\u0026amp;index=107\"\u003eYoutube: Backup in Linux Servers - Docker Volumes, and Databases\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTheo như video, thì ở đây sử dụng một open-source tên là \u003ca href=\"https://www.duplicati.com/download\"\u003eduplicati\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://duplicati.readthedocs.io/en/latest/01-introduction/\"\u003eDocuments của Duplicati\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"cài-đặt-duplicati-bằng-docker\"\u003eCài đặt Duplicati bằng Docker\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.linuxserver.io/images/docker-duplicati\"\u003elinuxserver/duplicati\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/christianlempa/videos/tree/main/duplicati-tutorial\"\u003eduplicati-tutorial\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"script-thực-hiện-việc-auto-backuphttpsgithubcomchristianlempascriptstreemaindb-container-backup\"\u003e\u003ca href=\"https://github.com/ChristianLempa/scripts/tree/main/db-container-backup\"\u003eScript thực hiện việc auto-backup\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=wvsi3QilNQ8\"\u003eTham khảo khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"so-sánh-kopia-và-duplicati\"\u003eSo sánh Kopia và Duplicati\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Backup_Tools/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKopia: Tập trung vào hiệu suất và chống trùng lặp dữ liệu mạnh mẽ, nhưng thiếu hỗ trợ VSS, giới hạn khả năng sao lưu tệp đang sử dụng trên Windows.\u003c/li\u003e\n\u003cli\u003eDuplicati: Hỗ trợ VSS (Volume Shadow Copy Service) trên Windows, cho phép sao lưu dữ liệu đang mở (như Outlook PST), và có danh sách đích đến đám mây rộng hơn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Backup_Tools/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChọn Kopia nếu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eBạn cần sao lưu nhanh, hiệu suất cao với dữ liệu lớn.\nBạn không cần sao lưu tệp đang sử dụng trên Windows (VSS).\nBạn thoải mái với CLI hoặc cần công cụ nhẹ cho máy chủ.\nVí dụ: Sao lưu máy chủ Linux, NAS, hoặc dữ liệu không thay đổi thường xuyên.\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eChọn Duplicati nếu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eBạn muốn giao diện dễ dùng và không cần nhiều kiến thức kỹ thuật.\nBạn cần sao lưu tệp đang sử dụng trên Windows (như Outlook, cơ sở dữ liệu).\nBạn muốn tích hợp với nhiều dịch vụ đám mây phổ biến.\nVí dụ: Sao lưu máy tính cá nhân, dữ liệu đám mây cho gia đình.\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/system-devops/backup_tools/",
      "date_published": "11036-11-09T38:1111:00+07:00",
      "date_modified": "11036-11-09T38:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "23c06c85c6412d587b545bb756a83d0054681b2b",
      "title": "Desktop_App",
      "summary": "",
      "content_text": "Changelog: 18/1/2025: Khởi tạo bài viết về Desktop App 9/3/2025: Cập nhật thông tin về Slint GUI toolkit Trong việc viết một desktop app thì có rất nhiều xu hướng, có thể dùng C#, C++ hoặc Rust.\nMình có tham khảo về việc dùng Rust để viết Desktop App. Rust Desktop app docs Framework mình tham khảo là Tauri:\nhttps://tauri.app/ https://www.twilio.com/en-us/blog/build-a-cross-platform-desktop-application-with-rust-using-tauri https://v1.tauri.app/v1/guides/getting-started/setup/ Tuy nhiên có thể mình sẽ chọn C++ để viết app. Lý do:\nThứ 1: Mình không muốn quên đi cách dùng ngôn ngữ C++ (nếu lâu quá không dùng thì sẽ dẫn đến quên). Thứ 2: Mình đã có khoảng thời gian gần 1 tháng tìm hiểu về một công cụ tên là C++ Builder, mình thấy công cụ này khá hay, và đáp ứng đc lý do thứ 1. (Ngoài ra mình cũng không muốn lãng phí 1 tháng đó. =]]). C++ Builder: https://blogs.embarcadero.com/everything-you-need-to-create-windows-apps-with-c/ https://devblogs.microsoft.com/cppblog/windows-desktop-development-with-c-in-visual-studio/ Theo mình tìm hiểu thì công cụ C++ Builder giúp mình có thể phát triển nhanh một app dành cho Windows. Công cụ này hỗ trợ gần như tận răng cho developer. C++ Builder đại đa số các extension của nó đều trả phí, tất nhiên vẫn có free, tuy nhiên việc code sẽ khó khăn hơn. Mình thấy các app dành cho Windows sẽ vẫn có một vị trí nhất định, và mình đã thấy các ứng dụng IoT cho desktop app được ứng dụng trong đời sống. Ứng dụng giữ xe thông minh. Một app chạy trên Windows, kết nối với thiết bị đọc RFID, Camera,\u0026hellip; Tag thẻ để nhận diện, camera chụp ảnh,\u0026hellip; Ứng dụng quản lý hàng hóa Thiết bị quét mã vạch kết nối với PC, khi quét app sẽ kiểm tra trong database và gửi ra thông tin. Có thể kết hợp với loa thông báo. Cập nhật: 9/3/2025 Slint là một bộ công cụ giao diện người dùng (GUI) khai báo, được thiết kế để xây dựng giao diện người dùng tự nhiên cho các ứng dụng trên nhiều nền tảng khác nhau, bao gồm nhúng, máy tính để bàn và web.\nCác tính năng chính của Slint: Đa ngôn ngữ lập trình: Slint hỗ trợ viết logic ứng dụng bằng Rust, C++, JavaScript và Python, giúp nó linh hoạt cho các nhà phát triển sử dụng ngôn ngữ yêu thích của họ. Nhẹ và hiệu quả: Slint được thiết kế để sử dụng ít tài nguyên, với thời gian chạy chỉ chiếm dưới 300KiB RAM. Đa nền tảng: Nó hỗ trợ nhiều hệ điều hành và kiến trúc bộ vi xử lý, bao gồm Linux, macOS, Windows, WebAssembly, QNX, và thậm chí cả các hệ thống không có hệ điều hành (bare-metal). Ngôn ngữ khai báo: Slint sử dụng một ngôn ngữ đặc thù (Domain Specific Language - DSL) riêng, tương tự như QML hoặc XAML, để mô tả giao diện người dùng. Ứng dụng thực tế Thích hợp cho thiết bị nhúng (ví dụ: HMI cho xe điện của SK Signet), ứng dụng nhẹ, hoặc các dự án cần hỗ trợ đa nền tảng tối ưu. Đang được dùng trong các lĩnh vực như âm thanh (WesAudio), tự động hóa đường sắt (OTIV). Documents: Github Project Supported Boards Demos ",
      "content_html": "\u003ch3 id=\"changelog\"\u003eChangelog:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e18/1/2025: Khởi tạo bài viết về Desktop App\n9/3/2025: Cập nhật thông tin về Slint GUI toolkit\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTrong việc viết một desktop app thì có rất nhiều xu hướng, có thể dùng C#, C++ hoặc Rust.\u003c/p\u003e\n\u003cp\u003eMình có tham khảo về việc dùng Rust để viết Desktop App. \u003ca href=\"https://blog.logrocket.com/build-desktop-app-qt-rust/\"\u003eRust Desktop app docs\u003c/a\u003e\nFramework mình tham khảo là \u003cstrong\u003eTauri\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tauri.app/\nhttps://www.twilio.com/en-us/blog/build-a-cross-platform-desktop-application-with-rust-using-tauri\nhttps://v1.tauri.app/v1/guides/getting-started/setup/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTuy nhiên có thể mình sẽ chọn C++ để viết app. Lý do:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThứ 1: Mình không muốn quên đi cách dùng ngôn ngữ C++ \u003cem\u003e(nếu lâu quá không dùng thì sẽ dẫn đến quên)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eThứ 2: Mình đã có khoảng thời gian gần 1 tháng tìm hiểu về một công cụ tên là \u003cstrong\u003eC++ Builder\u003c/strong\u003e, mình thấy công cụ này khá hay, và đáp ứng đc lý do thứ 1. \u003cem\u003e(Ngoài ra mình cũng không muốn lãng phí 1 tháng đó. =]])\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"c-builder\"\u003eC++ Builder:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://blogs.embarcadero.com/everything-you-need-to-create-windows-apps-with-c/\nhttps://devblogs.microsoft.com/cppblog/windows-desktop-development-with-c-in-visual-studio/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTheo mình tìm hiểu thì công cụ \u003cstrong\u003eC++ Builder\u003c/strong\u003e giúp mình có thể phát triển \u003cstrong\u003enhanh\u003c/strong\u003e một app dành cho Windows. Công cụ này hỗ trợ gần như \u003cstrong\u003etận răng\u003c/strong\u003e cho developer.\u003c/li\u003e\n\u003cli\u003eC++ Builder đại đa số các extension của nó đều \u003cstrong\u003etrả phí\u003c/strong\u003e, tất nhiên vẫn có \u003cstrong\u003efree\u003c/strong\u003e, tuy nhiên việc code sẽ khó khăn hơn.\u003c/li\u003e\n\u003cli\u003eMình thấy các app dành cho Windows sẽ vẫn có một vị trí nhất định, và mình đã thấy các ứng dụng IoT cho desktop app được ứng dụng trong đời sống.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ứng-dụng-giữ-xe-thông-minh\"\u003eỨng dụng giữ xe thông minh.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMột app chạy trên Windows, kết nối với thiết bị đọc RFID, Camera,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eTag thẻ để nhận diện, camera chụp ảnh,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ứng-dụng-quản-lý-hàng-hóa\"\u003eỨng dụng quản lý hàng hóa\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThiết bị quét mã vạch kết nối với PC, khi quét app sẽ kiểm tra trong database và gửi ra thông tin.\u003c/li\u003e\n\u003cli\u003eCó thể kết hợp với loa thông báo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://i0.wp.com/blogs.embarcadero.com/wp-content/uploads/2020/08/jljleH.jpg?resize=512%2C256\u0026amp;ssl=1\"\n  alt=\"C\u0026#43;\u0026#43; Builder\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-932025\"\u003eCập nhật: 9/3/2025\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSlint là một bộ công cụ giao diện người dùng (GUI) khai báo, được thiết kế để xây dựng giao diện người dùng tự nhiên cho các ứng dụng trên nhiều nền tảng khác nhau, bao gồm nhúng, máy tính để bàn và web.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"các-tính-năng-chính-của-slint\"\u003eCác tính năng chính của Slint:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eĐa ngôn ngữ lập trình:\u003c/strong\u003e Slint hỗ trợ viết logic ứng dụng bằng Rust, C++, JavaScript và Python, giúp nó linh hoạt cho các nhà phát triển sử dụng ngôn ngữ yêu thích của họ.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNhẹ và hiệu quả:\u003c/strong\u003e Slint được thiết kế để sử dụng ít tài nguyên, với thời gian chạy chỉ chiếm dưới 300KiB RAM.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eĐa nền tảng:\u003c/strong\u003e Nó hỗ trợ nhiều hệ điều hành và kiến trúc bộ vi xử lý, bao gồm Linux, macOS, Windows, WebAssembly, QNX, và thậm chí cả các hệ thống không có hệ điều hành (bare-metal).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNgôn ngữ khai báo:\u003c/strong\u003e Slint sử dụng một ngôn ngữ đặc thù (Domain Specific Language - DSL) riêng, tương tự như QML hoặc XAML, để mô tả giao diện người dùng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ứng-dụng-thực-tế\"\u003eỨng dụng thực tế\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThích hợp cho \u003cstrong\u003ethiết bị nhúng\u003c/strong\u003e (ví dụ: HMI cho xe điện của SK Signet), ứng dụng nhẹ, hoặc các dự án cần hỗ trợ đa nền tảng tối ưu.\u003c/li\u003e\n\u003cli\u003eĐang được dùng trong các lĩnh vực như âm thanh (WesAudio), tự động hóa đường sắt (OTIV).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"documentshttpsdocsslintdevlatestdocsslint\"\u003e\u003ca href=\"https://docs.slint.dev/latest/docs/slint/\"\u003eDocuments\u003c/a\u003e:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/slint-ui/slint\"\u003eGithub Project\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://slint.dev/supported-boards\"\u003eSupported Boards\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://slint.dev/demos\"\u003eDemos\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/desktop_app/",
      "date_published": "9036-09-09T322:99:00+07:00",
      "date_modified": "9036-09-09T322:99:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "cb39578e8819a8ffc9d0a2d2daf86ad9e4479eea",
      "title": "Thao_tac_An_toan",
      "summary": "",
      "content_text": "Bữa có thấy được một bài đăng của WhiteHat về các thao tác an toàn (cả về network, system, các thiết bị điện khác và vệ sinh chỗ làm).\nLúc trước đó down về mình quên, nay đăng lại về bài viết hay ho này. (Lưu trữ sau này còn biết đường mà đọc lại. =]])\n",
      "content_html": "\u003cp\u003eBữa có thấy được một bài đăng của \u003cstrong\u003eWhiteHat\u003c/strong\u003e về các \u003cstrong\u003ethao tác an toàn\u003c/strong\u003e \u003cem\u003e(cả về network, system, các thiết bị điện khác và vệ sinh chỗ làm)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eLúc trước đó down về mình quên, nay đăng lại về bài viết hay ho này. \u003cem\u003e(Lưu trữ sau này còn biết đường mà đọc lại. =]])\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_0.jpg\"\n  alt=\"Hình 0\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_8.jpg\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_9.jpg\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/Others/An_toan/An_to%c3%a0n_10.jpg\"\n  alt=\"Hình 10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/thao_tac_an_toan/",
      "date_published": "6036-06-09T359:66:00+07:00",
      "date_modified": "6036-06-09T359:66:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "74e24425c046bfd64fae29d02c93e5336606fd9c",
      "title": "Automation_Tools",
      "summary": "",
      "content_text": "Video: I automated EVERYTHING in my HomeLab // Kestra #2\nMình không có nhiều kiến thức về DevOps, nên mình sẽ dùng Grok 3 để phân tích và hỏi thêm về các công cụ Automation.\nĐây là câu trả lời:\nKestra Giới thiệu: Kestra là một công cụ điều phối workflow mã nguồn mở, được thiết kế để quản lý và tự động hóa các quy trình phức tạp. Trong video \u0026ldquo;I automated EVERYTHING in my HomeLab // Kestra #2\u0026rdquo;, tác giả sử dụng Kestra để điều phối các tác vụ như chạy script, quản lý container, và tích hợp hệ thống trong HomeLab. Điểm mạnh: Dễ định nghĩa workflow: Sử dụng YAML để mô tả luồng công việc, đơn giản và dễ đọc. Giao diện web: Có dashboard trực quan để theo dõi tiến trình, rất hữu ích cho việc giám sát trong HomeLab. Tích hợp linh hoạt: Hỗ trợ Docker, Kubernetes, và các công cụ khác, phù hợp với môi trường thử nghiệm. Nhẹ và mới mẻ: Không yêu cầu tài nguyên lớn, lý tưởng cho HomeLab cá nhân. Điểm yếu: Cộng đồng nhỏ: Vì là công cụ mới, tài liệu và hỗ trợ cộng đồng chưa phong phú như Ansible hay Terraform. Không chuyên sâu về cấu hình: Không mạnh trong việc quản lý trạng thái hệ thống như Ansible hay Terraform. Tại sao tác giả chọn Kestra?: Video cho thấy tác giả muốn một giải pháp nhẹ, dễ tùy chỉnh workflows phức tạp (như chạy các tác vụ theo thứ tự), và có giao diện để theo dõi trực tiếp. Kestra tỏ ra phù hợp với phong cách \u0026ldquo;tự động hóa mọi thứ\u0026rdquo; trong một môi trường thử nghiệm sáng tạo. Ansible Giới thiệu: Ansible là công cụ tự động hóa quản lý cấu hình, được sử dụng rộng rãi để triển khai ứng dụng, cấu hình server, và quản lý hệ thống mà không cần cài agent trên máy đích (dùng SSH). Điểm mạnh: Đơn giản và phổ biến: Cú pháp YAML (playbooks) dễ học, cộng đồng lớn với nhiều tài liệu và module sẵn có. Không cần agent: Chỉ cần SSH, phù hợp cho mọi hệ thống từ server lớn đến HomeLab nhỏ. Tự động hóa cơ bản mạnh mẽ: Quản lý cấu hình, cài đặt phần mềm, hoặc chạy script đều rất hiệu quả. Điểm yếu: Hiệu suất: Chậm hơn khi quản lý số lượng máy lớn vì không có cơ chế xử lý song song tối ưu (trừ khi dùng thêm công cụ như Ansible Tower). Không quản lý trạng thái hạ tầng: Không thiết kế để xây dựng hoặc duy trì cơ sở hạ tầng như Terraform. So với Kestra: Ansible tập trung vào tự động hóa tác vụ cụ thể (ví dụ: cài đặt Nginx trên 10 máy), trong khi Kestra thiên về điều phối luồng công việc phức tạp (ví dụ: chạy script A, sau đó kiểm tra kết quả, rồi mới chạy B). Terraform Giới thiệu: Terraform là công cụ \u0026ldquo;Infrastructure as Code\u0026rdquo; (IaC), dùng để xây dựng, quản lý, và duy trì hạ tầng (VM, network, cloud resources) thông qua các file cấu hình (HCL hoặc JSON). Điểm mạnh: Quản lý hạ tầng: Tạo và duy trì trạng thái cơ sở hạ tầng (ví dụ: tạo 5 VM trên AWS rồi gắn IP cố định). Hỗ trợ đa nền tảng: Tích hợp với hầu hết các nhà cung cấp cloud (AWS, GCP, Azure) và cả môi trường on-premise. Tính nhất quán: Đảm bảo hạ tầng luôn đúng với cấu hình đã định nghĩa (idempotency). Điểm yếu: Không phải công cụ điều phối: Không phù hợp cho việc chạy script hoặc quản lý tác vụ hàng ngày như Kestra hay Ansible. Độ phức tạp: Cần hiểu rõ hạ tầng và cú pháp HCL, không thân thiện với người mới bằng Ansible. So với Kestra: Terraform xây dựng \u0026ldquo;nền móng\u0026rdquo; ( hạ tầng), trong khi Kestra quản lý \u0026ldquo;công việc\u0026rdquo; chạy trên nền móng đó. ",
      "content_html": "\u003cp\u003eVideo: \u003ca href=\"https://www.youtube.com/watch?v=PJG1-7hMHsE\u0026amp;list=WL\u0026amp;index=68\u0026amp;t=14s\"\u003eI automated EVERYTHING in my HomeLab // Kestra #2\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMình không có nhiều kiến thức về DevOps, nên mình sẽ dùng \u003cstrong\u003eGrok 3\u003c/strong\u003e để phân tích và hỏi thêm về các công cụ Automation.\u003c/p\u003e\n\u003cp\u003eĐây là câu trả lời:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eKestra\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGiới thiệu: Kestra là một công cụ điều phối workflow mã nguồn mở, được thiết kế để quản lý và tự động hóa các quy trình phức tạp. Trong video \u0026ldquo;I automated EVERYTHING in my HomeLab // Kestra #2\u0026rdquo;, tác giả sử dụng Kestra để điều phối các tác vụ như chạy script, quản lý container, và tích hợp hệ thống trong HomeLab.\u003c/li\u003e\n\u003cli\u003eĐiểm mạnh:\n\u003cul\u003e\n\u003cli\u003eDễ định nghĩa workflow: Sử dụng YAML để mô tả luồng công việc, đơn giản và dễ đọc.\u003c/li\u003e\n\u003cli\u003eGiao diện web: Có dashboard trực quan để theo dõi tiến trình, rất hữu ích cho việc giám sát trong HomeLab.\u003c/li\u003e\n\u003cli\u003eTích hợp linh hoạt: Hỗ trợ Docker, Kubernetes, và các công cụ khác, phù hợp với môi trường thử nghiệm.\u003c/li\u003e\n\u003cli\u003eNhẹ và mới mẻ: Không yêu cầu tài nguyên lớn, lý tưởng cho HomeLab cá nhân.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐiểm yếu:\n\u003cul\u003e\n\u003cli\u003eCộng đồng nhỏ: Vì là công cụ mới, tài liệu và hỗ trợ cộng đồng chưa phong phú như Ansible hay Terraform.\u003c/li\u003e\n\u003cli\u003eKhông chuyên sâu về cấu hình: Không mạnh trong việc quản lý trạng thái hệ thống như Ansible hay Terraform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTại sao tác giả chọn Kestra?: Video cho thấy tác giả muốn một giải pháp nhẹ, dễ tùy chỉnh workflows phức tạp (như chạy các tác vụ theo thứ tự), và có giao diện để theo dõi trực tiếp. Kestra tỏ ra phù hợp với phong cách \u0026ldquo;tự động hóa mọi thứ\u0026rdquo; trong một môi trường thử nghiệm sáng tạo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eAnsible\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGiới thiệu: Ansible là công cụ tự động hóa quản lý cấu hình, được sử dụng rộng rãi để triển khai ứng dụng, cấu hình server, và quản lý hệ thống mà không cần cài agent trên máy đích (dùng SSH).\u003c/li\u003e\n\u003cli\u003eĐiểm mạnh:\n\u003cul\u003e\n\u003cli\u003eĐơn giản và phổ biến: Cú pháp YAML (playbooks) dễ học, cộng đồng lớn với nhiều tài liệu và module sẵn có.\u003c/li\u003e\n\u003cli\u003eKhông cần agent: Chỉ cần SSH, phù hợp cho mọi hệ thống từ server lớn đến HomeLab nhỏ.\u003c/li\u003e\n\u003cli\u003eTự động hóa cơ bản mạnh mẽ: Quản lý cấu hình, cài đặt phần mềm, hoặc chạy script đều rất hiệu quả.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐiểm yếu:\n\u003cul\u003e\n\u003cli\u003eHiệu suất: Chậm hơn khi quản lý số lượng máy lớn vì không có cơ chế xử lý song song tối ưu (trừ khi dùng thêm công cụ như Ansible Tower).\u003c/li\u003e\n\u003cli\u003eKhông quản lý trạng thái hạ tầng: Không thiết kế để xây dựng hoặc duy trì cơ sở hạ tầng như Terraform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSo với Kestra: Ansible tập trung vào tự động hóa tác vụ cụ thể (ví dụ: cài đặt Nginx trên 10 máy), trong khi Kestra thiên về điều phối luồng công việc phức tạp (ví dụ: chạy script A, sau đó kiểm tra kết quả, rồi mới chạy B).\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eTerraform\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eGiới thiệu: Terraform là công cụ \u0026ldquo;Infrastructure as Code\u0026rdquo; (IaC), dùng để xây dựng, quản lý, và duy trì hạ tầng (VM, network, cloud resources) thông qua các file cấu hình (HCL hoặc JSON).\u003c/li\u003e\n\u003cli\u003eĐiểm mạnh:\n\u003cul\u003e\n\u003cli\u003eQuản lý hạ tầng: Tạo và duy trì trạng thái cơ sở hạ tầng (ví dụ: tạo 5 VM trên AWS rồi gắn IP cố định).\u003c/li\u003e\n\u003cli\u003eHỗ trợ đa nền tảng: Tích hợp với hầu hết các nhà cung cấp cloud (AWS, GCP, Azure) và cả môi trường on-premise.\u003c/li\u003e\n\u003cli\u003eTính nhất quán: Đảm bảo hạ tầng luôn đúng với cấu hình đã định nghĩa (idempotency).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐiểm yếu:\n\u003cul\u003e\n\u003cli\u003eKhông phải công cụ điều phối: Không phù hợp cho việc chạy script hoặc quản lý tác vụ hàng ngày như Kestra hay Ansible.\u003c/li\u003e\n\u003cli\u003eĐộ phức tạp: Cần hiểu rõ hạ tầng và cú pháp HCL, không thân thiện với người mới bằng Ansible.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSo với Kestra: Terraform xây dựng \u0026ldquo;nền móng\u0026rdquo; ( hạ tầng), trong khi Kestra quản lý \u0026ldquo;công việc\u0026rdquo; chạy trên nền móng đó.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Automation_Tools/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/automation_tools/",
      "date_published": "26026-26-09T249:2626:00+07:00",
      "date_modified": "26026-26-09T249:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "88771a027c6f045dda8d2e83d986085a46145ef3",
      "title": "Y_tuong_project",
      "summary": "",
      "content_text": "Hiện tại thì bản thân vẫn đang tiếp tục cải thiện project HOMELAB.\nTuy nhiên mình sẽ làm một số project nhỏ hơn, và sẽ xoay quanh Homelab.\n🌱 Ý tưởng bổ sung cho HomeLAB: 👉 Rust Tracking Mình vẫn đang tìm hiểu và học ngôn ngữ lập trình Rust. Để trau dồi thêm khả năng code bằng Rust, mình sẽ setup một dự án cho bản thân, tên dự án hiện tại là Rust_Tracking. Dùng Rust để viết Firmware cho thiết bị GPS, sau đó gửi dữ liệu lên IoT Platform - ThingsBoard. IoT Platform này mình cũng tự build dựa trên hạ tầng hiện tại. Tự làm một thiết bị Tracking cho bản thân. 👉 Quản lý bán hàng Viết một app như của anh Sơn (vừa có thể chạy trên web, vừa dùng trên mobile app), dùng ngôn ngữ lập trình Flutter. Xây dựng database server (có thể dùng SQL Server). Web App: App hoạt động ở local (mạng nội bộ, không public), có chức năng nhập liệu. Kết nối với máy quét mã vạch, nhập số lượng hàng và đơn giá. Cập nhật dữ liệu cho database. Mobile App App chỉ có tác dụng quét mã để search đơn giá và cho biết hàng tồn kho. Khách hàng có thể dùng app này để biết tên hàng, và đơn giá. 👉 Raspberry Camera Mục đích là ôn luyện lại về Rust-lang + Tokio Framework cũng như đào sâu hơn về Nhúng Linux. Live-stream local (URL streaming Camera dùng HTTP hoặc RTSP). Platform: Lấy thông tin location, upload Image của camera. Điều khiển thông qua chatbot Telegram. Ngoài ra mình sẽ code camera này theo ONVIF Protocol, và theo QCVN-135\n👉 Bad USB Mục đích là để trau dồi kỹ năng coding dùng ngôn ngữ Rust, và ứng dụng vào Red-Team. Ở đây mình dự định sẽ dùng: Raspberry Pico + Rust-lang + Embassy Framewok 🌱 Ý tưởng cải thiện kỹ năng lập trình Rust: Phục vụ cho công việc. Nâng cao kỹ năng lập trình. 👉 Rust-IoT-Monitor Viết một console app bằng ngôn ngữ Rust. Kiểm tra thiết bị IoT đã kết nối với MQTT Broker (EMQX) Sau đó sẽ push những thông tin này cho ThingsBoard (tạo một dashboard sẵn) Nếu một thiết bị đã kết nối và bị disconnect thì sẽ có một notifi tới Telegram. 👉 Rust-for-ARM Các thiết bị Camera chạy linux nhúng, thường sẽ có một cổng UART để debug. Nhưng để lấy đc các thông tin debug này khá là phiền phức Do đó mình sẽ cần viết một công cụ để thể lấy log từ UART và lưu nó vào trong thẻ nhớ. ",
      "content_html": "\u003cp\u003eHiện tại thì bản thân vẫn đang tiếp tục cải thiện project \u003cstrong\u003eHOMELAB\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTuy nhiên mình sẽ làm một số project nhỏ hơn, và sẽ xoay quanh Homelab.\u003c/p\u003e\n\u003ch2 id=\"-ý-tưởng-bổ-sung-cho-homelab\"\u003e🌱 Ý tưởng bổ sung cho HomeLAB:\u003c/h2\u003e\n\u003ch3 id=\"-rust-tracking\"\u003e👉 Rust Tracking\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình vẫn đang tìm hiểu và học \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/rust-lang/\"\u003engôn ngữ lập trình Rust\u003c/a\u003e. Để trau dồi thêm khả năng code bằng Rust, mình sẽ setup một dự án cho bản thân, tên dự án hiện tại là \u003ccode\u003eRust_Tracking\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eDùng Rust để viết Firmware cho thiết bị GPS, sau đó gửi dữ liệu lên \u003ca href=\"https://www.vinhld-homelab.io.vn/login\"\u003eIoT Platform - ThingsBoard\u003c/a\u003e. IoT Platform này mình cũng tự build dựa trên hạ tầng hiện tại.\u003c/li\u003e\n\u003cli\u003eTự làm một thiết bị Tracking cho bản thân.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-quản-lý-bán-hàng\"\u003e👉 Quản lý bán hàng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eViết một app như của anh Sơn \u003cem\u003e(vừa có thể chạy trên web, vừa dùng trên mobile app)\u003c/em\u003e, dùng ngôn ngữ lập trình \u003cstrong\u003eFlutter\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eXây dựng \u003cstrong\u003edatabase server\u003c/strong\u003e \u003cem\u003e(có thể dùng \u003cstrong\u003eSQL Server\u003c/strong\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"web-app\"\u003eWeb App:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eApp hoạt động ở local \u003cem\u003e(mạng nội bộ, không public)\u003c/em\u003e, có chức năng nhập liệu.\u003c/li\u003e\n\u003cli\u003eKết nối với máy quét mã vạch, nhập số lượng hàng và đơn giá. Cập nhật dữ liệu cho database.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"mobile-app\"\u003eMobile App\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eApp chỉ có tác dụng quét mã để search đơn giá và cho biết hàng tồn kho.\u003c/li\u003e\n\u003cli\u003eKhách hàng có thể dùng app này để biết tên hàng, và đơn giá.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-raspberry-camera\"\u003e👉 Raspberry Camera\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục đích là ôn luyện lại về \u003cstrong\u003eRust-lang + Tokio Framework\u003c/strong\u003e cũng như đào sâu hơn về \u003cstrong\u003eNhúng Linux\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLive-stream local \u003cem\u003e(URL streaming Camera dùng HTTP hoặc RTSP)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003ePlatform: Lấy thông tin location, upload Image của camera.\u003c/li\u003e\n\u003cli\u003eĐiều khiển thông qua chatbot Telegram.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNgoài ra mình sẽ code camera này theo \u003cstrong\u003eONVIF Protocol\u003c/strong\u003e, và theo \u003ca href=\"https://sotttt.angiang.gov.vn/sites/default/files/2025-01/qcvn%20135.2024-%20ip%20camera.pdf\"\u003eQCVN-135\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"-bad-usb\"\u003e👉 Bad USB\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục đích là để \u003cstrong\u003etrau dồi kỹ năng coding dùng ngôn ngữ Rust, và ứng dụng vào Red-Team\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eỞ đây mình dự định sẽ dùng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRaspberry Pico + Rust-lang + Embassy Framewok\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"-ý-tưởng-cải-thiện-kỹ-năng-lập-trình-rust\"\u003e🌱 Ý tưởng cải thiện kỹ năng lập trình Rust:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ePhục vụ cho công việc.\u003c/li\u003e\n\u003cli\u003eNâng cao kỹ năng lập trình.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-rust-iot-monitor\"\u003e👉 Rust-IoT-Monitor\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eViết một \u003cstrong\u003econsole app\u003c/strong\u003e bằng ngôn ngữ Rust.\u003c/li\u003e\n\u003cli\u003eKiểm tra thiết bị IoT đã kết nối với MQTT Broker \u003cem\u003e(EMQX)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eSau đó sẽ push những thông tin này cho ThingsBoard \u003cem\u003e(tạo một dashboard sẵn)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eNếu một thiết bị đã kết nối và bị disconnect thì sẽ có một notifi tới Telegram.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-rust-for-arm\"\u003e👉 Rust-for-ARM\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCác thiết bị Camera chạy \u003ccode\u003elinux nhúng\u003c/code\u003e, thường sẽ có một cổng UART để debug. Nhưng để lấy đc các thông tin debug này khá là phiền phức\u003c/li\u003e\n\u003cli\u003eDo đó mình sẽ cần viết một công cụ để thể \u003cstrong\u003elấy log từ UART\u003c/strong\u003e và \u003cstrong\u003elưu nó vào trong thẻ nhớ\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/y_tuong_project/",
      "date_published": "26026-26-09T252:2626:00+07:00",
      "date_modified": "26026-26-09T252:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "ffd246c4a4fc5e829bdbcbe79b2b069658e33707",
      "title": "Virtual_System",
      "summary": "",
      "content_text": "Lụm được bài viết 10 Virtualization Systems You Should Know\n",
      "content_html": "\u003cp\u003eLụm được bài viết \u003ca href=\"https://www.threads.net/@anastasis_king/post/DE-XeORssNx\"\u003e10 Virtualization Systems You Should Know\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_3.jfif\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_8.jpg\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_9.jpg\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Virtual_System/Hinh_10.jpg\"\n  alt=\"Hình 10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/virtual_system/",
      "date_published": "10026-10-09T22:1010:00+07:00",
      "date_modified": "10026-10-09T22:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "ec78fc6e5f39ffda9be97974fa1cf6163f36f2af",
      "title": "RAID",
      "summary": "",
      "content_text": "Tham khảo video: Khái niệm về RAID RAID (Redundant Array of Independent/Inexpensive Disks) là một công nghệ lưu trữ dữ liệu cho phép kết hợp nhiều ổ đĩa cứng để tăng hiệu suất hoặc tạo khả năng chịu lỗi (fault tolerance).\nMột số cấp độ RAID phổ biến: RAID 0 (thường gọi là Striping): Ưu điểm của raid 0 chính là khả năng gộp ổ đĩa và có tốc độ đọc/ghi cao. Nhược điểm chính là dễ mất dữ liệu nếu ổ cứng bị hư. RAID 1 (thường gọi là Mirroring): Ưu điểm chính là về mặt an toàn dữ liệu. Nhược điểm là tốn tài nguyên của ổ cứng (vì cần phân vùng để lưu trữ backup). RAID 5 - Ít nhất phải có từ 3 ổ cứng trở lên RAID 5 có thể chịu được sự hỏng hóc của một ổ đĩa (Tức là trong 3 ổ, nếu có 1 ổ bị hỏng thì hệ thống vẫn hoạt động bình thường và vẫn đảm bảo về mặt an toàn dữ liệu). RAID 5 hoạt động tốt trong các ứng dụng chẳng hạn như hệ thống lưu trữ tập tin, máy chủ cơ sở dữ liệu, hoặc hệ thống lưu trữ tệp doanh nghiệp. RAID 6 RAID 6 là sự cải tiến từ RAID 5, sử dụng ít nhất là 4 ổ đĩa. Chịu được hỏng hóc của hai ổ đĩa. RAID 10 - Cần ít nhất 4 ổ đĩa. RAID 10 là dung hòa giữa RAID 0 và RAID 1. RAID 10 là lựa chọn lý tưởng trong các tình huống cần sự cân bằng giữa hiệu suất và độ an toàn dữ liệu. Bảng so sánh RAID_Overview ",
      "content_html": "\u003ch2 id=\"tham-khảo-video-khái-niệm-về-raidhttpswwwyoutubecomwatchvi9kbfiswxpclistwlindex6\"\u003eTham khảo video: \u003ca href=\"https://www.youtube.com/watch?v=i9KbFISWXPc\u0026amp;list=WL\u0026amp;index=6\"\u003eKhái niệm về RAID\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eRAID (Redundant Array of Independent/Inexpensive Disks)\u003c/strong\u003e là một công nghệ lưu trữ dữ liệu cho phép kết hợp nhiều ổ đĩa cứng để tăng hiệu suất hoặc tạo khả năng chịu lỗi (fault tolerance).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"một-số-cấp-độ-raid-phổ-biến\"\u003eMột số cấp độ RAID phổ biến:\u003c/h2\u003e\n\u003ch3 id=\"raid-0-thường-gọi-là-striping\"\u003eRAID 0 \u003cem\u003e(thường gọi là Striping)\u003c/em\u003e:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eƯu điểm của \u003cstrong\u003eraid 0\u003c/strong\u003e chính là khả năng \u003cstrong\u003egộp ổ đĩa\u003c/strong\u003e và có tốc độ đọc/ghi cao.\u003c/li\u003e\n\u003cli\u003eNhược điểm chính là \u003cstrong\u003edễ mất dữ liệu\u003c/strong\u003e nếu ổ cứng bị hư.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-1-thường-gọi-là-mirroring\"\u003eRAID 1 \u003cem\u003e(thường gọi là Mirroring)\u003c/em\u003e:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eƯu điểm chính là về mặt \u003cstrong\u003ean toàn dữ liệu\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhược điểm là tốn tài nguyên của ổ cứng \u003cem\u003e(vì cần phân vùng để lưu trữ backup)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-5---ít-nhất-phải-có-từ-3-ổ-cứng-trở-lên\"\u003eRAID 5 - Ít nhất phải có từ 3 ổ cứng trở lên\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_3.png\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRAID 5 có thể chịu được sự hỏng hóc của một ổ đĩa \u003cem\u003e(Tức là trong 3 ổ, nếu có 1 ổ bị hỏng thì hệ thống vẫn hoạt động bình thường và vẫn đảm bảo về mặt an toàn dữ liệu)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eRAID 5 hoạt động tốt trong các ứng dụng chẳng hạn như hệ thống lưu trữ tập tin, máy chủ cơ sở dữ liệu, hoặc hệ thống lưu trữ tệp doanh nghiệp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-6\"\u003eRAID 6\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRAID 6\u003c/strong\u003e là sự cải tiến từ RAID 5, sử dụng ít nhất là 4 ổ đĩa.\u003c/li\u003e\n\u003cli\u003eChịu được hỏng hóc của hai ổ đĩa.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raid-10---cần-ít-nhất-4-ổ-đĩa\"\u003eRAID 10 - Cần ít nhất 4 ổ đĩa.\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_4.png\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRAID 10\u003c/strong\u003e là dung hòa giữa \u003cstrong\u003eRAID 0\u003c/strong\u003e và \u003cstrong\u003eRAID 1\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eRAID 10 là lựa chọn lý tưởng trong các tình huống cần sự cân bằng giữa hiệu suất và độ an toàn dữ liệu.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"bảng-so-sánh\"\u003eBảng so sánh\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/Hinh_5.png\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"raid_overview\"\u003eRAID_Overview\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/RAID/RAID_Overview.jpg\"\n  alt=\"RAID_Overview\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/raid/",
      "date_published": "19016-19-09T146:1919:00+07:00",
      "date_modified": "19016-19-09T146:1919:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a0581688a31b709ce24dc5881aa840791987b478",
      "title": "CyberSecurity_Small_Businesses",
      "summary": "",
      "content_text": "Tổng hợp tài liệu về An toàn thông tin cho doanh nghiệp nhỏ: https://www.ftc.gov/business-guidance/small-businesses https://www.ftc.gov/business-guidance/small-businesses/cybersecurity https://www.ftc.gov/business-guidance/small-businesses/cybersecurity/basics https://www.ftc.gov/business-guidance/small-businesses/protecting-small-businesses-cases ",
      "content_html": "\u003ch3 id=\"tổng-hợp-tài-liệu-về-an-toàn-thông-tin-cho-doanh-nghiệp-nhỏ\"\u003eTổng hợp tài liệu về An toàn thông tin cho doanh nghiệp nhỏ:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.ftc.gov/business-guidance/small-businesses\nhttps://www.ftc.gov/business-guidance/small-businesses/cybersecurity\nhttps://www.ftc.gov/business-guidance/small-businesses/cybersecurity/basics\nhttps://www.ftc.gov/business-guidance/small-businesses/protecting-small-businesses-cases\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_6.jpg\"\n  alt=\"Hình 6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_7.jpg\"\n  alt=\"Hình 7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_8.jpg\"\n  alt=\"Hình 8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_9.jpg\"\n  alt=\"Hình 9\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_10.jpg\"\n  alt=\"Hình 10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_11.jpg\"\n  alt=\"Hình 11\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_12.jpg\"\n  alt=\"Hình 12\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_13.jpg\"\n  alt=\"Hình 13\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_14.jpg\"\n  alt=\"Hình 14\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_15.jpg\"\n  alt=\"Hình 15\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_16.jpg\"\n  alt=\"Hình 16\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_17.jpg\"\n  alt=\"Hình 17\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_18.jpg\"\n  alt=\"Hình 18\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_19.jpg\"\n  alt=\"Hình 19\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_20.jpg\"\n  alt=\"Hình 20\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_21.jpg\"\n  alt=\"Hình 21\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_22.jpg\"\n  alt=\"Hình 22\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_23.jpg\"\n  alt=\"Hình 23\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/CyberSecurity_Small_Businesses/Hinh_24.jpg\"\n  alt=\"Hình 24\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/cybersecurity_small_businesses/",
      "date_published": "17016-17-09T121:1717:00+07:00",
      "date_modified": "17016-17-09T121:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4a57b11d43630c5780b931bd58155e3637932a52",
      "title": "N8n",
      "summary": "",
      "content_text": "Giới thiệu n8n n8n là một công cụ tự động hóa luồng công việc (workflow automation) mã nguồn mở. Nó cho phép người dùng tạo ra các luồng công việc tự động bằng cách kết nối các ứng dụng, dịch vụ và API khác nhau mà không cần viết code. n8n phù hợp để tự động hóa các quy trình kinh doanh, quản lý dữ liệu và tích hợp ứng dụng. Ví dụ về Tự động hóa phát triển phần mềm: Tích hợp CI/CD: Khi có commit mới trên GitHub, n8n có thể kích hoạt một quy trình CI/CD trên Jenkins hoặc GitLab. Thông báo lỗi: Khi có lỗi xảy ra trong ứng dụng (được ghi nhận qua Sentry), n8n có thể gửi thông báo tới đội phát triển qua Slack. Một số bài viết về n8n: https://wiki.matbao.net/top-3-cong-nghe-ai-giup-tu-dong-hoa-quy-trinh-lam-viec-hieu-qua/ https://viblo.asia/p/gioi-thieu-n8n-nodes-chatwork-L4x5x3JblBM https://www.youtube.com/watch?v=oqNWwiFKAj0 Tham khảo tài liệu: Free versions: A free self-hosted community edition for self-hosted users Docker Installation: https://docs.n8n.io/hosting/installation/docker/ Build AI functionality using n8n: https://docs.n8n.io/advanced-ai/#related-resources https://docs.n8n.io/hosting/starter-kits/ai-starter-kit/ Install n8n on server super fast with only 1 command - AI Noodles Dựa theo video và tài liệu về n8n, thì có thể dùng n8n + AI để thực hiện các tác vụ nâng cao về automation. và trong video thì sử dụng LocalAI Install LocalAI: https://localai.io/basics/container/ https://localai.io/basics/build/ Enrich security incident tickets\n",
      "content_html": "\u003ch2 id=\"giới-thiệu-n8n\"\u003eGiới thiệu n8n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003en8n\u003c/strong\u003e là một công cụ \u003cstrong\u003etự động hóa luồng công việc\u003c/strong\u003e \u003cem\u003e(workflow automation)\u003c/em\u003e mã nguồn mở.\u003c/li\u003e\n\u003cli\u003eNó cho phép người dùng tạo ra các luồng công việc tự động bằng cách kết nối các ứng dụng, dịch vụ và API khác nhau mà không cần viết code.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003en8n\u003c/strong\u003e phù hợp để tự động hóa các quy trình kinh doanh, quản lý dữ liệu và tích hợp ứng dụng.\u003c/li\u003e\n\u003cli\u003eVí dụ về \u003cstrong\u003eTự động hóa phát triển phần mềm\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTích hợp CI/CD\u003c/strong\u003e: Khi có commit mới trên GitHub, n8n có thể kích hoạt một quy trình CI/CD trên Jenkins hoặc GitLab.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eThông báo lỗi\u003c/strong\u003e: Khi có lỗi xảy ra trong ứng dụng (được ghi nhận qua Sentry), n8n có thể gửi thông báo tới đội phát triển qua Slack.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMột số bài viết về \u003cstrong\u003en8n\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://wiki.matbao.net/top-3-cong-nghe-ai-giup-tu-dong-hoa-quy-trinh-lam-viec-hieu-qua/\nhttps://viblo.asia/p/gioi-thieu-n8n-nodes-chatwork-L4x5x3JblBM\nhttps://www.youtube.com/watch?v=oqNWwiFKAj0\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tham-khảo-tài-liệu\"\u003eTham khảo tài liệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.n8n.io/choose-n8n/#licenses\"\u003eFree versions\u003c/a\u003e: A free self-hosted community edition for self-hosted users\u003c/li\u003e\n\u003cli\u003eDocker Installation: \u003ca href=\"https://docs.n8n.io/hosting/installation/docker/\"\u003ehttps://docs.n8n.io/hosting/installation/docker/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eBuild AI functionality using n8n:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://docs.n8n.io/advanced-ai/#related-resources\nhttps://docs.n8n.io/hosting/starter-kits/ai-starter-kit/\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"install-n8n-on-server-super-fast-with-only-1-command---ai-noodleshttpswwwyoutubecomwatchvoflygnmskoq\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=OfLYgNmsKoQ\"\u003eInstall n8n on server super fast with only 1 command - AI Noodles\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa theo video và tài liệu về n8n, thì có thể dùng \u003cstrong\u003en8n + AI\u003c/strong\u003e để thực hiện các tác vụ nâng cao về automation.\u003c/li\u003e\n\u003cli\u003evà trong video thì sử dụng \u003ca href=\"https://localai.io/\"\u003eLocalAI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eInstall LocalAI:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://localai.io/basics/container/\nhttps://localai.io/basics/build/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEnrich security incident tickets\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://n8niostorageaccount.blob.core.windows.net/n8nio-strapi-blobs-prod/assets/secops_usecase_4c6aaad973.png\"\n  alt=\"n8n - SecOps\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/n8n/",
      "date_published": "17016-17-09T159:1717:00+07:00",
      "date_modified": "17016-17-09T159:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "619c010a490e554688b4fda9b97f007486f52708",
      "title": "Tailscale",
      "summary": "",
      "content_text": "Video: 3 Best Remote Access Methods for Your Homelab Revealed! Sau khi xem xong video này, mình thấy có một thông tin khá hay. Đó là về giải pháp VPN Tailscale Tailscale Tailscale một giải pháp VPN thay thế cho các kiểu VPN truyền thống. Mình có thể sử dụng Tailscale cho cá nhân (và nó free). Với bản free thì mình có thể add tối đa là 100 devices và giới hạn ở 3 account (dạng như là tạo các account con và phần quyền) Mình thấy Tailscale này có nét giống với ngrok và raspberry connect, tất nhiên là mục đích 2 công cụ này là khác nhau và ngrok thì bị giới hạn về số lượng thiết bị. Documents của Tailscale: https://tailscale.com/kb/1017/install https://tailscale.com/use-cases/homelab Một bài viết khác về Tailscale: https://thuanbui.me/tailscale-vpn/ Note Hiện tại thì mình đang dùng giải pháp VPN truyền thống (Fortigate VPN) và Jump-Server (Teleport). Nên giải pháp Tailscale mang tính chất tham khảo, cái này mình thấy cũng khá hay, biết đâu sau này lại có thể áp dụng vào đâu đó. How Tailscale works ",
      "content_html": "\u003ch3 id=\"video-3-best-remote-access-methods-for-your-homelab-revealedhttpswwwyoutubecomwatchvxmktcfb5vselistwlindex4t2s\"\u003eVideo: \u003ca href=\"https://www.youtube.com/watch?v=XMKTCFB5VsE\u0026amp;list=WL\u0026amp;index=4\u0026amp;t=2s\"\u003e3 Best Remote Access Methods for Your Homelab Revealed!\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi xem xong video này, mình thấy có một thông tin khá hay.\u003c/li\u003e\n\u003cli\u003eĐó là về giải pháp VPN \u003cstrong\u003eTailscale\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tailscalehttpstailscalecom\"\u003e\u003ca href=\"https://tailscale.com/\"\u003eTailscale\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTailscale một giải pháp VPN thay thế cho các kiểu \u003cem\u003eVPN truyền thống\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eMình có thể sử dụng Tailscale cho cá nhân \u003cem\u003e(và nó \u003cstrong\u003efree\u003c/strong\u003e)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eVới bản free thì mình có thể add tối đa là \u003cstrong\u003e100 devices\u003c/strong\u003e và giới hạn ở \u003cstrong\u003e3 account\u003c/strong\u003e \u003cem\u003e(dạng như là tạo các account con và phần quyền)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eMình thấy Tailscale này có nét giống với \u003cstrong\u003engrok\u003c/strong\u003e và \u003cstrong\u003eraspberry connect\u003c/strong\u003e, tất nhiên là mục đích 2 công cụ này là khác nhau và ngrok thì bị giới hạn về số lượng thiết bị.\u003c/li\u003e\n\u003cli\u003eDocuments của Tailscale:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tailscale.com/kb/1017/install\nhttps://tailscale.com/use-cases/homelab\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eMột bài viết khác về \u003cstrong\u003eTailscale\u003c/strong\u003e: \u003ca href=\"https://thuanbui.me/tailscale-vpn/\"\u003ehttps://thuanbui.me/tailscale-vpn/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiện tại thì mình đang dùng giải pháp VPN truyền thống \u003cem\u003e(Fortigate VPN)\u003c/em\u003e và Jump-Server \u003cem\u003e(Teleport)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eNên giải pháp \u003cstrong\u003eTailscale\u003c/strong\u003e mang tính chất tham khảo, cái này mình thấy cũng khá hay, biết đâu sau này lại có thể áp dụng vào đâu đó.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"how-tailscale-works\"\u003eHow Tailscale works\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://cdn.sanity.io/images/w77i7m8x/production/dbba97845c1ad1955669cc6a84c94f9d5fb78ade-1600x1080.svg?w=1920\u0026amp;q=75\u0026amp;fit=clip\u0026amp;auto=format\"\n  alt=\"Tailscale\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/tailscale/",
      "date_published": "17016-17-09T142:1717:00+07:00",
      "date_modified": "17016-17-09T142:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "78793621d7815d3fbfd1c0eb90c9aeed3088d9c5",
      "title": "OpenMediaVault",
      "summary": "",
      "content_text": "History STT Create Description 1 30/11/2024 Tạo nội dung về OMV. 2 28/12/2024 Thêm nội dung về một NAS OS - HexOS OpenMediaVault (OMV) Là một hệ điều hành mã nguồn mở được thiết kế đặc biệt để triển khai hệ thống lưu trữ mạng (Network Attached Storage - NAS). Dựa trên hệ điều hành Debian Linux, OMV cung cấp một giao diện web thân thiện để quản lý, cấu hình và vận hành các dịch vụ lưu trữ dữ liệu. Lưu ý là hiện tại OMV không hỗ trợ trên Ubuntu được. Ngoài ra mình cũng có thể cài OMV trên Raspberry. Download file ISO Documents: https://computingforgeeks.com/install-and-configure-openmediavault-nas-storage-server/#google_vignette https://pakstech.com/blog/openmediavault-proxmox/ https://www.youtube.com/watch?v=Bce7VT3kJ4g https://longervision.github.io/2024/08/08/OperatingSystems/RaspberryPi/openmediavault-nas/ https://github.com/openmediavault/openmediavault https://www.openmediavault.org/ https://linuxconfig.org/how-to-install-openmediavault-on-raspberry-pi https://www.the-diy-life.com/i-built-a-4-bay-raspberry-pi-5-based-nas/ My Dashboard OMV\nCập nhật ngày 28/12/2024 HexOS Đây là một OS dành cho việc lưu trữ, một OS dành cho NAS-Server. HexOS này được xây dựng dựa trên TrueNAS, và cũng là một dạng open-source. Storage, streaming, virtual machines and more. Create a secure, private server you can manage from anywhere with HexOS.\nTài liệu tham khảo và video: Home Servers Might Never Be The Same\u0026hellip; HexOS Is Here https://hexos.com/blog/the-magic-behind-hexos https://nascompares.com/2024/12/02/hexos-nas-software-review-of-the-beta/ Video so sánh: Best NAS Software: TrueNAS vs OpenMediaVault vs Unraid ",
      "content_html": "\u003ch2 id=\"history\"\u003eHistory\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eSTT\u003c/th\u003e\n\u003cth\u003eCreate\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e30/11/2024\u003c/td\u003e\n\u003ctd\u003eTạo nội dung về \u003cstrong\u003eOMV\u003c/strong\u003e.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e28/12/2024\u003c/td\u003e\n\u003ctd\u003eThêm nội dung về một NAS OS - \u003cstrong\u003eHexOS\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"openmediavault-omvhttpswwwopenmediavaultorg\"\u003e\u003ca href=\"https://www.openmediavault.org/\"\u003eOpenMediaVault (OMV)\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLà một hệ điều hành mã nguồn mở được thiết kế đặc biệt để triển khai hệ thống lưu trữ mạng (Network Attached Storage - NAS).\u003c/li\u003e\n\u003cli\u003eDựa trên hệ điều hành \u003cstrong\u003eDebian Linux\u003c/strong\u003e, OMV cung cấp một giao diện web thân thiện để quản lý, cấu hình và vận hành các dịch vụ lưu trữ dữ liệu.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLưu ý là hiện tại \u003cstrong\u003eOMV\u003c/strong\u003e không hỗ trợ trên Ubuntu được. \u003c/br\u003e\nNgoài ra mình cũng có thể cài OMV trên \u003cstrong\u003eRaspberry\u003c/strong\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"download-file-isohttpswwwopenmediavaultorgdownloadhtml\"\u003e\u003ca href=\"https://www.openmediavault.org/download.html\"\u003eDownload file ISO\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"documents\"\u003eDocuments:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://computingforgeeks.com/install-and-configure-openmediavault-nas-storage-server/#google_vignette\"\u003ehttps://computingforgeeks.com/install-and-configure-openmediavault-nas-storage-server/#google_vignette\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pakstech.com/blog/openmediavault-proxmox/\"\u003ehttps://pakstech.com/blog/openmediavault-proxmox/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=Bce7VT3kJ4g\"\u003ehttps://www.youtube.com/watch?v=Bce7VT3kJ4g\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://longervision.github.io/2024/08/08/OperatingSystems/RaspberryPi/openmediavault-nas/\"\u003ehttps://longervision.github.io/2024/08/08/OperatingSystems/RaspberryPi/openmediavault-nas/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/openmediavault/openmediavault\"\u003ehttps://github.com/openmediavault/openmediavault\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.openmediavault.org/\"\u003ehttps://www.openmediavault.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://linuxconfig.org/how-to-install-openmediavault-on-raspberry-pi\"\u003ehttps://linuxconfig.org/how-to-install-openmediavault-on-raspberry-pi\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.the-diy-life.com/i-built-a-4-bay-raspberry-pi-5-based-nas/\"\u003ehttps://www.the-diy-life.com/i-built-a-4-bay-raspberry-pi-5-based-nas/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMy Dashboard OMV\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/NAS_Server/Dashboard_OMV.png\"\n  alt=\"OMV\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-ngày-28122024\"\u003eCập nhật ngày 28/12/2024\u003c/h2\u003e\n\u003ch3 id=\"hexos\"\u003eHexOS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một OS dành cho việc lưu trữ, một OS dành cho NAS-Server. HexOS này được xây dựng dựa trên \u003cstrong\u003eTrueNAS\u003c/strong\u003e, và cũng là một dạng open-source.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eStorage, streaming, virtual machines and more. \u003c/br\u003e\nCreate a secure, private server you can manage from anywhere with HexOS.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/NAS_Server/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo-và-video\"\u003eTài liệu tham khảo và video:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=AfRZuZ6G1SM\"\u003eHome Servers Might Never Be The Same\u0026hellip; HexOS Is Here\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://hexos.com/blog/the-magic-behind-hexos\"\u003ehttps://hexos.com/blog/the-magic-behind-hexos\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://nascompares.com/2024/12/02/hexos-nas-software-review-of-the-beta/\"\u003ehttps://nascompares.com/2024/12/02/hexos-nas-software-review-of-the-beta/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"video-so-sánh-best-nas-software-truenas-vs-openmediavault-vs-unraidhttpswwwyoutubecomwatchvxngpayc2iau\"\u003eVideo so sánh: \u003ca href=\"https://www.youtube.com/watch?v=xNGPAyC2iaU\"\u003eBest NAS Software: TrueNAS vs OpenMediaVault vs Unraid\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/NAS_Server/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/openmediavault/",
      "date_published": "28126-28-09T1238:2828:00+07:00",
      "date_modified": "28126-28-09T1238:2828:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7c7d735238dc0f4aee07cc79500aed744f63b4c5",
      "title": "ClamAV",
      "summary": "",
      "content_text": " ClamAV là một công cụ open-source, theo tài liệu thì có thể cài đặt trên nhiều OS từ Windows cho đến Linux. Tuy nhiên mình thấy trên Win đã có Windows Defender rất mạnh mẽ rồi. Hiện tại các công cụ Endpoint mình đang dùng bao gồm: Antivirus: Windows Defender, ClamAV (sẽ dùng trong tương lai gần) XDR: Wazuh Agent EDR: Aurora Agent ClamAV + Wazuh, powerful Anti-Virus protection for Linux Công cụ này sẽ thực sự hữu ích và phát huy tác dụng mạnh trên Linux. Giống như trong video có giới thiệu, việc kết hợp giữa ClamAV + Wazuh sẽ giúp mình monitor và phản ứng kịp thời các tác nhân gây hại đến server. Documentation https://github.com/Cisco-Talos/clamav https://docs.clamav.net/ https://www.clamav.net/downloads ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eClamAV là một công cụ open-source, theo tài liệu thì có thể cài đặt trên nhiều OS từ Windows cho đến Linux.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/ClamAV/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTuy nhiên mình thấy trên Win đã có \u003cstrong\u003eWindows Defender\u003c/strong\u003e rất mạnh mẽ rồi.\u003c/li\u003e\n\u003cli\u003eHiện tại các công cụ \u003cstrong\u003eEndpoint\u003c/strong\u003e mình đang dùng bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eAntivirus\u003c/strong\u003e: Windows Defender, ClamAV \u003cem\u003e(sẽ dùng trong tương lai gần)\u003c/em\u003e \u003c/br\u003e\n\u003cstrong\u003eXDR\u003c/strong\u003e: Wazuh Agent \u003c/br\u003e\n\u003cstrong\u003eEDR\u003c/strong\u003e: Aurora Agent \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"clamav--wazuh-powerful-anti-virus-protection-for-linuxhttpswwwyoutubecomwatchv9e45tq61h14\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=9e45TQ61H14\"\u003eClamAV + Wazuh, powerful Anti-Virus protection for Linux\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này sẽ thực sự hữu ích và phát huy tác dụng mạnh trên Linux.\u003c/li\u003e\n\u003cli\u003eGiống như trong video có giới thiệu, việc kết hợp giữa \u003cstrong\u003eClamAV + Wazuh\u003c/strong\u003e sẽ giúp mình monitor và phản ứng kịp thời các tác nhân gây hại đến server.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/ClamAV/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"documentation\"\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Cisco-Talos/clamav\"\u003ehttps://github.com/Cisco-Talos/clamav\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.clamav.net/\"\u003ehttps://docs.clamav.net/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.clamav.net/downloads\"\u003ehttps://www.clamav.net/downloads\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/clamav/",
      "date_published": "30116-30-09T1120:3030:00+07:00",
      "date_modified": "30116-30-09T1120:3030:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4ad146984946ab4ae6ecd241e37735fd7ae01a94",
      "title": "Huly",
      "summary": "",
      "content_text": "Một platform open-source quản lý dự án.\nCó các tính năng như:\nJira Meeting, chat Và documents như Notion Nếu như không muốn bỏ quá nhiều chi phí cho các nền tảng trả phí, thì có thể tham khảo để tự host Huly này để xài.\nTài liệu: https://docs.huly.io/getting-started/introduction-huly/ https://huly.io/ https://github.com/hcengineering/platform ",
      "content_html": "\u003cp\u003eMột platform open-source quản lý dự án.\u003c/p\u003e\n\u003cp\u003eCó các tính năng như:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJira\u003c/li\u003e\n\u003cli\u003eMeeting, chat\u003c/li\u003e\n\u003cli\u003eVà documents như Notion\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNếu như không muốn bỏ quá nhiều chi phí cho các nền tảng trả phí, thì có thể tham khảo để tự host \u003cstrong\u003eHuly\u003c/strong\u003e này để xài.\u003c/p\u003e\n\u003ch3 id=\"tài-liệu\"\u003eTài liệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.huly.io/getting-started/introduction-huly/\"\u003ehttps://docs.huly.io/getting-started/introduction-huly/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huly.io/\"\u003ehttps://huly.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/hcengineering/platform\"\u003ehttps://github.com/hcengineering/platform\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/huly/",
      "date_published": "17116-17-09T1145:1717:00+07:00",
      "date_modified": "17116-17-09T1145:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "dcda9882e36876d12b63310331edb055fc9f5a92",
      "title": "Permission_Linux",
      "summary": "",
      "content_text": "Ghi chú về Permission trong linux.\nVideo: DevOps for Freshers | Bài 7: Quyền truy cập trong Linux | DevOps cho người mới bắt đầu Phân quyền - Permission Theo như trong video thì phân quyền sẽ có: Chủ sở hữu (u) - Nhóm sở hữu (g) - Nhóm khác (o) Muốn thay đổi quyền sở hữu (của tất cả tập tin có trong thư mục) thì dùng lệnh: sudo chown -R \u0026lt;chu_so_huu\u0026gt;:\u0026lt;nhom_so_huu\u0026gt; \u0026lt;folder_name\u0026gt; Mỗi nhóm sẽ đều có các quyền tác động khác nhau. Quyền tác động: read (4) - write (2) - execute (1) Câu lệnh để thay đổi đổi một quyền tác động của 1 file, ví dụ: sudo chmod 750 \u0026lt;file_name\u0026gt; Với 750 cho \u0026lt;file_name\u0026gt;, tức là file này: Có quyền r,w,e \u0026ndash;\u0026gt; Chủ sở hữu file Có quyền r,e \u0026ndash;\u0026gt; Nhóm sở hữu file Không có quyền thao tác trên file này đối với nhóm khác ",
      "content_html": "\u003cp\u003eGhi chú về \u003cstrong\u003ePermission trong linux\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"video-devops-for-freshers--bài-7-quyền-truy-cập-trong-linux--devops-cho-người-mới-bắt-đầuhttpswwwyoutubecomwatchvu5oufnvomt4listplsvroivfnp1ku8fouecc-hbjbqnaggwl2index8\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=U5Oufnvomt4\u0026amp;list=PLsvroIvFNP1KU8foUeCC-hbJbqnAggWL2\u0026amp;index=8\"\u003eVideo: DevOps for Freshers | Bài 7: Quyền truy cập trong Linux | DevOps cho người mới bắt đầu\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Permission_Linux/Permission.png\"\n  alt=\"Permission\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"phân-quyền---permission\"\u003ePhân quyền - Permission\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo như trong video thì phân quyền sẽ có:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eChủ sở hữu (u) - Nhóm sở hữu (g) - Nhóm khác (o)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eMuốn thay đổi quyền sở hữu (của tất cả tập tin có trong thư mục) thì dùng lệnh:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo chown -R \u0026lt;chu_so_huu\u0026gt;:\u0026lt;nhom_so_huu\u0026gt; \u0026lt;folder_name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eMỗi nhóm sẽ đều có các quyền tác động khác nhau.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"quyền-tác-động\"\u003eQuyền tác động:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eread (4) - write (2) - execute (1)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCâu lệnh để thay đổi đổi một quyền tác động của 1 file, ví dụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo chmod 750 \u0026lt;file_name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eVới \u003cstrong\u003e750\u003c/strong\u003e cho \u003ccode\u003e\u0026lt;file_name\u0026gt;\u003c/code\u003e, tức là file này:\n\u003cul\u003e\n\u003cli\u003eCó quyền \u003cstrong\u003er,w,e\u003c/strong\u003e \u0026ndash;\u0026gt; Chủ sở hữu file\u003c/li\u003e\n\u003cli\u003eCó quyền \u003cstrong\u003er,e\u003c/strong\u003e \u0026ndash;\u0026gt; Nhóm sở hữu file\u003c/li\u003e\n\u003cli\u003eKhông có quyền thao tác trên file này đối với nhóm khác\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/System-DevOps/Permission_Linux/Linux_File_Cheatsheet.jfif\"\n  alt=\"Cheatsheet\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/system-devops/permission_linux/",
      "date_published": "17116-17-09T1139:1717:00+07:00",
      "date_modified": "17116-17-09T1139:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8952986493d99062e799e181787175b42c8ffafe",
      "title": "Kien_truc_may_tinh",
      "summary": "",
      "content_text": " Ngày Mô tả 27/8/2024 Khởi tạo bài viết 17/11/2024 Update thêm từ video ARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn? Kiển trúc Máy tính Kiến trúc máy tính - Von-Neumann Được chia làm 3 phần chính: CPU Memory IO Cả 3 thành phần này đều giao tiếp với nhau thông qua bus (gọi là data bus) kiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing) Sự khác biệt giữa kiến trúc Harvard vs Von-Neumann đó chính là sự bố trí giữa CPU - Memory.\nKiến trúc chip x86 Architecture Thường thấy trong các sản phẩm máy tính desktop hoặc laptop. Phổ biến là dòng chip của Intel. RISC Architectures MIPS Architecture: KIẾN TRÚC BỘ LỆNH ARM Architecture: Tài liệu ARMarch Một bài viết so sánh giữa ARM vs x86 Data Bus Có 2 kiểu truyền dữ liệu là:\nNối tiếp (Serial) Song song (Parallel) Song song Dùng cho display (truyền hình ảnh), PCI, printer,\u0026hellip; Nối tiếp: Dùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,\u0026hellip; Giao tiếp nối tiếp thì chia làm 2 loại là: Giao tiếp bất đồng bộ: UART, RS232, RS485 Giao tiếp đồng bộ: SPI Cập nhật 17/11/2024 Youtube: ARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn?\nViệc ARM được dùng trên di động thì không có gì mới lạ, nhưng việc ARM sử dụng trên PC (theo như trong video của anh Luân) thì cái này mình mới biết.\nChip ARM được sinh ra để khắc phục nhược điểm của x86.\nTrong video anh Luân nói về việc tương thích phần mềm giữa x86 với ARM. Và mình cũng đã gặp phải một case như vậy. Ban đầu mình có viết một app nho nhỏ bằng ngôn ngữ Rust-lang, chạy trên Linux (Ubuntu) kiến trúc x86 AMD64. App chạy bình thường, sau đó sử dụng rust cross-compile để convert file chạy trên raspberry. Convert xong thì chạy ko đc. Mình nghi là các library đang dùng không support cho arm. =]] ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e27/8/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/11/2024\u003c/td\u003e\n\u003ctd\u003eUpdate thêm từ video \u003cstrong\u003eARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn?\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"kiển-trúc-máy-tính\"\u003eKiển trúc Máy tính\u003c/h2\u003e\n\u003ch3 id=\"kiến-trúc-máy-tính---von-neumannhttpswwwdigikeycomenmakerblogs2024von-neumann-architecture\"\u003e\u003ca href=\"https://www.digikey.com/en/maker/blogs/2024/von-neumann-architecture\"\u003eKiến trúc máy tính - Von-Neumann\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐược chia làm 3 phần chính:\n\u003cul\u003e\n\u003cli\u003eCPU\u003c/li\u003e\n\u003cli\u003eMemory\u003c/li\u003e\n\u003cli\u003eIO\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCả 3 thành phần này đều giao tiếp với nhau thông qua \u003cstrong\u003ebus\u003c/strong\u003e (gọi là \u003ccode\u003edata bus\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kiến-trúc-harvard-sử-dụng-rộng-rãi-trong-các-bộ-vi-điều-khiển-và-dsp-digital-signal-processing\"\u003ekiến trúc Harvard: Sử dụng rộng rãi trong các bộ vi điều khiển và DSP (Digital Signal Processing)\u003c/h3\u003e\n\u003cp\u003eSự khác biệt giữa kiến trúc \u003cstrong\u003eHarvard\u003c/strong\u003e vs \u003cstrong\u003eVon-Neumann\u003c/strong\u003e đó chính là sự bố trí giữa \u003cstrong\u003eCPU - Memory\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"kiến-trúc-chiphttpsinc42comglossarychip-architecture\"\u003e\u003ca href=\"https://inc42.com/glossary/chip-architecture/\"\u003eKiến trúc chip\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"x86-architecture\"\u003ex86 Architecture\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThường thấy trong các sản phẩm máy tính desktop hoặc laptop.\u003c/li\u003e\n\u003cli\u003ePhổ biến là dòng chip của \u003cstrong\u003eIntel\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"risc-architectures\"\u003eRISC Architectures\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMIPS Architecture: \u003ca href=\"https://www.cit.ctu.edu.vn/~dtnghi/cod/ch3.pdf\"\u003eKIẾN TRÚC BỘ LỆNH\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eARM Architecture:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.csie.ntu.edu.tw/~cyy/courses/assembly/12fall/lectures/handouts/lec08_ARMarch.pdf\"\u003eTài liệu ARMarch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.candtsolution.com/news_events-detail/what-is-the-difference-between-arm-and-x86/\"\u003eMột bài viết so sánh giữa ARM vs x86\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"data-bushttpswwwdigikeycomenmakertutorials2023what-is-serial-communication-and-how-does-it-compare-to-paralleltextwhats20the20difference20between20serialdata20that20can20be20transferred\"\u003e\u003ca href=\"https://www.digikey.com/en/maker/tutorials/2023/what-is-serial-communication-and-how-does-it-compare-to-parallel#:~:text=What's%20the%20Difference%20Between%20Serial,data%20that%20can%20be%20transferred\"\u003eData Bus\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCó 2 kiểu truyền dữ liệu là:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eNối tiếp (Serial)\nSong song (Parallel)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Kien_truc_may_tinh/Communicate.jpg\"\n  alt=\"Communicate\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"song-song\"\u003eSong song\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng cho display (truyền hình ảnh), PCI, printer,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nối-tiếp\"\u003eNối tiếp:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng trong Ethernet, Wifi, BLE, eSATA, SPI, I2C, CAN, USB, RS232, RS485, JTAG,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eGiao tiếp nối tiếp thì chia làm 2 loại là:\n\u003cul\u003e\n\u003cli\u003eGiao tiếp bất đồng bộ: UART, RS232, RS485\u003c/li\u003e\n\u003cli\u003eGiao tiếp đồng bộ: SPI\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-17112024\"\u003eCập nhật 17/11/2024\u003c/h2\u003e\n\u003cp\u003eYoutube: \u003ca href=\"https://www.youtube.com/watch?v=9zurhPRRXRM\"\u003eARM vs x86: khác biệt ra sao? Mạnh hơn? Pin tốt hơn?\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eViệc \u003cstrong\u003eARM\u003c/strong\u003e được dùng trên di động thì không có gì mới lạ, nhưng việc \u003cstrong\u003eARM sử dụng trên PC\u003c/strong\u003e \u003cem\u003e(theo như trong video của anh Luân)\u003c/em\u003e thì cái này mình mới biết.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Kien_truc_may_tinh/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eChip ARM được sinh ra để khắc phục nhược điểm của x86\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Kien_truc_may_tinh/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video anh Luân nói về việc tương thích phần mềm giữa \u003cstrong\u003ex86\u003c/strong\u003e với \u003cstrong\u003eARM\u003c/strong\u003e. Và mình cũng đã gặp phải một case như vậy.\u003c/li\u003e\n\u003cli\u003eBan đầu mình có viết một app nho nhỏ bằng ngôn ngữ \u003cstrong\u003eRust-lang\u003c/strong\u003e, chạy trên \u003cstrong\u003eLinux (Ubuntu) kiến trúc x86 AMD64\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eApp chạy bình thường, sau đó sử dụng \u003cstrong\u003erust cross-compile\u003c/strong\u003e để convert file chạy trên raspberry. Convert xong thì chạy ko đc.\u003c/li\u003e\n\u003cli\u003eMình nghi là các library đang dùng không support cho \u003cstrong\u003earm\u003c/strong\u003e. =]]\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/kien_truc_may_tinh/",
      "date_published": "17116-17-09T1111:1717:00+07:00",
      "date_modified": "17116-17-09T1111:1717:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "f76f0d4ffc1fe7d93ee318f5333661e1fb4b243a",
      "title": "OBD2_PIDs",
      "summary": "",
      "content_text": "Xem thêm thông tin về CAN_OBDII\nTổng hợp tài liệu liên quan:\nCAN Bus Explained - A Simple Intro Wiki: OBDII PIDs OBD2 PID Overview OBD Diagnostic Trouble Code Converter \u0026amp; Lookup Tool Một tài liệu về sản phẩm tham khảo và thông tin về OBDII: OBD2 - Intro \u0026amp; Data Logger Guide DTC (Diagnostic Trouble Codes) DTC là các mã lỗi mà hệ thống chẩn đoán OBD-II tạo ra khi phát hiện vấn đề về hoạt động của xe. Chúng giúp xác định nguyên nhân của các sự cố liên quan đến hệ thống động cơ, khí thải, và các thành phần khác. PID (Parameter IDs) PID là các mã định danh tham số được sử dụng để yêu cầu và nhận dữ liệu từ các cảm biến và hệ thống khác nhau trên xe. Dữ liệu này giúp theo dõi tình trạng hoạt động của xe, chẳng hạn như tốc độ xe, tốc độ động cơ, nhiệt độ chất làm mát, v.v. DTC vs PIDs DTC để chẩn đoán lỗi. PID để giám sát dữ liệu. Ví dụ mình có dòng chip STN1110: Nếu cần lấy thông tin về xe thì mình dùng mã lệnh PID để gửi cho ECU, và nhận phản hồi từ ECU. Còn DTC (mã lỗi) thì xe sẽ tự động tạo ra mã lỗi này khi phát hiện vấn đề. Ví dụ, nếu xe của bạn gặp sự cố liên quan đến xi-lanh, ECU sẽ tạo ra mã lỗi P0301 và lưu trữ nó. khi bạn kết nối công cụ quét OBD-II (như STN1110) với cổng OBD-II của xe, công cụ này sẽ tự động đọc và hiển thị mã DTC mà ECU đã lưu trữ. Giới thiệu về STN1110 IC STN1110 là một OBD-II to UART interpreter IC (thiết bị trình dịch OBD-II sang UART) Thay vào đó, nó được sử dụng để chuyển đổi các thông điệp OBD-II thành các thông điệp UART, cho phép kết nối với các thiết bị khác như máy tính hoặc microcontroller thông qua giao tiếp UART. Nó hoạt động như một trung gian giúp truy xuất dữ liệu từ hệ thống OBD-II của xe, bao gồm các mã lỗi DTC, thông số hiệu suất, và nhiều thông tin khác. Để tạo ra một thiết bị tương tự như STN1110, bạn sẽ cần những thành phần cơ bản sau: MCU, CAN Controller, CAN Transceiver. Tham khảo Telematics Dashboards - Visualize CAN Data Dashboard này nhìn đẹp, rất hay ho, thật sự đáng nghiên cứu và học hỏi. Vừa kết hợp được những thông tin cơ bản lấy từ OBD2, vừa kết hợp với thông tin GPS của thiết bị tracking. Tổng hợp các lệnh PIDs thường dùng. Nhiệt độ làm mát (Engine Coolant Temperature - TMP) Tốc độ động cơ (Engine speed - RPM) Tốc độ phương tiện (Vehicle speed - SPD) Mass air flow sensor (MAF) Calculated engine load ",
      "content_html": "\u003cp\u003eXem thêm thông tin về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/hardware/can_obdii/\"\u003eCAN_OBDII\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTổng hợp tài liệu liên quan:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.csselectronics.com/pages/can-bus-simple-intro-tutorial\"\u003eCAN Bus Explained - A Simple Intro\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/OBD-II_PIDs\"\u003eWiki: OBDII PIDs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.csselectronics.com/pages/obd2-pid-table-on-board-diagnostics-j1979\"\u003eOBD2 PID Overview\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.csselectronics.com/pages/obd-trouble-code-dtc-lookup-converter-tool\"\u003eOBD Diagnostic Trouble Code Converter \u0026amp; Lookup Tool\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMột tài liệu về sản phẩm tham khảo và thông tin về OBDII: \u003ca href=\"/docs/OBD2_data_starter_pack.pdf\"\u003eOBD2 - Intro \u0026amp; Data Logger Guide\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"dtc-diagnostic-trouble-codes\"\u003eDTC (Diagnostic Trouble Codes)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDTC là \u003cstrong\u003ecác mã lỗi\u003c/strong\u003e mà hệ thống chẩn đoán OBD-II tạo ra khi phát hiện vấn đề về hoạt động của xe.\u003c/li\u003e\n\u003cli\u003eChúng giúp xác định nguyên nhân của các sự cố liên quan đến hệ thống động cơ, khí thải, và các thành phần khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pid-parameter-ids\"\u003ePID (Parameter IDs)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePID là \u003cstrong\u003ecác mã định danh tham số\u003c/strong\u003e được sử dụng để yêu cầu và nhận dữ liệu từ các cảm biến và hệ thống khác nhau trên xe.\u003c/li\u003e\n\u003cli\u003eDữ liệu này giúp theo dõi tình trạng hoạt động của xe, chẳng hạn như tốc độ xe, tốc độ động cơ, nhiệt độ chất làm mát, v.v.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"dtc-vs-pids\"\u003eDTC vs PIDs\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDTC để chẩn đoán lỗi. PID để giám sát dữ liệu\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVí dụ mình có dòng chip \u003cstrong\u003eSTN1110\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNếu cần lấy thông tin về xe thì mình dùng mã lệnh PID để gửi cho ECU, và nhận phản hồi từ ECU. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCòn DTC (mã lỗi) thì xe sẽ \u003cstrong\u003etự động tạo ra mã lỗi\u003c/strong\u003e này khi phát hiện vấn đề. Ví dụ, nếu xe của bạn gặp sự cố liên quan đến xi-lanh, ECU sẽ tạo ra mã lỗi P0301 và lưu trữ nó. khi bạn kết nối công cụ quét OBD-II (như STN1110) với cổng OBD-II của xe, \u003cstrong\u003ecông cụ này sẽ tự động đọc và hiển thị mã DTC mà ECU đã lưu trữ\u003c/strong\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"giới-thiệu-về-stn1110httpswwwobdsolcomsolutionschipsstn1110formmg0av3\"\u003eGiới thiệu về \u003ca href=\"https://www.obdsol.com/solutions/chips/stn1110/?form=MG0AV3\"\u003eSTN1110\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIC STN1110 là một OBD-II to UART interpreter IC (thiết bị trình dịch OBD-II sang UART)\u003c/li\u003e\n\u003cli\u003eThay vào đó, nó được sử dụng để chuyển đổi các thông điệp OBD-II thành các thông điệp UART, cho phép kết nối với các thiết bị khác như máy tính hoặc microcontroller thông qua giao tiếp UART.\u003c/li\u003e\n\u003cli\u003eNó hoạt động như một trung gian giúp truy xuất dữ liệu từ hệ thống OBD-II của xe, bao gồm các mã lỗi DTC, thông số hiệu suất, và nhiều thông tin khác.\u003c/li\u003e\n\u003cli\u003eĐể tạo ra một thiết bị tương tự như STN1110, bạn sẽ cần những thành phần cơ bản sau: \u003ccode\u003eMCU\u003c/code\u003e, \u003ccode\u003eCAN Controller\u003c/code\u003e, \u003ccode\u003eCAN Transceiver\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"tham-khảo-telematics-dashboards---visualize-can-datahttpswwwcsselectronicscompagestelematics-dashboard-open-source\"\u003eTham khảo \u003ca href=\"https://www.csselectronics.com/pages/telematics-dashboard-open-source\"\u003eTelematics Dashboards - Visualize CAN Data\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/Sample_OBDII_Dashboard.webp\"\n  alt=\"Sample_OBDII_Dashboard\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDashboard này nhìn đẹp, rất hay ho, thật sự đáng nghiên cứu và học hỏi.\u003c/li\u003e\n\u003cli\u003eVừa kết hợp được những \u003cstrong\u003ethông tin cơ bản lấy từ OBD2\u003c/strong\u003e, vừa kết hợp với \u003cstrong\u003ethông tin GPS của thiết bị tracking\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tổng-hợp-các-lệnh-pids-thường-dùng\"\u003eTổng hợp các lệnh PIDs thường dùng.\u003c/h2\u003e\n\u003ch3 id=\"nhiệt-độ-làm-mát-engine-coolant-temperature---tmp\"\u003eNhiệt độ làm mát (Engine Coolant Temperature - TMP)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/TMP.png\"\n  alt=\"TMP\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tốc-độ-động-cơ-engine-speed---rpm\"\u003eTốc độ động cơ (Engine speed - RPM)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/RPM.png\"\n  alt=\"RPM\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"tốc-độ-phương-tiện-vehicle-speed---spd\"\u003eTốc độ phương tiện (Vehicle speed - SPD)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/SPD.png\"\n  alt=\"SPD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"mass-air-flow-sensor-maf\"\u003eMass air flow sensor (MAF)\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OBD2_PIDs/MAF.png\"\n  alt=\"MAF\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"calculated-engine-load\"\u003eCalculated engine load\u003c/h3\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/obd2_pids/",
      "date_published": "11106-11-09T1023:1111:00+07:00",
      "date_modified": "11106-11-09T1023:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "cc904edd51e47395566e93d3d0857041c529937e",
      "title": "CAN_OBDII",
      "summary": "",
      "content_text": "CAN Bus: Serial Communication - How It Works? Controller Area Network (CAN hoặc CAN Bus) một giao thức truyền thông nối tiếp bất đồng bộ. Bus CAN chỉ có 2 dây giúp kết nối các module điều khiển với nhau dễ dàng hơn khi so sánh với cách làm truyền thống. Do trên ô tô tín hiệu bị nhiễu rất nhiều (sử dụng nhiều mô-tơ), nên CAN Protocol đã được phát triển để chống nhiễu. Ban đầu CAN được thiết kế dành cho ngành công nghiệp ô tô, tuy nhiên hiện nay CAN cũng đã trở thành một tiêu chuẩn phổ biến trong tự động hóa công nghiệp và các ngành khác. Bit Rate (Tốc độ truyền dữ liệu) và Transmission Distances (Khoảng cách truyền dữ liệu) CAN bus sử dụng các tốc độ truyền dữ liệu khác nhau, thường được tính bằng kilobit trên giây (kbps). Hình dưới là công thức: Tốc độ truyền dữ liệu càng cao thì lượng dữ liệu có thể truyền trong một khoảng thời gian càng lớn, nhưng lại có sự đánh đổi với khoảng cách truyền. Dưới đây là bảng biểu thị mối quan hệ giữa tốc độ truyền dữ liệu và khoảng cách truyền tối đa cho CAN bus: Ngoài tốc độ truyền và khoảng cách, một số yếu tố khác cũng có thể ảnh hưởng đến hiệu suất truyền dẫn trên CAN bus: Chất lượng dây cáp: Dây cáp có trở kháng phù hợp sẽ giúp tín hiệu truyền ổn định hơn. Nhiễu điện từ: Môi trường có nhiều nhiễu điện từ (EMI) có thể làm giảm chất lượng tín hiệu. Số lượng thiết bị trên bus: Mỗi thiết bị trên CAN bus sẽ tạo ra tải (load) và có thể ảnh hưởng đến hiệu suất tổng thể. CAN Bus Version CAN Transceiver CAN transceiver không thực hiện bất kỳ xử lý logic nào liên quan đến giao thức CAN mà chỉ làm nhiệm vụ chuyển đổi tín hiệu. Một ví dụ phổ biến về CAN transceiver là MCP2551 của Microchip, được sử dụng rất nhiều trong các ứng dụng CAN bus. Ngoài ra cũng có một số loại CAN Transceiver khác như: TJA1050 SN65HVD230 CAN Bus Controllers CAN bus Controller là một vi mạch tích hợp (IC) chứa tất cả các logic và khả năng xử lý dữ liệu để gửi và nhận các thông điệp CAN bus. Tuy nhiên, nó không có các chân đầu ra trực tiếp CAN_H và CAN_L (là các đường tín hiệu vật lý của CAN bus), mà thay vào đó chỉ có các chân TX và RX ở mức logic. Điều này có nghĩa là nó cần phải được kết nối với một CAN transceiver (bộ chuyển đổi CAN) để chuyển đổi tín hiệu logic thành tín hiệu vật lý trên CAN bus. Bởi vì CAN Controller chỉ hoạt động ở mức logic (0 và 1), cần có một CAN transceiver để chuyển đổi tín hiệu logic đó thành tín hiệu differential (tín hiệu vi sai) trên CAN_H và CAN_L (đây là hai dây tín hiệu của CAN bus). CAN Bus Microcontroller Peripherals: Nhiều vi điều khiển (MCU) hiện đại có tích hợp CAN controller như một phần peripheral bên trong. Ví dụ, các dòng vi điều khiển như STM32 hoặc ESP32 có thể chứa sẵn CAN controller trên chip. Điều này giúp giảm thiểu sự phức tạp trong thiết kế phần cứng vì không cần thêm một IC CAN controller bên ngoài. Mối quan hệ giữa CAN Controller và Transceiver: Như vậy, để giao tiếp hoàn chỉnh trên CAN bus, cả CAN controller và CAN transceiver đều cần thiết: CAN controller: Thực hiện các chức năng logic, quản lý giao thức CAN, và truyền/nhận dữ liệu qua các tín hiệu TX/RX ở mức logic. CAN transceiver: Chuyển đổi các tín hiệu logic từ CAN controller thành tín hiệu vi sai và ngược lại để tương tác với mạng CAN vật lý (CAN_H và CAN_L). Một thiết kế CAN bus điển hình sẽ bao gồm: Vi điều khiển (MCU): Gửi/nhận dữ liệu và điều khiển hệ thống. CAN Controller: Xử lý thông điệp CAN, giao tiếp với MCU qua các giao thức như SPI. CAN Transceiver: Chuyển đổi tín hiệu giữa CAN Controller và CAN bus. Tài liệu tham khảo: Tài liệu Car Hacking Tài liệu khác: https://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1727681723175\u0026amp;ref_url=https%253A%252F%252Fwww.google.com.sg%252F https://mesidas.com/can-canbus/ https://community.nxp.com/t5/NXP-Tech-Blog/101-Controller-Area-Network-CAN-standard/ba-p/1217054 https://www.typhoon-hil.com/documentation/typhoon-hil-software-manual/References/can_bus_protocol.html https://blog.mbedded.ninja/electronics/communication-protocols/can-protocol/ https://www.csselectronics.com/pages/can-bus-simple-intro-tutorial OBD Các bài viết liên quan: https://www.otosaigon.com/threads/huong-dan-chan-doan-loi-bang-may-quet-obd2-cho-nguoi-nghiep-du.9075318/ https://autoitech.vn/obd-ii-ma-loi-tren-o-to-phan-1/ https://vinfastauto.com/vn_vi/he-thong-obd-tren-o-to-va-nhung-dieu-can-biet https://www.thegioididong.com/hoi-dap/cong-obd-2-la-gi-cac-tien-ich-tu-cong-obd-2-tren-xe-o-to-1292647 OBD (On – Board Diagnostics), hay còn gọi là hệ thống chẩn đoán lỗi OBD, được trang bị trên ô tô để theo dõi và điều chỉnh một số hoạt động của phương tiện. Hệ thống này thu thập thông tin từ mạng lưới các cảm biến gắn cố định quanh xe, phát hiện lỗi hư hỏng và cảnh báo tới người lái nhằm kịp thời đưa ra phương án xử lý.\nCổng kết nối OBDII: Note Theo mình hiểu thì OBD là một chuẩn (gồm cổng kết nối, protocol) để các hãng xe làm theo quy chuẩn này. Mình liên tưởng điều này với bộ thiết bị GSHT, ví dụ với mỗi nhà phát hành một thiết bị GSHT thì sẽ có một bộ protocol của họ. Tuy nhiên các thiết bị GSHT này đều phải tuân theo QCVN31 (bao gồm công kết nối, protocol của bản tin). Khi tuân theo chuẩn chung này thì nhà nước, chính quyền có thể đọc thông tin từ thiết bị GSHT khi có vấn đề xảy ra. Nếu hiểu như vậy thì sẽ phân biệt và dễ hiểu hơn giữa CAN vs OBD. Tài liệu về mã lỗi trên OBDII https://www.obd-codes.com/ https://www.obd-codes.com/faq/obd2-codes-explained.php https://en.wikipedia.org/wiki/OBD-II_PIDs ",
      "content_html": "\u003ch2 id=\"can-bus-serial-communication---how-it-workshttpswwwyoutubecomwatchvjzsczrt9tto\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=JZSCzRT9TTo\"\u003eCAN Bus: Serial Communication - How It Works?\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_1.png\"\n  alt=\"CAN_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eController Area Network (CAN hoặc CAN Bus)\u003c/strong\u003e một giao thức truyền thông nối tiếp bất đồng bộ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_2.png\"\n  alt=\"CAN_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBus CAN chỉ có 2 dây giúp kết nối các module điều khiển với nhau dễ dàng hơn khi so sánh với cách làm truyền thống.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_3.png\"\n  alt=\"CAN_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDo trên ô tô tín hiệu bị nhiễu rất nhiều (sử dụng nhiều mô-tơ), nên \u003cstrong\u003eCAN Protocol\u003c/strong\u003e đã được phát triển để \u003cstrong\u003echống nhiễu\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eBan đầu CAN được thiết kế dành cho ngành công nghiệp ô tô, tuy nhiên hiện nay CAN cũng đã trở thành một tiêu chuẩn phổ biến trong tự động hóa công nghiệp và các ngành khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bit-rate-tốc-độ-truyền-dữ-liệu-và-transmission-distances-khoảng-cách-truyền-dữ-liệu\"\u003eBit Rate (Tốc độ truyền dữ liệu) và Transmission Distances (Khoảng cách truyền dữ liệu)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCAN bus sử dụng các tốc độ truyền dữ liệu khác nhau, thường được tính bằng kilobit trên giây (kbps).\u003c/li\u003e\n\u003cli\u003eHình dưới là công thức:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_4.png\"\n  alt=\"CAN_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTốc độ truyền dữ liệu càng cao thì lượng dữ liệu có thể truyền trong một khoảng thời gian càng lớn, nhưng lại có sự đánh đổi với \u003cstrong\u003ekhoảng cách truyền\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDưới đây là bảng biểu thị mối quan hệ giữa tốc độ truyền dữ liệu và khoảng cách truyền tối đa cho CAN bus:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_5.png\"\n  alt=\"CAN_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNgoài tốc độ truyền và khoảng cách, một số yếu tố khác cũng có thể ảnh hưởng đến hiệu suất truyền dẫn trên CAN bus:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eChất lượng dây cáp\u003c/strong\u003e: Dây cáp có trở kháng phù hợp sẽ giúp tín hiệu truyền ổn định hơn.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNhiễu điện từ\u003c/strong\u003e: Môi trường có nhiều nhiễu điện từ (EMI) có thể làm giảm chất lượng tín hiệu.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSố lượng thiết bị trên bus\u003c/strong\u003e: Mỗi thiết bị trên CAN bus sẽ tạo ra tải (load) và có thể ảnh hưởng đến hiệu suất tổng thể.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"can-bus-version\"\u003eCAN Bus Version\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_Bus_Version.png\"\n  alt=\"CAN_Bus_Version\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"can-transceiver\"\u003eCAN Transceiver\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCAN transceiver không thực hiện bất kỳ xử lý logic nào liên quan đến giao thức CAN mà chỉ làm nhiệm vụ chuyển đổi tín hiệu. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eMột ví dụ phổ biến về CAN transceiver là \u003ca href=\"https://ww1.microchip.com/downloads/en/devicedoc/20001667g.pdf\"\u003eMCP2551\u003c/a\u003e của Microchip, được sử dụng rất nhiều trong các ứng dụng CAN bus.\u003c/li\u003e\n\u003cli\u003eNgoài ra cũng có một số loại \u003cstrong\u003eCAN Transceiver\u003c/strong\u003e khác như:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.nxp.com/docs/en/data-sheet/TJA1050.pdf\"\u003eTJA1050\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.ti.com/lit/ds/symlink/sn65hvd230.pdf?ts=1727771231223\u0026amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FSN65HVD230%253Futm_source%253Dgoogle%2526utm_medium%253Dcpc%2526utm_campaign%253Dasc-null-null-GPN_EN-cpc-pf-google-soas%2526utm_content%253DSN65HVD230%2526ds_k%253DSN65HVD230+Datasheet%2526DCM%253Dyes%2526gad_source%253D1%2526gclid%253DCj0KCQjwu-63BhC9ARIsAMMTLXR7R_weCPL_OVEche7n0ns9PKmoIPJQEKCm7Smr_0-Ta597tHP5OdEaAt8jEALw_wcB%2526gclsrc%253Daw.ds\"\u003eSN65HVD230\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"can-bus-controllers\"\u003eCAN Bus Controllers\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCAN bus Controller\u003c/strong\u003e là một vi mạch tích hợp (IC) chứa tất cả các logic và khả năng xử lý dữ liệu để gửi và nhận các thông điệp CAN bus.\u003c/li\u003e\n\u003cli\u003eTuy nhiên, nó không có các chân đầu ra trực tiếp \u003ccode\u003eCAN_H\u003c/code\u003e và \u003ccode\u003eCAN_L\u003c/code\u003e (là các đường tín hiệu vật lý của CAN bus), mà thay vào đó chỉ có các chân TX và RX ở mức logic.\u003c/li\u003e\n\u003cli\u003eĐiều này có nghĩa là nó cần phải được kết nối với một CAN transceiver (bộ chuyển đổi CAN) để chuyển đổi tín hiệu logic thành tín hiệu vật lý trên CAN bus.\u003c/li\u003e\n\u003cli\u003eBởi vì CAN Controller chỉ hoạt động ở mức logic (0 và 1), cần có một CAN transceiver để chuyển đổi tín hiệu logic đó thành tín hiệu differential \u003cem\u003e(tín hiệu vi sai)\u003c/em\u003e trên \u003ccode\u003eCAN_H\u003c/code\u003e và \u003ccode\u003eCAN_L\u003c/code\u003e (đây là hai dây tín hiệu của CAN bus).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/CAN_6.png\"\n  alt=\"CAN_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCAN Bus Microcontroller Peripherals\u003c/strong\u003e: Nhiều vi điều khiển (MCU) hiện đại có tích hợp CAN controller như một phần peripheral bên trong.\nVí dụ, các dòng vi điều khiển như \u003cstrong\u003eSTM32\u003c/strong\u003e hoặc \u003cstrong\u003eESP32\u003c/strong\u003e có thể chứa sẵn CAN controller trên chip. Điều này giúp giảm thiểu sự phức tạp trong thiết kế phần cứng vì không cần thêm một IC CAN controller bên ngoài.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mối-quan-hệ-giữa-can-controller-và-transceiver\"\u003eMối quan hệ giữa CAN Controller và Transceiver:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNhư vậy, để giao tiếp hoàn chỉnh trên CAN bus, cả CAN controller và CAN transceiver đều cần thiết:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCAN controller\u003c/strong\u003e: Thực hiện các chức năng logic, quản lý giao thức CAN, và truyền/nhận dữ liệu qua các tín hiệu TX/RX ở mức logic.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCAN transceiver\u003c/strong\u003e: Chuyển đổi các tín hiệu logic từ CAN controller thành tín hiệu vi sai và ngược lại để tương tác với mạng CAN vật lý (\u003ccode\u003eCAN_H\u003c/code\u003e và \u003ccode\u003eCAN_L\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMột thiết kế CAN bus điển hình sẽ bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eVi điều khiển (MCU)\u003c/strong\u003e: Gửi/nhận dữ liệu và điều khiển hệ thống. \u003c/br\u003e\n\u003cstrong\u003eCAN Controller\u003c/strong\u003e: Xử lý thông điệp CAN, giao tiếp với MCU qua các giao thức như SPI. \u003c/br\u003e\n\u003cstrong\u003eCAN Transceiver\u003c/strong\u003e: Chuyển đổi tín hiệu giữa CAN Controller và CAN bus. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tài-liệu-tham-khảo\"\u003eTài liệu tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf\"\u003eTài liệu Car Hacking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu khác:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.ti.com/lit/an/sloa101b/sloa101b.pdf?ts=1727681723175\u0026amp;ref_url=https%253A%252F%252Fwww.google.com.sg%252F\nhttps://mesidas.com/can-canbus/\nhttps://community.nxp.com/t5/NXP-Tech-Blog/101-Controller-Area-Network-CAN-standard/ba-p/1217054\nhttps://www.typhoon-hil.com/documentation/typhoon-hil-software-manual/References/can_bus_protocol.html\nhttps://blog.mbedded.ninja/electronics/communication-protocols/can-protocol/\nhttps://www.csselectronics.com/pages/can-bus-simple-intro-tutorial\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"obd\"\u003eOBD\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác bài viết liên quan:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.otosaigon.com/threads/huong-dan-chan-doan-loi-bang-may-quet-obd2-cho-nguoi-nghiep-du.9075318/\nhttps://autoitech.vn/obd-ii-ma-loi-tren-o-to-phan-1/\nhttps://vinfastauto.com/vn_vi/he-thong-obd-tren-o-to-va-nhung-dieu-can-biet\nhttps://www.thegioididong.com/hoi-dap/cong-obd-2-la-gi-cac-tien-ich-tu-cong-obd-2-tren-xe-o-to-1292647\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eOBD (On – Board Diagnostics)\u003c/strong\u003e, hay còn gọi là hệ thống chẩn đoán lỗi OBD, được trang bị trên ô tô để theo dõi và điều chỉnh một số hoạt động của phương tiện. Hệ thống này thu thập thông tin từ mạng lưới các cảm biến gắn cố định quanh xe, phát hiện lỗi hư hỏng và cảnh báo tới người lái nhằm kịp thời đưa ra phương án xử lý.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/H%e1%bb%87_th%e1%bb%91ng_OBD.jpg\"\n  alt=\"OBD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCổng kết nối OBDII:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/CAN_OBDII/OBDII_Pinout.jpg\"\n  alt=\"OBD_pinout\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo mình hiểu thì OBD là một chuẩn (gồm cổng kết nối, protocol) để các hãng xe làm theo quy chuẩn này.\u003c/li\u003e\n\u003cli\u003eMình liên tưởng điều này với bộ thiết bị GSHT, ví dụ với mỗi nhà phát hành một thiết bị GSHT thì sẽ có một bộ protocol của họ.\u003c/li\u003e\n\u003cli\u003eTuy nhiên các thiết bị GSHT này đều phải tuân theo \u003cstrong\u003eQCVN31\u003c/strong\u003e (bao gồm công kết nối, protocol của bản tin). Khi tuân theo chuẩn chung này thì nhà nước, chính quyền có thể đọc thông tin từ thiết bị GSHT khi có vấn đề xảy ra.\u003c/li\u003e\n\u003cli\u003eNếu hiểu như vậy thì sẽ phân biệt và dễ hiểu hơn giữa \u003cstrong\u003eCAN vs OBD\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tài-liệu-về-mã-lỗi-trên-obdii\"\u003eTài liệu về mã lỗi trên OBDII\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.obd-codes.com/\nhttps://www.obd-codes.com/faq/obd2-codes-explained.php\nhttps://en.wikipedia.org/wiki/OBD-II_PIDs\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/can_obdii/",
      "date_published": "11106-11-09T1056:1111:00+07:00",
      "date_modified": "11106-11-09T1056:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1ba79970c01707fa06415de9e7b567c85620aa8e",
      "title": "DMA",
      "summary": "",
      "content_text": "Trong quá trình tìm hiểu lại về DMA, mình lại vô trình biết thêm một trang web chia sẻ kiến thức về Điện tử, Lập trình,\u0026hellip;\n👉 Website: Lập trình - Điện tử\nNgoài ra mình cũng tìm đc một bài viết khá hay, cũng liên quan một phần đến DMA.\n🌱 Bài viết Các kỹ thuật thiết kế luồng xử lý trong chương trình nhúng Đối với một số chương trình nhỏ, các chương trình mà các bạn mới thực hành (blink LED, đọc nút bấm, \u0026hellip;) có một đặc điểm chung, đó là chương trình đều liên tục thực thi, kiểm tra một số lệnh nào đó, trong vòng lặp while (1). Điều này dẫn đến nhiều nhược điểm, chẳng hạn: Những lệnh đứng sau phải đợi những lệnh đứng trước thực thi xong, như vậy có thể gây bỏ lỡ các sự kiện nếu kích thước chương trình lớn. 3 cách thiết kế luồng xử lý đơn giản nhất trong chương trình nhúng, đó là Polling, Interrupt, DMA. Polling Cách mà chúng ta vẫn hay làm như vậy, trong vòng lặp while(1), gọi là kỹ thuật Polling - liên tục kiểm tra, liên tục thực thi. Hin\nTuy nhiên, với các chương trình lớn, phức tạp hơn, đòi hỏi đáp ứng nhanh hơn, thì polling sẽ rất khó đáp ứng được. Polling trong các trường hợp này có thể gây mất các sự kiện Interrupt Hiểu đơn giản thay vì liên tục kiểm tra nút bấm, ta cài đặt cho nó là 1 ngắt. Thì khi bấm nút, chương trình sẽ bị gián đoạn, và CPU phải kiểm tra xem điều gì đang xảy ra Ưu điểm là Interrupt là giúp chương trình đáp ứng nhanh với những cái ta cần. Có thể sử dụng chế độ tiết kiệm năng lượng khi vi điều khiển không làm gì. Tuy nhiên, nhược điểm của nó là ta cần khống chế chương trình con thực thi ngắt ISR để tránh việc chương trình phục vụ một ngắt quá lâu. Lời khuyên là nên viết chương trình ISR càng ngắn về mặt thời gian càng tốt. DMA - Direct Memory Access Kỹ thuật này để sử dụng để truyền dữ liệu trực tiếp giữa bộ nhớ và ngoại vi mà không thông qua CPU (trong lúc này, CPU có thể làm việc khác nhờ thế tiết kiệm thời gian CPU rất nhiều). Trong hầu hết các thiết bị nhúng, các thiết bị ngoại vi không hỗ trợ truyền nhiều bit cùng lúc, với ngoại lệ là giao thức CAN. Thay vào đó, vi điều khiển (MCU) phải ghi từng byte một, và sau đó chờ cho đến khi thiết bị ngoại vi sẵn sàng để gửi byte tiếp theo. 💬 Cơ chế hoạt động thông thường của Core:\nHãy nhìn hình vẽ trên, CPU sẽ điều khiển việc transfer data giữa Peripheral (UART, I2C, SPI, \u0026hellip;) và bộ nhớ (RAM) qua các đường bus. Cơ chế này được hiểu như cơ chế Master - Slave, với CPU đóng vai trò là Master, Peripheral và Memory đóng vai trò như các slave. Nên việc giao tiếp giữa 2 Slave sẽ do Master điều khiển. Tuy nhiên với việc CPU phải làm thêm 1 công việc quan trọng khác - Fetch lệnh từ bộ nhớ (FLASH) để thực thi các lệnh của chương trình. Vì vậy, khi cần truyền dữ liệu liên tục giữa Peripheral và RAM, CPU sẽ bị chiếm dụng, và không có thời gian làm các công việc khác, hoặc có thể gây miss dữ liệu khi transfer. Chính vì vậy, hệ thống hỗ trợ một Master khác để chuyên làm công việc này, đó là DMA. 💬 Một số kiến trúc Vi điều khiển không hỗ trợ DMA (8051, AVR, PIC, \u0026hellip;), có thể sử dụng bộ chip ngoài DMAC - DMA Controller để thay thể. Ở đây chúng ta chỉ xét đến các dòng có hỗ trợ DMA nội, cụ thể là trong Vi điềuk khiển STM32.\nDMA cho phép MCU thiết lập một luồng truyền dữ liệu (gửi hoặc nhận) và sau đó chờ cho đến khi luồng truyền hoàn tất. Khi sử dụng DMA, sau khi bắt đầu, MCU không cần can thiệp cho đến khi việc truyền dữ liệu hoàn tất, có nghĩa là MCU có thể thực hiện các tính toán khác hoặc thiết lập các I/O khác trong khi luồng truyền đang diễn ra. Tài liệu tham khảo thêm về DMA https://github.com/embassy-rs/embassy/wiki https://www.laptrinhdientu.com/2022/04/DMA1.html ",
      "content_html": "\u003cp\u003eTrong quá trình tìm hiểu lại về \u003cstrong\u003eDMA\u003c/strong\u003e, mình lại vô trình biết thêm một trang web chia sẻ kiến thức về \u003cstrong\u003eĐiện tử, Lập trình,\u0026hellip;\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e👉 Website: \u003ca href=\"https://www.laptrinhdientu.com/\"\u003eLập trình - Điện tử\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eNgoài ra mình cũng tìm đc một bài viết khá hay, cũng liên quan một phần đến DMA.\u003c/p\u003e\n\u003ch2 id=\"-bài-viết-các-kỹ-thuật-thiết-kế-luồng-xử-lý-trong-chương-trình-nhúnghttpswwwlaptrinhdientucom202201embeddeddesignhtml\"\u003e🌱 Bài viết \u003ca href=\"https://www.laptrinhdientu.com/2022/01/EmbeddedDesign.html\"\u003eCác kỹ thuật thiết kế luồng xử lý trong chương trình nhúng\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eĐối với một số chương trình nhỏ, các chương trình mà các bạn mới thực hành (blink LED, đọc nút bấm, \u0026hellip;) có một đặc điểm chung, đó là chương trình đều liên tục thực thi, kiểm tra một số lệnh nào đó, trong vòng lặp while (1). Điều này dẫn đến nhiều nhược điểm, chẳng hạn: Những lệnh đứng sau phải đợi những lệnh đứng trước thực thi xong, như vậy có thể gây bỏ lỡ các sự kiện nếu kích thước chương trình lớn. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e3 cách thiết kế luồng xử lý đơn giản nhất trong chương trình nhúng, đó là \u003ccode\u003ePolling\u003c/code\u003e, \u003ccode\u003eInterrupt\u003c/code\u003e, \u003ccode\u003eDMA\u003c/code\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"polling\"\u003ePolling\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCách mà chúng ta vẫn hay làm như vậy, trong vòng lặp \u003cstrong\u003ewhile(1)\u003c/strong\u003e, gọi là kỹ thuật Polling - liên tục kiểm tra, liên tục thực thi.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_1.webp\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\nHin\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTuy nhiên, với các chương trình lớn, phức tạp hơn, đòi hỏi đáp ứng nhanh hơn, thì polling sẽ rất khó đáp ứng được. Polling trong các trường hợp này có thể gây mất các sự kiện\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"interrupt\"\u003eInterrupt\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiểu đơn giản thay vì liên tục kiểm tra nút bấm, ta cài đặt cho nó là 1 ngắt.\u003c/li\u003e\n\u003cli\u003eThì khi bấm nút, chương trình sẽ bị gián đoạn, và CPU phải kiểm tra xem điều gì đang xảy ra\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_2.webp\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eƯu điểm là Interrupt là giúp chương trình đáp ứng nhanh với những cái ta cần. Có thể sử dụng chế độ tiết kiệm năng lượng khi vi điều khiển không làm gì.\u003c/li\u003e\n\u003cli\u003eTuy nhiên, nhược điểm của nó là ta cần khống chế chương trình con thực thi ngắt ISR để tránh việc chương trình phục vụ một ngắt quá lâu. Lời khuyên là nên viết chương trình ISR càng ngắn về mặt thời gian càng tốt.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"markdma---direct-memory-accessmark\"\u003e\u003cmark\u003eDMA - Direct Memory Access\u003c/mark\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKỹ thuật này để sử dụng để truyền dữ liệu trực tiếp giữa bộ nhớ và ngoại vi mà không thông qua CPU (trong lúc này, CPU có thể làm việc khác nhờ thế tiết kiệm thời gian CPU rất nhiều).\u003c/li\u003e\n\u003cli\u003eTrong hầu hết các thiết bị nhúng, các thiết bị ngoại vi không hỗ trợ truyền nhiều bit cùng lúc, với ngoại lệ là giao thức CAN. Thay vào đó, vi điều khiển (MCU) phải ghi từng byte một, và sau đó chờ cho đến khi thiết bị ngoại vi sẵn sàng để gửi byte tiếp theo.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e💬 Cơ chế hoạt động thông thường của Core:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_3.webp\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHãy nhìn hình vẽ trên, CPU sẽ điều khiển việc transfer data giữa Peripheral (UART, I2C, SPI, \u0026hellip;) và bộ nhớ (RAM) qua các đường bus. Cơ chế này được hiểu như cơ chế \u003cstrong\u003eMaster - Slave\u003c/strong\u003e, với CPU đóng vai trò là Master, Peripheral và Memory đóng vai trò như các slave. Nên việc giao tiếp giữa 2 Slave sẽ do Master điều khiển. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTuy nhiên với việc CPU phải làm thêm 1 công việc quan trọng khác - Fetch lệnh từ bộ nhớ (FLASH) để thực thi các lệnh của chương trình. Vì vậy, khi cần truyền dữ liệu liên tục giữa Peripheral và RAM, CPU sẽ bị chiếm dụng, và không có thời gian làm các công việc khác, hoặc có thể gây miss dữ liệu khi transfer. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eChính vì vậy, hệ thống hỗ trợ một \u003cstrong\u003eMaster\u003c/strong\u003e khác để chuyên làm công việc này, đó là \u003cstrong\u003eDMA\u003c/strong\u003e. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e💬 Một số kiến trúc Vi điều khiển không hỗ trợ DMA (8051, AVR, PIC, \u0026hellip;), có thể sử dụng bộ chip ngoài DMAC - DMA Controller để thay thể. Ở đây chúng ta chỉ xét đến các dòng có hỗ trợ DMA nội, cụ thể là trong Vi điềuk khiển STM32.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDMA cho phép MCU thiết lập một luồng truyền dữ liệu (gửi hoặc nhận) và sau đó chờ cho đến khi luồng truyền hoàn tất. Khi sử dụng DMA, sau khi bắt đầu, MCU không cần can thiệp cho đến khi việc truyền dữ liệu hoàn tất, có nghĩa là MCU có thể thực hiện các tính toán khác hoặc thiết lập các I/O khác trong khi luồng truyền đang diễn ra.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/DMA/Hinh_4.webp\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTài liệu tham khảo thêm về DMA\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/embassy-rs/embassy/wiki\nhttps://www.laptrinhdientu.com/2022/04/DMA1.html\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/dma/",
      "date_published": "11106-11-09T1021:1111:00+07:00",
      "date_modified": "11106-11-09T1021:1111:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "5339aede944e7541ae1695d5e04399522d2b95d3",
      "title": "Rust_for_ARM",
      "summary": "",
      "content_text": " Ngày Mô tả 10/10/2024 Khởi tạo bài viết, ghi chú về Rust for ARM 12/10/2024 Ghi chú thêm một số tài liệu về OpenWRT Hiện tại đã dùng Rust để code Bất đồng bộ.\nVới MCU thì dùng framework embassy Với Linux (hoặc Windows) thì dùng tokio Với framework tokio thì mình đã có một project nhỏ (tên là Tracking_Report), mục tiêu là build app để lấy thông tin trên NATS Server và gửi data lên ThingsBoard.\nTheo suy nghĩ đơn giản thì mình chỉ cần build code để chạy trên kiến trúc ARM là được. Nhưng khi dùng Cross Compilation để build thì lại lỗi tè le.\nChưa rõ lý do. Tạm thời sẽ documents lại những gì làm đc và những tài liệu liên quan.\nDocument lại Rust Cross Compilation cho ARM Mình có tìm được một project về Cross Compilation, tên là rust cross compilation Mình đã làm theo và test thử cho raspberry thì chạy được, nhưng khi áp dụng vào Tracking_Report thì build vẫn lỗi. Kiểm tra thông tin của Raspberry CM4 Kiểm tra phần cứng: cat /sys/firmware/devicetree/base/model Kiểm tra kiến trúc: lscpu Vậy phần cứng Raspberry CM4, thông tin: Model name: Cortex-A72 Architecture: armv7l Theo tài liệu trên github rust_cross_compilation thì: # For my armv7l embedded computer $ rustup target add armv7-unknown-linux-gnueabi # For my Raspberry Pi Zero W $ rustup target add arm-unknown-linux-gnueabihf Dựa trên platform support có thông tin: target std Note armv7-unknown-linux-gnueabi ✓ Armv7-A Linux (kernel 4.15, glibc 2.27) Setup trên máy Ubuntu Đầu tiên là cài rust cho linux (ở đây là máy Ubuntu). Sau đó mình cần cài đặt một số công cụ: rustup target add armv7-unknown-linux-gnueabi sudo apt install gcc-arm-linux-gnueabi Download project: git clone https://github.com/LOCNNIL/rust_cross_compilation.git cd rust_cross_compilation/ cargo build --target armv7-unknown-linux-gnueabi Lưu ý về file .cargo/config.toml: # target config for Embedded Computer with armv7l arch [target.armv7-unknown-linux-gnueabi] linker = \u0026#34;arm-linux-gnueabi-gcc\u0026#34; rustflags = [\u0026#34;-C\u0026#34;, \u0026#34;target-feature=+crt-static\u0026#34;] Sau đó copy file sang Pi: sudo scp target/armv7-unknown-linux-gnueabi/debug/cross-arm pi@192.168.10.100: Run on Pi Quay lại Pi, và chạy lệnh: ./cross-arm Đã chạy đc thành công. Tổng hợp một số tài liệu khác: https://www.acmesystems.it/arm9_toolchain https://harmonicss.co.uk/rust/rust-on-a-raspberry-pi-part-1/ Đây là một tutorial làm quen với việc viết OS cho Raspberry, tên project: rust-raspberrypi-OS-tutorials Ghi chú khác về armv7-unknown-linux-uclibceabi This target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U). Tức là khi code rust và build file với target là armv7-unknown-linux-uclibceabi thì có thể sẽ chạy được trên OpneWRT. Cập nhật 12/10/2024 Ghi chú tổng hợp một số tài liệu về OpenWRT cho Rust\nBuilding Rust code for my OpenWrt Wi-Fi router Đây là một ghi chú khác về cross compiling Rust programs ",
      "content_html": "\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e10/10/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết, ghi chú về Rust for ARM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e12/10/2024\u003c/td\u003e\n\u003ctd\u003eGhi chú thêm một số tài liệu về OpenWRT\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHiện tại đã dùng \u003cstrong\u003eRust\u003c/strong\u003e để code \u003cstrong\u003eBất đồng bộ\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVới MCU thì dùng framework \u003ca href=\"https://github.com/embassy-rs/embassy\"\u003eembassy\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eVới Linux (hoặc Windows) thì dùng \u003ca href=\"https://github.com/tokio-rs/tokio\"\u003etokio\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVới framework tokio thì mình đã có một project nhỏ \u003cem\u003e(tên là Tracking_Report)\u003c/em\u003e, mục tiêu là build app để lấy thông tin trên \u003cstrong\u003eNATS Server\u003c/strong\u003e và gửi data lên \u003cstrong\u003eThingsBoard\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTheo suy nghĩ đơn giản thì mình chỉ cần build code để chạy trên kiến trúc \u003cstrong\u003eARM\u003c/strong\u003e là được. Nhưng khi dùng \u003cstrong\u003eCross Compilation\u003c/strong\u003e để build thì lại \u003cstrong\u003elỗi tè le\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eChưa rõ lý do. Tạm thời sẽ documents lại những gì làm đc và những tài liệu liên quan.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"document-lại-rust-cross-compilation-cho-arm\"\u003eDocument lại Rust Cross Compilation cho ARM\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMình có tìm được một project về \u003cem\u003eCross Compilation\u003c/em\u003e, tên là \u003ca href=\"https://github.com/locnnil/rust_cross_compilation\"\u003erust cross compilation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMình đã làm theo và test thử cho raspberry thì chạy được, \u003cstrong\u003enhưng khi áp dụng vào Tracking_Report thì build vẫn lỗi\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kiểm-tra-thông-tin-của-raspberry-cm4\"\u003eKiểm tra thông tin của Raspberry CM4\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKiểm tra phần cứng:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecat /sys/firmware/devicetree/base/model\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eKiểm tra kiến trúc:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elscpu\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Rust_for_ARM/Hinh_1.png\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVậy phần cứng \u003cstrong\u003eRaspberry CM4\u003c/strong\u003e, thông tin:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eModel name: Cortex-A72\nArchitecture: armv7l\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTheo tài liệu trên github \u003ca href=\"https://github.com/locnnil/rust_cross_compilation\"\u003erust_cross_compilation\u003c/a\u003e thì:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# For my armv7l embedded computer\n$ rustup target add armv7-unknown-linux-gnueabi \n\n# For my Raspberry Pi Zero W\n$ rustup target add arm-unknown-linux-gnueabihf\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eDựa trên \u003ca href=\"https://doc.rust-lang.org/beta/rustc/platform-support.html\"\u003eplatform support\u003c/a\u003e có thông tin:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003etarget\u003c/th\u003e\n\u003cth\u003estd\u003c/th\u003e\n\u003cth\u003eNote\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003earmv7-unknown-linux-gnueabi\u003c/td\u003e\n\u003ctd\u003e✓\u003c/td\u003e\n\u003ctd\u003eArmv7-A Linux (kernel 4.15, glibc 2.27)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"setup-trên-máy-ubuntu\"\u003eSetup trên máy Ubuntu\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐầu tiên là cài rust cho linux \u003cem\u003e(ở đây là máy Ubuntu)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eSau đó mình cần cài đặt một số công cụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003erustup target add armv7-unknown-linux-gnueabi\nsudo apt install gcc-arm-linux-gnueabi\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eDownload project:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egit clone https://github.com/LOCNNIL/rust_cross_compilation.git\ncd rust_cross_compilation/\ncargo build --target armv7-unknown-linux-gnueabi\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eLưu ý về file \u003ccode\u003e.cargo/config.toml\u003c/code\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# target config for Embedded Computer with armv7l arch\n[target.armv7-unknown-linux-gnueabi]\nlinker = \u0026#34;arm-linux-gnueabi-gcc\u0026#34;\nrustflags = [\u0026#34;-C\u0026#34;, \u0026#34;target-feature=+crt-static\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eSau đó copy file sang Pi:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo scp target/armv7-unknown-linux-gnueabi/debug/cross-arm pi@192.168.10.100:\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"run-on-pi\"\u003eRun on Pi\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eQuay lại Pi, và chạy lệnh:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e./cross-arm\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐã chạy đc thành công.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Rust_for_ARM/Hinh_2.png\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"tổng-hợp-một-số-tài-liệu-khác\"\u003eTổng hợp một số tài liệu khác:\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.acmesystems.it/arm9_toolchain\nhttps://harmonicss.co.uk/rust/rust-on-a-raspberry-pi-part-1/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eĐây là một tutorial làm quen với việc \u003cstrong\u003eviết OS cho Raspberry\u003c/strong\u003e, tên project: \u003ca href=\"https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials\"\u003erust-raspberrypi-OS-tutorials\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ghi-chú-khác-về-armv7-unknown-linux-uclibceabihttpsdocrust-langorgrustcplatform-supportarmv7-unknown-linux-uclibceabihtml\"\u003eGhi chú khác về \u003ca href=\"https://doc.rust-lang.org/rustc/platform-support/armv7-unknown-linux-uclibceabi.html\"\u003earmv7-unknown-linux-uclibceabi\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis target supports Armv7-A softfloat CPUs and uses the uclibc-ng standard library. This is a common configuration on many consumer routers (e.g., Netgear R7000, Asus RT-AC68U). \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eTức là khi code rust và build file với target là \u003ccode\u003earmv7-unknown-linux-uclibceabi\u003c/code\u003e thì có thể sẽ chạy được trên \u003cstrong\u003eOpneWRT\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"cập-nhật-12102024\"\u003eCập nhật 12/10/2024\u003c/h2\u003e\n\u003cp\u003eGhi chú tổng hợp một số tài liệu về \u003ca href=\"https://openwrt.org/about\"\u003eOpenWRT\u003c/a\u003e cho Rust\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://blog.dend.ro/building-rust-for-routers/\"\u003eBuilding Rust code for my OpenWrt Wi-Fi router\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eĐây là một ghi chú khác về \u003ca href=\"https://github.com/japaric/rust-cross\"\u003ecross compiling Rust programs\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust_for_arm/",
      "date_published": "10106-10-09T1030:1010:00+07:00",
      "date_modified": "10106-10-09T1030:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a652262b2916c6795da636201503398e8ab0c326",
      "title": "Android_Automotive",
      "summary": "",
      "content_text": "Trong lúc lướt lát trên facebook, mình vô tình bắt gặp một bài viết Android Automotive Boot Process A-Z.\nTừ đó vô tình biết thêm được một trang chia sẻ kiến thức về mảng Automotive.\n👉Website: https://devlinux.vn/newest\nTrang tổng hợp các bài viết về Android Automotive Tổng quát về bài viết Android Automotive Boot Process A-Z Tóm tắt các bước chính trong quá trình khởi động Android: Boot ROM: Khi hệ thống bật nguồn, bộ nhớ ROM được kích hoạt đầu tiên. Đây là nơi chứa mã khởi động ban đầu giúp xác định thiết bị lưu trữ chứa phần mềm hệ điều hành.\nBootloader: Sau khi Boot ROM hoàn thành, Bootloader được tải lên để bắt đầu nạp kernel của hệ điều hành vào bộ nhớ.\nRead Boot Config: Bootloader đọc cấu hình khởi động từ các thiết bị lưu trữ (như thẻ SD, eMMC, USB).\nChọn thiết bị khởi động (Boot Device): Dựa trên cấu hình boot, hệ thống chọn thiết bị chứa kernel của hệ điều hành.\nKernel Linux: Kernel của Linux được tải và bắt đầu thực hiện các chức năng cốt lõi của hệ điều hành.\nAndroid Init Process: Quá trình khởi tạo của Android được thực hiện, bao gồm khởi chạy các dịch vụ cơ bản và phân quyền bằng SELinux.\nZygote Process: Zygote là một tiến trình quan trọng trong Android, khởi tạo các hệ thống máy ảo Dalvik/ART, giúp tạo ra các tiến trình ứng dụng.\nSystem Server: Khởi động các dịch vụ hệ thống Android như quản lý pin, cảm biến, dịch vụ mạng, dịch vụ quản lý ứng dụng và các dịch vụ liên quan đến phương tiện di chuyển.\nLauncher: Cuối cùng, Android khởi động giao diện người dùng chính (Launcher), nơi người dùng có thể tương tác với hệ thống.\n",
      "content_html": "\u003cp\u003eTrong lúc lướt lát trên facebook, mình vô tình bắt gặp một bài viết \u003cstrong\u003eAndroid Automotive Boot Process A-Z\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTừ đó vô tình biết thêm được một trang chia sẻ kiến thức về mảng Automotive.\u003c/p\u003e\n\u003cp\u003e👉Website: \u003ca href=\"https://devlinux.vn/newest\"\u003ehttps://devlinux.vn/newest\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"trang-tổng-hợp-các-bài-viết-về-android-automotivehttpsdevlinuxvnseriesbasic-android-automotive\"\u003eTrang tổng hợp các bài viết về \u003ca href=\"https://devlinux.vn/series/basic-android-automotive\"\u003eAndroid Automotive\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"tổng-quát-về-bài-viết-android-automotive-boot-process-a-zhttpsdevlinuxvnpostandroid-boot-process-a-z\"\u003eTổng quát về bài viết \u003ca href=\"https://devlinux.vn/post/android-boot-process-a-z\"\u003eAndroid Automotive Boot Process A-Z\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTóm tắt các bước chính trong quá trình khởi động Android: \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBoot ROM\u003c/strong\u003e: Khi hệ thống bật nguồn, bộ nhớ ROM được kích hoạt đầu tiên. Đây là nơi chứa mã khởi động ban đầu giúp xác định thiết bị lưu trữ chứa phần mềm hệ điều hành.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eBootloader\u003c/strong\u003e: Sau khi Boot ROM hoàn thành, Bootloader được tải lên để bắt đầu nạp kernel của hệ điều hành vào bộ nhớ.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eRead Boot Config\u003c/strong\u003e: Bootloader đọc cấu hình khởi động từ các thiết bị lưu trữ (như thẻ SD, eMMC, USB).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eChọn thiết bị khởi động (Boot Device)\u003c/strong\u003e: Dựa trên cấu hình boot, hệ thống chọn thiết bị chứa kernel của hệ điều hành.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eKernel Linux\u003c/strong\u003e: Kernel của Linux được tải và bắt đầu thực hiện các chức năng cốt lõi của hệ điều hành.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eAndroid Init Process\u003c/strong\u003e: Quá trình khởi tạo của Android được thực hiện, bao gồm khởi chạy các dịch vụ cơ bản và phân quyền bằng SELinux.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eZygote Process\u003c/strong\u003e: Zygote là một tiến trình quan trọng trong Android, khởi tạo các hệ thống máy ảo Dalvik/ART, giúp tạo ra các tiến trình ứng dụng.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSystem Server\u003c/strong\u003e: Khởi động các dịch vụ hệ thống Android như quản lý pin, cảm biến, dịch vụ mạng, dịch vụ quản lý ứng dụng và các dịch vụ liên quan đến phương tiện di chuyển.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eLauncher\u003c/strong\u003e: Cuối cùng, Android khởi động giao diện người dùng chính (Launcher), nơi người dùng có thể tương tác với hệ thống.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Android_Automotive_Boot_Process.jpg\"\n  alt=\"Boot_Process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/android_automotive/",
      "date_published": "7106-07-09T106:77:00+07:00",
      "date_modified": "7106-07-09T106:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c838ed435f6add572f7c3bd52057eae348c78374",
      "title": "Fault_Injection",
      "summary": "",
      "content_text": "Fault Injection là một kỹ thuật được sử dụng trong việc kiểm tra và đảm bảo độ tin cậy của các hệ thống phần mềm và phần cứng.\nMục đích của kỹ thuật này là cố tình tạo ra các lỗi hoặc điều kiện bất thường trong hệ thống để xem hệ thống sẽ phản ứng như thế nào, từ đó đánh giá được tính ổn định và khả năng xử lý lỗi của hệ thống.\nCó thể hiểu đơn giản rằng khi bạn phát triển một hệ thống, bạn luôn mong muốn nó hoạt động một cách hoàn hảo.\nNhưng trong thực tế, có nhiều yếu tố như lỗi phần cứng, lỗi phần mềm, hoặc những sự cố bất ngờ từ môi trường ngoài có thể ảnh hưởng đến hệ thống.\nFault injection giúp mô phỏng những tình huống này bằng cách cố tình đưa ra các lỗi, ví dụ như:\nLỗi phần cứng: Giả lập các vấn đề như bộ nhớ bị lỗi, đường truyền bị gián đoạn. Lỗi phần mềm: Gây ra lỗi trong code như chia cho 0, tràn bộ đệm (buffer overflow), hoặc làm hỏng dữ liệu. Điều kiện thời gian: Gây trễ (delay) hoặc thay đổi thời gian xử lý để kiểm tra khả năng xử lý của hệ thống trong những điều kiện bất lợi. Mục tiêu của Fault Injection là đảm bảo hệ thống có thể hoạt động tốt, hoặc ít nhất là không bị phá hỏng hoàn toàn, khi xảy ra các lỗi này.\nĐây là một phương pháp rất hữu ích trong việc tăng cường độ tin cậy và an toàn của các hệ thống, đặc biệt là trong các ứng dụng quan trọng như hàng không, ô tô, y tế, hay các hệ thống nhúng.\nBài viết How to voltage fault injection Trong quá trình đánh giá bảo mật vật lý của thiết bị IoT, một trong những mục tiêu là tận dụng giao diện gỡ lỗi của chip để có thể truy cập và nghiên cứu cách hoạt động của thiết bị. Một kịch bản lý tưởng là trích xuất toàn bộ hệ thống tệp để tìm cách giành quyền truy cập root vào thiết bị. Sau đó là kiểm tra những dịch vụ nào đang chạy, debug để cuối cùng là kiểm soát mục tiêu (target). Khi bắt đầu quá trình kiểm tra, chúng ta thường gặp phải các biện pháp bảo vệ trên giao diện gỡ lỗi cấm truy cập vào đầy đủ chức năng của nó hoặc trên chuỗi khởi động cấm bất kỳ sửa đổi nào trên đó. Glitching là một cách để cố gắng vượt qua loại bảo vệ này. Glitching Glitching là một kỹ thuật tấn công trong bảo mật, trong đó kẻ tấn công cố tình gây ra sự cố hoặc nhiễu trong hệ thống để tạo ra các hành vi bất thường. Phương pháp này thường áp dụng cho các vi điều khiển hoặc thiết bị nhúng, nơi mà việc gây nhiễu tạm thời vào nguồn điện, xung nhịp, hoặc các tín hiệu khác có thể khiến hệ thống thực hiện các lệnh sai hoặc bỏ qua các bước kiểm tra an ninh. Điều này có thể dẫn đến việc tiết lộ thông tin nhạy cảm hoặc truy cập trái phép. ",
      "content_html": "\u003cp\u003e\u003cstrong\u003eFault Injection\u003c/strong\u003e là một kỹ thuật được sử dụng trong việc kiểm tra và đảm bảo độ tin cậy của các hệ thống phần mềm và phần cứng.\u003c/p\u003e\n\u003cp\u003eMục đích của kỹ thuật này là cố tình tạo ra các lỗi hoặc điều kiện bất thường trong hệ thống để xem hệ thống sẽ phản ứng như thế nào, từ đó đánh giá được tính ổn định và khả năng xử lý lỗi của hệ thống.\u003c/p\u003e\n\u003cp\u003eCó thể hiểu đơn giản rằng khi bạn phát triển một hệ thống, bạn luôn mong muốn nó hoạt động một cách hoàn hảo.\u003c/p\u003e\n\u003cp\u003eNhưng trong thực tế, có nhiều yếu tố như lỗi phần cứng, lỗi phần mềm, hoặc những sự cố bất ngờ từ môi trường ngoài có thể ảnh hưởng đến hệ thống.\u003c/p\u003e\n\u003cp\u003eFault injection giúp mô phỏng những tình huống này bằng cách cố tình đưa ra các lỗi, ví dụ như:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eLỗi phần cứng\u003c/strong\u003e: Giả lập các vấn đề như bộ nhớ bị lỗi, đường truyền bị gián đoạn. \u003c/br\u003e\n\u003cstrong\u003eLỗi phần mềm\u003c/strong\u003e: Gây ra lỗi trong code như chia cho 0, tràn bộ đệm (buffer overflow), hoặc làm hỏng dữ liệu. \u003c/br\u003e\n\u003cstrong\u003eĐiều kiện thời gian\u003c/strong\u003e: Gây trễ (delay) hoặc thay đổi thời gian xử lý để kiểm tra khả năng xử lý của hệ thống trong những điều kiện bất lợi. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMục tiêu của Fault Injection là đảm bảo hệ thống có thể hoạt động tốt, hoặc ít nhất là không bị phá hỏng hoàn toàn, khi xảy ra các lỗi này.\u003c/p\u003e\n\u003cp\u003eĐây là một phương pháp rất hữu ích trong việc tăng cường độ tin cậy và an toàn của các hệ thống, đặc biệt là trong các ứng dụng quan trọng như hàng không, ô tô, y tế, hay các hệ thống nhúng.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.techtarget.com/rms/onlineimages/whatis-fault_injection_testing.png\"\n  alt=\"Fault Injection\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"bài-viết-how-to-voltage-fault-injectionhttpswwwsynacktivcompublicationshow-to-voltage-fault-injection\"\u003eBài viết \u003ca href=\"https://www.synacktiv.com/publications/how-to-voltage-fault-injection\"\u003eHow to voltage fault injection\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTrong quá trình đánh giá bảo mật vật lý của thiết bị IoT, một trong những mục tiêu là \u003cstrong\u003etận dụng giao diện gỡ lỗi\u003c/strong\u003e của chip để có thể truy cập và nghiên cứu cách hoạt động của thiết bị. \u003c/br\u003e\nMột kịch bản lý tưởng là trích xuất toàn bộ hệ thống tệp để \u003cstrong\u003etìm cách giành quyền truy cập root vào thiết bị\u003c/strong\u003e. Sau đó là \u003cem\u003ekiểm tra những dịch vụ nào đang chạy\u003c/em\u003e, \u003cem\u003edebug\u003c/em\u003e để cuối cùng là kiểm soát mục tiêu (target). \u003c/br\u003e\nKhi bắt đầu quá trình kiểm tra, chúng ta thường gặp phải các biện pháp bảo vệ trên giao diện gỡ lỗi cấm truy cập vào đầy đủ chức năng của nó hoặc trên chuỗi khởi động cấm bất kỳ sửa đổi nào trên đó. \u003c/br\u003e\n\u003ccode\u003eGlitching\u003c/code\u003e là một cách để cố gắng vượt qua loại bảo vệ này. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"glitching\"\u003eGlitching\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGlitching là một kỹ thuật tấn công trong bảo mật, trong đó kẻ tấn công cố tình gây ra sự cố hoặc nhiễu trong hệ thống để tạo ra các hành vi bất thường.\u003c/li\u003e\n\u003cli\u003ePhương pháp này thường áp dụng cho các vi điều khiển hoặc thiết bị nhúng, nơi mà việc gây nhiễu tạm thời vào nguồn điện, xung nhịp, hoặc các tín hiệu khác có thể khiến hệ thống thực hiện các lệnh sai hoặc bỏ qua các bước kiểm tra an ninh.\u003c/li\u003e\n\u003cli\u003eĐiều này có thể dẫn đến việc tiết lộ thông tin nhạy cảm hoặc truy cập trái phép.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/fault_injection/",
      "date_published": "5106-05-09T1013:55:00+07:00",
      "date_modified": "5106-05-09T1013:55:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a4fba5c94b9684813ebdfb7f5ee87834050fd32",
      "title": "Car_Hacking",
      "summary": "",
      "content_text": "Book: The Car Hacker Handbook Trong quá trình tìm hiểu về CAN - OBDII vô tình lụm được tài liệu về Car Hacking.\nCó những thông tin, kiến thức mà thông thường tìm hiểu về CAN-Bus sẽ không thấy. Từ những key-work này lại tiếp tục research thêm, và có thêm được những thông tin thú vị khác.\nCAN Bus Packet Điểm đặc trưng của CAN bus là các gói tin được phát quảng bá (broadcast) đến tất cả các thiết bị (controllers) trên cùng mạng, giống như cách UDP hoạt động trên mạng Ethernet.\nMột số vấn đề chính liên quan đến cơ chế này:\nPhát quảng bá trên CAN bus Trong mạng CAN bus, các gói tin (packets) được gửi ra sẽ không chỉ định đích cụ thể cho một thiết bị nào mà thay vào đó, tất cả các node (thiết bị) trên bus sẽ nhận được gói tin đó. Điều này có nghĩa là:\nMọi thiết bị trên cùng một mạng CAN đều nhìn thấy mọi gói tin. Các thiết bị sẽ tự quyết định liệu có xử lý gói tin hay bỏ qua nó, dựa trên ID của gói tin. Gói tin chứa một trường ID (identifier) để các thiết bị nhận diện loại dữ liệu và quyết định liệu nó có phải xử lý thông tin hay không. Không có thông tin về nguồn gốc của gói tin Các gói tin trên CAN bus không chứa thông tin về nguồn gốc (tức là không có địa chỉ của thiết bị gửi), mà chỉ có ID của thông điệp. Điều này tạo ra một số vấn đề:\nKhông có cách để biết được thiết bị nào đã gửi gói tin, điều này có thể gây ra khó khăn trong việc giám sát và bảo mật. Giả lập thiết bị khác: Bất kỳ thiết bị nào trên mạng CAN đều có thể gửi gói tin với ID bất kỳ. Điều này có nghĩa là nếu một thiết bị hoặc một kẻ tấn công muốn giả lập một thiết bị khác, họ có thể dễ dàng gửi các gói tin với ID của thiết bị cần giả lập, khiến các thiết bị khác nghĩ rằng dữ liệu đến từ thiết bị chính thức. Tấn công trên CAN bus Do tính chất mở và phát quảng bá của CAN bus, nó dễ trở thành mục tiêu cho các cuộc tấn công:\nTấn công giả lập (Spoofing): Như đã nêu, kẻ tấn công có thể gửi các gói tin giả mạo từ một thiết bị khác mà các node khác không thể phân biệt được, vì CAN không có cách để xác minh nguồn gốc của gói tin. Tấn công phát ngập (Flooding): Kẻ tấn công có thể phát liên tục các gói tin với độ ưu tiên cao, làm tắc nghẽn mạng, ngăn các thiết bị khác truyền thông tin. Tấn công từ chối dịch vụ (DoS): Bằng cách phát đi các gói tin không hợp lệ hoặc giả mạo, kẻ tấn công có thể làm gián đoạn hoạt động của hệ thống CAN. Bảo mật hạn chế trên CAN bus Do CAN bus ban đầu được thiết kế cho các hệ thống nhúng không kết nối với bên ngoài (như ô tô, máy móc công nghiệp), bảo mật không được ưu tiên trong thiết kế của giao thức:\nKhông có cơ chế xác thực: CAN bus không có cơ chế tích hợp để xác thực nguồn gốc của các gói tin. Không có mã hóa: Dữ liệu truyền trên CAN bus không được mã hóa, vì vậy bất kỳ thiết bị nào trên mạng cũng có thể đọc được toàn bộ nội dung của các gói tin. Giải pháp bảo mật Vì các vấn đề bảo mật vốn có của CAN bus, các giải pháp bảo mật cần được thiết kế thêm ở cấp độ ứng dụng hoặc hệ thống, bao gồm:\nXác thực gói tin: Sử dụng các giải pháp xác thực ở mức ứng dụng để kiểm tra xem gói tin có được gửi từ nguồn tin cậy không. Mã hóa dữ liệu: Mặc dù CAN bus không hỗ trợ mã hóa dữ liệu nội tại, các giải pháp mã hóa có thể được thêm vào ở lớp ứng dụng để bảo vệ dữ liệu nhạy cảm. Giám sát mạng CAN: Các hệ thống giám sát (IDS/IPS) có thể được sử dụng để phát hiện các hành vi bất thường trên mạng, như tấn công phát ngập hoặc giả lập thiết bị. Tools SocketCAN SocketCAN là một framework trong Linux giúp quản lý và giao tiếp với CAN bus thông qua giao diện lập trình socket, giống như cách xử lý các giao tiếp mạng khác như Ethernet. Nó giúp lập trình viên dễ dàng sử dụng CAN bus mà không cần phải tìm hiểu các giao thức phức tạp hoặc các driver riêng biệt.\nInstall can-utils: sudo apt-get install can-utils Nhìn chung đây là một công cụ phần mềm dành cho CAN-Bus (giống như công cụ minicom dành cho cổng Serial). Do đó mình sẽ cần một thiết bị phần cứng để giao tiếp CAN-Bus, giống như trong video MCP2515 CAN Bus Module Tutorial with Arduino and Linux Wireshark Đây là công cụ quá phổ biến cho việc bắt gói tin. Do đó mình có thể dùng wireshark để bắt gói tin của CAN. Để bắt được gói tin CAN, thì mình cần dùng kết hợp giữa SocketCAN với Wireshark. Đôi khi wireshark không thể lắng nghe thiết bị slcanX, do đó mình sẽ cần dùng các command có trong bộ công cụ can-utils: candump cansniffer Kayak is an application for CAN bus diagnosis and monitoring. Github Project Kayak- tutorial Features: - view raw CAN data on a bus - view CAN frames interpreted as signals and messages - XML-based bus definitions - connect to to multiple CAN busses on different machines at once - multiple users can connect to the same CAN bus using a single CAN controller - no platform dependend code - core library without dependencies for use in other applications that need to handle CAN frames - rich client application (Netbeans RCP) - easily write your own plugins using the Netbeans plugin system ECUsim OBD simulator ECUsim 2000: Simulators can generate faults and MIL lights, and they include fault knobs for changing common vehicle parameters, such as speed.\nDocument: ECUsim 2000 User Guide Document: ECUsim Programming Manual Other Documents OBD CAN Bus Equipped Vehicles ECU PIN-OUT DIAGRAMS ChipWhisperer getting-started Documentation Home Education \u0026amp; Training ",
      "content_html": "\u003ch1 id=\"book-the-car-hacker-handbookhttpsdocsalexomarcombibliotecathecarhackershandbookpdf\"\u003eBook: \u003ca href=\"https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf\"\u003eThe Car Hacker Handbook\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Car_Hacking/Car_Hacking.jpg\"\n  alt=\"Car Hacking\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eTrong quá trình tìm hiểu về \u003ccode\u003eCAN - OBDII\u003c/code\u003e vô tình \u003cstrong\u003elụm\u003c/strong\u003e được tài liệu về \u003cstrong\u003eCar Hacking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCó những thông tin, kiến thức mà thông thường tìm hiểu về CAN-Bus sẽ không thấy. Từ những \u003cstrong\u003ekey-work\u003c/strong\u003e này lại tiếp tục research thêm, và có thêm được những thông tin thú vị khác.\u003c/p\u003e\n\u003ch2 id=\"can-bus-packet\"\u003eCAN Bus Packet\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Car_Hacking/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐiểm đặc trưng của CAN bus là các gói tin được phát quảng bá \u003cstrong\u003e(broadcast)\u003c/strong\u003e đến tất cả các thiết bị (controllers) trên cùng mạng, giống như cách UDP hoạt động trên mạng Ethernet.\u003c/p\u003e\n\u003cp\u003eMột số vấn đề chính liên quan đến cơ chế này:\u003c/p\u003e\n\u003ch3 id=\"phát-quảng-bá-trên-can-bus\"\u003ePhát quảng bá trên CAN bus\u003c/h3\u003e\n\u003cp\u003eTrong mạng CAN bus, các gói tin (packets) được gửi ra sẽ không chỉ định đích cụ thể cho một thiết bị nào mà thay vào đó, tất cả các node (thiết bị) trên bus sẽ nhận được gói tin đó. Điều này có nghĩa là:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eMọi thiết bị trên cùng một mạng CAN đều nhìn thấy mọi gói tin\u003c/strong\u003e. \u003c/br\u003e\nCác thiết bị sẽ tự quyết định liệu có xử lý gói tin hay bỏ qua nó, dựa trên ID của gói tin. Gói tin chứa một trường ID (identifier) để các thiết bị nhận diện loại dữ liệu và quyết định liệu nó có phải xử lý thông tin hay không. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"không-có-thông-tin-về-nguồn-gốc-của-gói-tin\"\u003eKhông có thông tin về nguồn gốc của gói tin\u003c/h3\u003e\n\u003cp\u003eCác gói tin trên CAN bus không chứa thông tin về nguồn gốc (tức là không có địa chỉ của thiết bị gửi), mà chỉ có ID của thông điệp. Điều này tạo ra một số vấn đề:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eKhông có cách để biết được thiết bị nào đã gửi gói tin\u003c/strong\u003e, điều này có thể gây ra khó khăn trong việc giám sát và bảo mật. \u003c/br\u003e\n\u003cstrong\u003eGiả lập thiết bị khác\u003c/strong\u003e: Bất kỳ thiết bị nào trên mạng CAN đều có thể gửi gói tin với ID bất kỳ. Điều này có nghĩa là nếu một thiết bị hoặc một kẻ tấn công muốn giả lập một thiết bị khác, họ có thể dễ dàng gửi các gói tin với ID của thiết bị cần giả lập, khiến các thiết bị khác nghĩ rằng dữ liệu đến từ thiết bị chính thức. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"tấn-công-trên-can-bus\"\u003eTấn công trên CAN bus\u003c/h3\u003e\n\u003cp\u003eDo tính chất mở và phát quảng bá của CAN bus, nó dễ trở thành mục tiêu cho các cuộc tấn công:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTấn công giả lập (Spoofing)\u003c/strong\u003e: Như đã nêu, kẻ tấn công có thể gửi các gói tin giả mạo từ một thiết bị khác mà các node khác không thể phân biệt được, vì CAN không có cách để xác minh nguồn gốc của gói tin. \u003c/br\u003e\n\u003cstrong\u003eTấn công phát ngập (Flooding)\u003c/strong\u003e: Kẻ tấn công có thể phát liên tục các gói tin với độ ưu tiên cao, làm tắc nghẽn mạng, ngăn các thiết bị khác truyền thông tin. \u003c/br\u003e\n\u003cstrong\u003eTấn công từ chối dịch vụ (DoS)\u003c/strong\u003e: Bằng cách phát đi các gói tin không hợp lệ hoặc giả mạo, kẻ tấn công có thể làm gián đoạn hoạt động của hệ thống CAN. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"bảo-mật-hạn-chế-trên-can-bus\"\u003eBảo mật hạn chế trên CAN bus\u003c/h3\u003e\n\u003cp\u003eDo CAN bus ban đầu được thiết kế cho các hệ thống nhúng không kết nối với bên ngoài (như ô tô, máy móc công nghiệp), bảo mật không được ưu tiên trong thiết kế của giao thức:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eKhông có cơ chế xác thực\u003c/strong\u003e: CAN bus không có cơ chế tích hợp để xác thực nguồn gốc của các gói tin. \u003c/br\u003e\n\u003cstrong\u003eKhông có mã hóa\u003c/strong\u003e: Dữ liệu truyền trên CAN bus không được mã hóa, vì vậy bất kỳ thiết bị nào trên mạng cũng có thể đọc được toàn bộ nội dung của các gói tin. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"giải-pháp-bảo-mật\"\u003eGiải pháp bảo mật\u003c/h3\u003e\n\u003cp\u003eVì các vấn đề bảo mật vốn có của CAN bus, các giải pháp bảo mật cần được thiết kế thêm ở cấp độ ứng dụng hoặc hệ thống, bao gồm:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eXác thực gói tin\u003c/strong\u003e: Sử dụng các giải pháp xác thực ở mức ứng dụng để kiểm tra xem gói tin có được gửi từ nguồn tin cậy không. \u003c/br\u003e\n\u003cstrong\u003eMã hóa dữ liệu\u003c/strong\u003e: Mặc dù CAN bus không hỗ trợ mã hóa dữ liệu nội tại, các giải pháp mã hóa có thể được thêm vào ở lớp ứng dụng để bảo vệ dữ liệu nhạy cảm. \u003c/br\u003e\n\u003cstrong\u003eGiám sát mạng CAN\u003c/strong\u003e: Các hệ thống giám sát (IDS/IPS) có thể được sử dụng để phát hiện các hành vi bất thường trên mạng, như tấn công phát ngập hoặc giả lập thiết bị. \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"tools\"\u003eTools\u003c/h2\u003e\n\u003ch3 id=\"socketcan\"\u003eSocketCAN\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSocketCAN là một framework trong Linux giúp quản lý và giao tiếp với CAN bus thông qua giao diện lập trình socket, giống như cách xử lý các giao tiếp mạng khác như Ethernet. Nó giúp lập trình viên dễ dàng sử dụng CAN bus mà không cần phải tìm hiểu các giao thức phức tạp hoặc các driver riêng biệt.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Car_Hacking/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstall \u003ca href=\"https://github.com/linux-can/can-utils\"\u003ecan-utils\u003c/a\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo apt-get install can-utils\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eNhìn chung đây là một công cụ phần mềm dành cho CAN-Bus \u003cem\u003e(giống như công cụ minicom dành cho cổng Serial)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eDo đó mình sẽ cần một \u003ca href=\"https://www.amazon.com/dp/B07P9JGXXB?ref=ppx_yo2ov_dt_b_product_details\u0026amp;th=1\"\u003ethiết bị phần cứng\u003c/a\u003e để giao tiếp CAN-Bus, giống như trong video \u003ca href=\"https://www.youtube.com/watch?v=GA-KNEuAR9w\"\u003eMCP2515 CAN Bus Module Tutorial with Arduino and Linux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"wireshark\"\u003eWireshark\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là công cụ quá phổ biến cho việc bắt gói tin.\u003c/li\u003e\n\u003cli\u003eDo đó mình có thể dùng \u003cem\u003ewireshark\u003c/em\u003e để bắt gói tin của CAN.\u003c/li\u003e\n\u003cli\u003eĐể bắt được gói tin CAN, thì mình cần dùng kết hợp giữa \u003cstrong\u003eSocketCAN\u003c/strong\u003e với \u003cstrong\u003eWireshark\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐôi khi wireshark không thể lắng nghe thiết bị \u003ccode\u003eslcanX\u003c/code\u003e, do đó mình sẽ cần dùng các command có trong bộ công cụ \u003cstrong\u003ecan-utils\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecandump\ncansniffer\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"kayakhttpsdschanoehgithubiokayak-is-an-application-for-can-bus-diagnosis-and-monitoring\"\u003e\u003ca href=\"https://dschanoeh.github.io/Kayak/\"\u003eKayak\u003c/a\u003e is an application for CAN bus diagnosis and monitoring.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/dschanoeh/Kayak\"\u003eGithub Project\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dschanoeh.github.io/Kayak/tutorial.html\"\u003eKayak- tutorial\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eFeatures:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- view raw CAN data on a bus\n- view CAN frames interpreted as signals and messages\n- XML-based bus definitions\n- connect to to multiple CAN busses on different machines at once\n- multiple users can connect to the same CAN bus using a single CAN controller\n- no platform dependend code\n- core library without dependencies for use in other applications that need to handle CAN frames\n- rich client application (Netbeans RCP)\n- easily write your own plugins using the Netbeans plugin system\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"ecusim-obd-simulator\"\u003eECUsim OBD simulator\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.obdsol.com/solutions/development-tools/obd-simulators/ecusim-2000/\"\u003eECUsim 2000\u003c/a\u003e: Simulators can generate faults and MIL lights, and they include fault knobs for changing common vehicle parameters, such as speed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.scantool.net/static/images/products/ecusim_2000/ecusim_2000_diagram_web.png\"\n  alt=\"ECUsim 2000\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDocument: \u003ca href=\"https://www.scantool.net/scantool/downloads/101/ecusim_2000-ug.pdf\"\u003eECUsim 2000 User Guide\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocument: \u003ca href=\"https://www.scantool.net/static/documentation/ecusim/ecusim-pm.pdf\"\u003eECUsim Programming Manual\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"other-documents\"\u003eOther Documents\u003c/h2\u003e\n\u003ch3 id=\"obd-can-bus-equipped-vehicleshttpwwwauterrawebcomaboutcanhtml\"\u003e\u003ca href=\"http://www.auterraweb.com/aboutcan.html\"\u003eOBD CAN Bus Equipped Vehicles\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"ecu-pin-out-diagramshttpswwwinnovatemotorsportscomecu-pin-out-diagrams\"\u003e\u003ca href=\"https://www.innovatemotorsports.com/ecu-pin-out-diagrams/\"\u003eECU PIN-OUT DIAGRAMS\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"chipwhispererhttpswwwnewaecomchipwhisperer\"\u003e\u003ca href=\"https://www.newae.com/chipwhisperer\"\u003eChipWhisperer\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://chipwhisperer.readthedocs.io/en/latest/getting-started.html\"\u003egetting-started\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://rtfm.newae.com/\"\u003eDocumentation Home\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.newae.com/education\"\u003eEducation \u0026amp; Training\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/car_hacking/",
      "date_published": "5106-05-09T1055:55:00+07:00",
      "date_modified": "5106-05-09T1055:55:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1d6e1d9d82c5e034cbee811a39d8ea0cdf4dfb8b",
      "title": "Rust Lang",
      "summary": "",
      "content_text": " Ngày Mô tả 1/4/2024 Khởi tạo bài viết 17/8/2024 Cập nhật bài viết, thêm thông tin về Rust-lang 13/9/2024 Update thêm documents về Rust Hạn chế Năm 2023 xảy ra nhiều dramma của Rust Found Rust là ngôn ngữ khó học, code khó. 5 things I wish I knew before learning Rust Why do developers hate Rust? Cộng đồng DEV chưa quá đông như Golang. Top Programming Languages 2023 Lợi ích Rust là ngôn ngữ low level, được sử dụng cho nhiều mục đích khác nhau: Dùng để code nhúng. Dùng để code phía Server. Có thể dùng để code OS - như Rust for Linux Rust chú trọng vào sự an toàn - memory safety. Cộng đồng Rust vẫn đang phát triển. Dựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang Rust Roadmap Tài liệu về Rust Rust IDE - RustRover\nThe Embedded Rust Book\nStandard library developers Guide\nBlog Rust\nRust By Example\nRust Tiếng Việt\nYoutube - Crust of Rust\nYoutube - Let\u0026rsquo;s Get Rusty\nRust Cheatsheet\nWriting an OS in Rust\nCập nhật 17/8/2024 Youtube: Where is Rust being used? Tổng hợp Rust is for Robotics Project ros2_rust Project CleanIt Doc: Offline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard nostd-wifi-lamp esp32c3-no-std-async-mqtt-demo Framework cho MQTT cho Rust: rumqtt rust-mqtt Framework NATS for Rust: nats.rs Có thể sử dụng NATS cho ThingsBoard. Sample code từ ChatGPT: use nats::asynk::Connection; use serde::{Deserialize, Serialize}; use serde_json::json; use tokio::time::{sleep, Duration}; #[derive(Debug, Serialize, Deserialize)] struct TelemetryData { device_id: String, temperature: f64, humidity: f64, timestamp: u64, } #[tokio::main] async fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { // Connect to the NATS server let nc: Connection = nats::asynk::connect(\u0026#34;demo.nats.io\u0026#34;).await?; // Subscribe to a subject where ThingsBoard publishes telemetry data let subscription = nc.subscribe(\u0026#34;thingsboard.telemetry\u0026#34;).await?; // Process incoming messages while let Some(msg) = subscription.next().await { // Parse the telemetry data (assumed to be JSON) let telemetry: TelemetryData = serde_json::from_slice(\u0026amp;msg.data).expect(\u0026#34;Failed to parse telemetry data\u0026#34;); println!(\u0026#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}\u0026#34;, telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp); // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject let response_subject = format!(\u0026#34;thingsboard.ack.{}\u0026#34;, telemetry.device_id); let ack_message = json!({ \u0026#34;device_id\u0026#34;: telemetry.device_id, \u0026#34;status\u0026#34;: \u0026#34;acknowledged\u0026#34;, \u0026#34;timestamp\u0026#34;: telemetry.timestamp }); nc.publish(\u0026amp;response_subject, ack_message.to_string().as_bytes()).await?; } Ok(()) } Cập nhật 13/9/2024 Bài viết: 35 Rust Learning Resources Every Beginner Should Know in 2022 Trong bài viết này tổng hợp rất nhiều documents cho beginner để bắt đầu với Rust. Ở đây mình thấy có những trang rất hay, ví dụ: Tour of Rust Trang này có tiếng Việt và có thêm phần để run code.\nA half-hour to learn Rust A Gentle Introduction To Rust Easy Rust ",
      "content_html": "\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust_Embedded.png\"\n  alt=\"Rust_Embedded\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1/4/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e17/8/2024\u003c/td\u003e\n\u003ctd\u003eCập nhật bài viết, thêm thông tin về Rust-lang\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e13/9/2024\u003c/td\u003e\n\u003ctd\u003eUpdate thêm documents về Rust\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch3 id=\"hạn-chế\"\u003eHạn chế\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://users.rust-lang.org/t/why-is-there-so-much-mismanagement-in-the-rust-foundation-and-core-team/94822\"\u003eNăm 2023 xảy ra nhiều dramma của Rust Found\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eRust là ngôn ngữ \u003cstrong\u003ekhó học, code khó\u003c/strong\u003e.\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=EYCBm0xAWow\u0026amp;list=LL\u0026amp;index=3\"\u003e5 things I wish I knew before learning Rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=fknamfNtKk0\"\u003eWhy do developers hate Rust?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCộng đồng \u003cstrong\u003eDEV\u003c/strong\u003e chưa quá đông như Golang. \u003ca href=\"https://spectrum.ieee.org/the-top-programming-languages-2023\"\u003eTop Programming Languages 2023\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"lợi-ích\"\u003eLợi ích\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRust là ngôn ngữ \u003cstrong\u003elow level\u003c/strong\u003e, được sử dụng cho nhiều mục đích khác nhau:\n\u003cul\u003e\n\u003cli\u003eDùng để code nhúng.\u003c/li\u003e\n\u003cli\u003eDùng để code phía Server.\u003c/li\u003e\n\u003cli\u003eCó thể dùng để code OS - như \u003ca href=\"https://rust-for-linux.com/\"\u003eRust for Linux\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eRust chú trọng vào sự an toàn - \u003cstrong\u003ememory safety\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCộng đồng Rust vẫn đang phát triển. \u003ca href=\"https://pypl.github.io/PYPL.html\"\u003eDựa trên báo cáo thì số lượt tìm kiếm hướng dẫn lập trình Rust đã tăng hơn Golang\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"rust-roadmaphttpsroadmapshrust\"\u003e\u003ca href=\"https://roadmap.sh/rust\"\u003eRust Roadmap\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tài-liệu-về-rust\"\u003eTài liệu về Rust\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/help/rust/getting-started.html\"\u003eRust IDE - RustRover\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://docs.rust-embedded.org/book/\"\u003eThe Embedded Rust Book\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://std-dev-guide.rust-lang.org/\"\u003eStandard library developers Guide\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://blog.rust-lang.org/\"\u003eBlog Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://doc.rust-lang.org/rust-by-example/index.html\"\u003eRust By Example\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://rust-tieng-viet.github.io/getting-started/first-project.html\"\u003eRust Tiếng Việt\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=rAl-9HwD858\u0026amp;list=PLqbS7AVVErFiWDOAVrPt7aYmnuuOLYvOa\u0026amp;index=3\"\u003eYoutube - Crust of Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/@letsgetrusty\"\u003eYoutube - Let\u0026rsquo;s Get Rusty\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://docs.google.com/document/d/1kQidzAlbqapu-WZTuw4Djik0uTqMZYyiMXTM9F21Dz4/edit?lid=75778#heading=h.gjdgxs\"\u003eRust Cheatsheet\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://os.phil-opp.com/\"\u003eWriting an OS in Rust\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"cập-nhật-1782024\"\u003eCập nhật 17/8/2024\u003c/h1\u003e\n\u003ch3 id=\"youtube-where-is-rust-being-usedhttpswwwyoutubecomwatchv42fhqwq6sva\"\u003eYoutube: \u003ca href=\"https://www.youtube.com/watch?v=42FhQWQ6SVA\"\u003eWhere is Rust being used?\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"tổng-hợp-rust-is-for-roboticshttpsroboticsrs\"\u003eTổng hợp \u003ca href=\"https://robotics.rs/\"\u003eRust is for Robotics\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProject \u003ca href=\"https://github.com/ros2-rust/ros2_rust\"\u003eros2_rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eProject \u003ca href=\"https://github.com/Sollimann/CleanIt\"\u003eCleanIt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"doc-offline-first-smart-energy-monitor-with-rust-esp32-and-thingsboardhttpsmoslehiancomposts20223-ofmon\"\u003eDoc: \u003ca href=\"https://moslehian.com/posts/2022/3-ofmon/\"\u003eOffline-first Smart Energy Monitor with Rust, ESP32, and Thingsboard\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Nereuxofficial/nostd-wifi-lamp\"\u003enostd-wifi-lamp\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/JurajSadel/esp32c3-no-std-async-mqtt-demo\"\u003eesp32c3-no-std-async-mqtt-demo\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"framework-cho-mqtt-cho-rust-rumqtthttpsgithubcombytebeamiorumqtt\"\u003eFramework cho MQTT cho Rust: \u003ca href=\"https://github.com/bytebeamio/rumqtt\"\u003erumqtt\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/obabec/rust-mqtt\"\u003erust-mqtt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"framework-nats-for-rust-natsrshttpsgithubcomnats-ionatsrs\"\u003eFramework NATS for Rust: \u003ca href=\"https://github.com/nats-io/nats.rs\"\u003enats.rs\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó thể sử dụng NATS cho ThingsBoard.\u003c/li\u003e\n\u003cli\u003eSample code từ ChatGPT:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse nats::asynk::Connection;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse tokio::time::{sleep, Duration};\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct TelemetryData {\n    device_id: String,\n    temperature: f64,\n    humidity: f64,\n    timestamp: u64,\n}\n\n#[tokio::main]\nasync fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; {\n    // Connect to the NATS server\n    let nc: Connection = nats::asynk::connect(\u0026#34;demo.nats.io\u0026#34;).await?;\n\n    // Subscribe to a subject where ThingsBoard publishes telemetry data\n    let subscription = nc.subscribe(\u0026#34;thingsboard.telemetry\u0026#34;).await?;\n\n    // Process incoming messages\n    while let Some(msg) = subscription.next().await {\n        // Parse the telemetry data (assumed to be JSON)\n        let telemetry: TelemetryData = serde_json::from_slice(\u0026amp;msg.data).expect(\u0026#34;Failed to parse telemetry data\u0026#34;);\n\n        println!(\u0026#34;Received telemetry from device {}: Temperature = {}, Humidity = {}, Timestamp = {}\u0026#34;,\n                 telemetry.device_id, telemetry.temperature, telemetry.humidity, telemetry.timestamp);\n\n        // Optionally, publish an acknowledgment or command back to ThingsBoard or another subject\n        let response_subject = format!(\u0026#34;thingsboard.ack.{}\u0026#34;, telemetry.device_id);\n        let ack_message = json!({\n            \u0026#34;device_id\u0026#34;: telemetry.device_id,\n            \u0026#34;status\u0026#34;: \u0026#34;acknowledged\u0026#34;,\n            \u0026#34;timestamp\u0026#34;: telemetry.timestamp\n        });\n\n        nc.publish(\u0026amp;response_subject, ack_message.to_string().as_bytes()).await?;\n    }\n\n    Ok(())\n}\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch1 id=\"cập-nhật-1392024\"\u003eCập nhật 13/9/2024\u003c/h1\u003e\n\u003ch2 id=\"bài-viết-35-rust-learning-resources-every-beginner-should-know-in-2022httpsblogtheembeddedrustaceancom35-rust-learning-resources-every-beginner-should-know-in-2022\"\u003eBài viết: \u003ca href=\"https://blog.theembeddedrustacean.com/35-rust-learning-resources-every-beginner-should-know-in-2022\"\u003e35 Rust Learning Resources Every Beginner Should Know in 2022\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong bài viết này tổng hợp rất nhiều documents cho beginner để bắt đầu với Rust.\u003c/li\u003e\n\u003cli\u003eỞ đây mình thấy có những trang rất hay, ví dụ:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tour-of-rusthttpstourofrustcom\"\u003e\u003ca href=\"https://tourofrust.com/\"\u003eTour of Rust\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTrang này có tiếng Việt và có thêm phần để run code.\u003c/p\u003e\n\u003ch3 id=\"a-half-hour-to-learn-rusthttpsfasterthanlimearticlesa-half-hour-to-learn-rust\"\u003e\u003ca href=\"https://fasterthanli.me/articles/a-half-hour-to-learn-rust\"\u003eA half-hour to learn Rust\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"a-gentle-introduction-to-rusthttpsstevedonovangithubiorust-gentle-introreadmehtml\"\u003e\u003ca href=\"https://stevedonovan.github.io/rust-gentle-intro/readme.html\"\u003eA Gentle Introduction To Rust\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"easy-rusthttpsdhghomongithubioeasy_rustchapter_1html\"\u003e\u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_1.html\"\u003eEasy Rust\u003c/a\u003e\u003c/h3\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust-lang/",
      "date_published": "13096-13-09T914:1313:00+07:00",
      "date_modified": "13096-13-09T914:1313:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "6f5f5c06dee021d91043f0407390373f173cefb9",
      "title": "Hoi_thao_2024",
      "summary": "",
      "content_text": "Link Video: Hội thảo và Triển lãm An toàn Thông tin phía Nam 2024 Sau khi xem và nghe xong thì mình có nhiều thông tin hữu ích như sau\nThiết bị phần cứng - Khóa xác thực Với loại sản phẩm này thì bên VinCSS cũng có. Và ngoài ra, hiện tại HPT cũng đang bán sản phẩm chính hãng Khóa bảo mật Yubikey Mình đã mua 1 cái, sau khi xem clip của anh Duy Luân, link. Phishing Trong video thì có nói về 1 trong các kiểu tấn công phổ biến hiện nay, để từ đó trình bày cách phòng thủ cho phù hợp. Và thường thì quá trình tấn công của hacker hiện tại là phishing. Gửi email có mã độc \u0026mdash;\u0026gt; Cài malware vào máy nạn nhân trong tổ chức. Âm thầm mò mẫm trong hệ thống Network của tổ chức, và tìm cơ hội để tấn công vào Server. Backdoor Hacker thường cài cắm backdoor thường bằng 1 trong 3 cách. Thứ 1: Tạo Webshell, nguy cơ này đến từ việc sử dụng mã nguồn không hợp lệ. Thứ 2: Tạo account dễ nhầm lẫn. Giả sử hacker đã xâm nhập vào máy nạn nhân, vậy tránh bị phát hiện thì hacker sẽ tạo ra các account với tên bình thường để tránh bị phát hiện. Thứ 3: Dùng DLL (cái này thì mình cũng chưa rõ lắm). Backup Giờ mình mới biết có thuật ngữ mới backup 32110 Có ít nhất là 3 bản dữ liệu (kể cả bản đang vận hành). Vị trí đặt các bản sao phải ở 2 địa điểm khác nhau. Có ít nhất 1 bản copy đặt ở local. Có ít nhất 1 bản offline. Tất cả các bản backup phải đều không bị lỗi và có thể sử dụng được. NOTE: Một lưu ý quan trọng là tất cả data backup phải được mã hóa.\nCác hình ảnh được capture từ bài trình bày của nhóm Chống lừa đảo ",
      "content_html": "\u003ch2 id=\"link-video-hội-thảo-và-triển-lãm-an-toàn-thông-tin-phía-nam-2024httpswwwfacebookcomvnisahcmvideos1461942441187294\"\u003eLink Video: \u003ca href=\"https://www.facebook.com/VNISA.HCM/videos/1461942441187294\"\u003eHội thảo và Triển lãm An toàn Thông tin phía Nam 2024\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSau khi xem và nghe xong thì mình có nhiều thông tin hữu ích như sau\u003c/p\u003e\n\u003ch3 id=\"thiết-bị-phần-cứng---khóa-xác-thực\"\u003eThiết bị phần cứng - Khóa xác thực\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVới loại sản phẩm này thì bên VinCSS cũng có.\u003c/li\u003e\n\u003cli\u003eVà ngoài ra, hiện tại \u003cstrong\u003eHPT\u003c/strong\u003e cũng đang bán sản phẩm chính hãng \u003ca href=\"https://hpttechstore.com/collections/khoa-bao-mat-yubikey\"\u003eKhóa bảo mật Yubikey\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMình đã mua 1 cái, sau khi xem clip của anh Duy Luân, \u003ca href=\"https://www.youtube.com/watch?v=wmC7ZDJfHa0\"\u003elink.\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"phishing\"\u003ePhishing\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/4_layer.png\"\n  alt=\"4_layer\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video thì có nói về 1 trong các kiểu tấn công phổ biến hiện nay, để từ đó trình bày cách phòng thủ cho phù hợp.\u003c/li\u003e\n\u003cli\u003eVà thường thì quá trình tấn công của hacker hiện tại là \u003cstrong\u003ephishing\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGửi email\u003c/strong\u003e có mã độc \u0026mdash;\u0026gt; \u003cstrong\u003eCài malware\u003c/strong\u003e vào máy nạn nhân trong tổ chức.\u003c/li\u003e\n\u003cli\u003eÂm thầm \u003cem\u003emò mẫm\u003c/em\u003e trong \u003cstrong\u003ehệ thống Network\u003c/strong\u003e của tổ chức, và tìm cơ hội để \u003cstrong\u003etấn công vào Server\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"backdoor\"\u003eBackdoor\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/3_cach_backdoor.png\"\n  alt=\"backdoor\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHacker thường cài cắm backdoor thường bằng 1 trong 3 cách.\u003c/li\u003e\n\u003cli\u003eThứ 1: Tạo \u003cstrong\u003eWebshell\u003c/strong\u003e, nguy cơ này đến từ việc sử dụng mã nguồn không hợp lệ.\u003c/li\u003e\n\u003cli\u003eThứ 2: \u003cstrong\u003eTạo account dễ nhầm lẫn\u003c/strong\u003e. Giả sử hacker đã xâm nhập vào máy nạn nhân, vậy tránh bị phát hiện thì hacker sẽ tạo ra các account với tên \u003cstrong\u003ebình thường\u003c/strong\u003e để tránh bị phát hiện.\u003c/li\u003e\n\u003cli\u003eThứ 3: Dùng \u003cstrong\u003eDLL\u003c/strong\u003e (\u003cem\u003ecái này thì mình cũng chưa rõ lắm\u003c/em\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"backup\"\u003eBackup\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Backup_zip_code.png\"\n  alt=\"backup\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGiờ mình mới biết có thuật ngữ mới backup \u003ccode\u003e32110\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCó \u003cstrong\u003eít nhất\u003c/strong\u003e là 3 bản dữ liệu \u003cem\u003e(kể cả bản đang vận hành)\u003c/em\u003e.\u003c/li\u003e\n\u003cli\u003eVị trí đặt các bản sao phải ở \u003cstrong\u003e2 địa điểm\u003c/strong\u003e khác nhau.\u003c/li\u003e\n\u003cli\u003eCó ít nhất \u003cstrong\u003e1 bản copy đặt ở local\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCó ít nhất \u003cstrong\u003e1 bản offline\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTất cả các bản backup phải đều \u003cstrong\u003ekhông bị lỗi\u003c/strong\u003e và có thể sử dụng được.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: Một lưu ý quan trọng là tất cả data backup phải được mã hóa.\u003c/p\u003e\n\u003ch3 id=\"các-hình-ảnh-được-capture-từ-bài-trình-bày-của-nhóm-chống-lừa-đảo\"\u003eCác hình ảnh được capture từ bài trình bày của nhóm \u003cstrong\u003eChống lừa đảo\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_1.png\"\n  alt=\"Hình_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_2.png\"\n  alt=\"Hình_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_3.png\"\n  alt=\"Hình_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_4.png\"\n  alt=\"Hình_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_5.png\"\n  alt=\"Hình_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_6.png\"\n  alt=\"Hình_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hoi_thao_2024/Hinh_7.png\"\n  alt=\"Hình_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/hoi_thao_2024/",
      "date_published": "2096-02-09T929:22:00+07:00",
      "date_modified": "2096-02-09T929:22:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "02d4eeaa8ce44a303d67c920fd5c38f39c32a151",
      "title": "Box_RFID",
      "summary": "",
      "content_text": "Sau quá trình Research_CR95 và vất vả code FW cho bộ hộp đọc thẻ này.\nCuối cùng cũng đã hoàn thành.\nThông tin về bộ đọc thẻ RFID. Yêu cầu thông tin về thẻ tài xế GPLX: 12 ký tự số. Tên tài xế: Sử dụng ký tự chữ (Viết hoa). ID: 10 ký tự số Hộp đọc thẻ RFID Nếu đọc thẻ thành công, thì đèn led DN sẽ chớp sáng 1 lần.\nLần tag thẻ tiếp theo cần phải cách lần tag thẻ trước đó, ít nhất là 3s.\nFeature (Tính năng) Debug: Show debug, send command: IT_TRACE1 Turn off debug, send command: IT_TRACE0 Request Version: Send Response $DVSRFID,VER $DVSRFID,VER,1.2 Đọc thẻ Khi đặt thẻ vào bộ đọc, nếu đọc thành công, thiết bị sẽ gửi ra thông tin: $DVSRFID,READ,123456789012,NGUYENVANA,1234567890 Trong đó:\n123456789012: là thông tin về GPLX NGUYENVANA: là tên tài xế (NGUYEN VAN A) 1234567890: là thông tin ID Card Nếu thẻ bị lỗi thông tin, thì thiết bị sẽ trả ra: $DVSRFID,READ,,, ",
      "content_html": "\u003cp\u003eSau quá trình \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/hardware/research_cr95/\"\u003eResearch_CR95\u003c/a\u003e và vất vả code FW cho bộ hộp đọc thẻ này.\u003c/p\u003e\n\u003cp\u003eCuối cùng cũng đã hoàn thành.\u003c/p\u003e\n\u003ch1 id=\"thông-tin-về-bộ-đọc-thẻ-rfid\"\u003eThông tin về bộ đọc thẻ RFID.\u003c/h1\u003e\n\u003ch2 id=\"yêu-cầu-thông-tin-về-thẻ-tài-xế\"\u003eYêu cầu thông tin về thẻ tài xế\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGPLX\u003c/strong\u003e: 12 ký tự số.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTên tài xế\u003c/strong\u003e: Sử dụng ký tự chữ (Viết hoa).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eID\u003c/strong\u003e: 10 ký tự số\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"hộp-đọc-thẻ-rfid\"\u003eHộp đọc thẻ RFID\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/RFID_Box.jpg\"\n  alt=\"RFID\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eNếu đọc thẻ thành công, thì đèn led \u003cstrong\u003eDN\u003c/strong\u003e sẽ chớp sáng \u003cstrong\u003e1 lần\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLần tag thẻ tiếp theo\u003c/strong\u003e cần phải cách \u003cstrong\u003elần tag thẻ trước đó\u003c/strong\u003e, ít nhất là \u003cstrong\u003e3s\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"feature-tính-năng\"\u003eFeature (Tính năng)\u003c/h2\u003e\n\u003ch3 id=\"debug\"\u003eDebug:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eShow debug, send command: \u003ccode\u003eIT_TRACE1\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTurn off debug, send command: \u003ccode\u003eIT_TRACE0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"request-version\"\u003eRequest Version:\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eSend\u003c/th\u003e\n\u003cth\u003eResponse\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e$DVSRFID,VER\u003c/td\u003e\n\u003ctd\u003e$DVSRFID,VER,1.2\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"đọc-thẻ\"\u003eĐọc thẻ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đặt thẻ vào bộ đọc, nếu đọc thành công, thiết bị sẽ gửi ra thông tin:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$DVSRFID,READ,123456789012,NGUYENVANA,1234567890\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTrong đó:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e123456789012\u003c/strong\u003e: là thông tin về GPLX \u003cbr\u003e\n\u003cstrong\u003eNGUYENVANA\u003c/strong\u003e: là tên tài xế (NGUYEN VAN A) \u003cbr\u003e\n\u003cstrong\u003e1234567890\u003c/strong\u003e: là thông tin ID Card \u003cbr\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eNếu thẻ bị lỗi thông tin, thì thiết bị sẽ trả ra:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$DVSRFID,READ,,,\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/hardware/box_rfid/",
      "date_published": "29086-29-09T838:2929:00+07:00",
      "date_modified": "29086-29-09T838:2929:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "afef4961bf5cabcf54173cd8303e7abbfd2bf1ec",
      "title": "NFC_PWA",
      "summary": "",
      "content_text": "Một số bài viết về việc sử dụng Web PWA để đánh cắp thông tin: https://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa https://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/ https://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info Github project: nfcgate https://github.com/nfcgate/nfcgate/tree/v2/doc https://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md https://github.com/nfcgate/nfcgate/tree/v2/doc/mode Ghi chú theo cách hiểu của bản thân Lúc trước mình có tìm hiểu qua về Web PWA (lúc đó có nghiên cứu về bluetooth trên di động). Với các ứng dụng web PWA thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động. Đầu tiên đầu tiên là dẫn dụ (có thể qua phishing) cài đặt một ứng dụng (có chứa malware) bằng đường link Web PWA. Dùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native. Lúc này hacker dùng nfcgate để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch. Khi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân. Như trong Video Youtube ",
      "content_html": "\u003ch3 id=\"một-số-bài-viết-về-việc-sử-dụng-web-pwa-để-đánh-cắp-thông-tin\"\u003eMột số bài viết về việc sử dụng Web PWA để đánh cắp thông tin:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tinnhiemmang.vn/tin-tac-danh-cap-thong-tin-ngan-hang-tu-nguoi-dung-ios-android-thong-qua-ung-dung-pwa\nhttps://www.bleepingcomputer.com/news/security/new-ngate-android-malware-uses-nfc-chip-to-steal-credit-card-data/\nhttps://www.darkreading.com/mobile-security/nfc-traffic-stealer-targets-android-users-and-their-banking-info\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"github-project-nfcgatehttpsgithubcomnfcgatenfcgate\"\u003eGithub project: \u003ca href=\"https://github.com/nfcgate/nfcgate\"\u003enfcgate\u003c/a\u003e\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://github.com/nfcgate/nfcgate/tree/v2/doc\nhttps://github.com/nfcgate/nfcgate/blob/v2/doc/Compatibility.md\nhttps://github.com/nfcgate/nfcgate/tree/v2/doc/mode\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2 id=\"ghi-chú-theo-cách-hiểu-của-bản-thân\"\u003eGhi chú theo cách hiểu của bản thân\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước mình có tìm hiểu qua về \u003cstrong\u003eWeb PWA\u003c/strong\u003e (lúc đó có nghiên cứu về \u003cem\u003ebluetooth\u003c/em\u003e trên di động).\u003c/li\u003e\n\u003cli\u003eVới các ứng dụng web \u003ccode\u003ePWA\u003c/code\u003e thì mình không cần cài đặt thủ công như các app di động, nhưng vẫn có thể dùng đầy đủ tất cả tính năng như app di động.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/NFC_PWA/entire-process.webp\"\n  alt=\"entire-process\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐầu tiên đầu tiên là dẫn dụ \u003cem\u003e(có thể qua phishing)\u003c/em\u003e cài đặt một ứng dụng (có chứa malware) bằng đường link \u003cstrong\u003eWeb PWA\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDùng PWA theo mình hiểu hiện tại thì mục tiêu là tránh sự phiền phức như khi cài đặt ứng dụng Native.\u003c/li\u003e\n\u003cli\u003eLúc này hacker dùng \u003cstrong\u003enfcgate\u003c/strong\u003e để capture lại các traffic nếu như victime sử dụng NFC để thực hiện giao dịch.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/NFC_PWA/nfc-replay.webp\"\n  alt=\"nfc-replay\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã có đc traffic thì bắt đầu giả mạo credit-card của nạn nhân.\u003c/li\u003e\n\u003cli\u003eNhư trong \u003ca href=\"https://youtu.be/q69--5rdlmI\"\u003eVideo Youtube\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/nfc_pwa/",
      "date_published": "27086-27-09T847:2727:00+07:00",
      "date_modified": "27086-27-09T847:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "377c454df8e403d4adbd6e21b260c4d8c1a7686c",
      "title": "Radxa_X4",
      "summary": "",
      "content_text": "Thông tin: https://www.youtube.com/watch?v=F2atAHDOaIA https://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040 https://github.com/geerlingguy/sbc-reviews/issues/48 https://radxa.com/products/x/x4/ Giải thích theo cách hiểu cá nhân: Cụm từ x86 with a side of Arm trong trường hợp của Radxa X4 SBC (Single Board Computer) mô tả việc tích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.\nĐiều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.\nGiải thích cụ thể:\nIntel N100 và Kiến trúc x86: Intel N100 đây là một bộ vi xử lý x86 của Intel, thuộc dòng Alder Lake-N, sử dụng kiến trúc x86-64. X86 được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó. Ứng dụng: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ. Raspberry Pi RP2040 và Kiến trúc ARM: RP2040: Đây là một bộ vi điều khiển dựa trên kiến trúc ARM Cortex-M0+ do Raspberry Pi Foundation phát triển. Đây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực. Ứng dụng: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng. Tại sao sử dụng cả x86 và ARM trên cùng một bo mạch? Sử dụng tối ưu tài nguyên: x86: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. ARM: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. Tăng tính linh hoạt và hiệu suất:\nSự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính Đồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn. Điều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng. Tính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.\nKết luận: Radxa X4 SBC mô tả việc kết hợp cả hai kiến trúc trong một thiết bị Sử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực. Đây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống. ",
      "content_html": "\u003ch3 id=\"thông-tin\"\u003eThông tin:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://www.youtube.com/watch?v=F2atAHDOaIA\nhttps://www.jeffgeerling.com/blog/2024/radxa-x4-sbc-unites-intel-n100-and-raspberry-pi-rp2040\nhttps://github.com/geerlingguy/sbc-reviews/issues/48\nhttps://radxa.com/products/x/x4/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://radxa.com/x/x4/banner_radxa_x4.webp\"\n  alt=\"radxa_x4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch1 id=\"giải-thích-theo-cách-hiểu-cá-nhân\"\u003eGiải thích theo cách hiểu cá nhân:\u003c/h1\u003e\n\u003cp\u003eCụm từ \u003cstrong\u003ex86 with a side of Arm\u003c/strong\u003e trong trường hợp của \u003ccode\u003eRadxa X4 SBC (Single Board Computer)\u003c/code\u003e mô tả việc \u003cstrong\u003etích hợp cả hai kiến trúc x86 và ARM trên cùng một bo mạch\u003c/strong\u003e, nhưng mỗi kiến trúc phục vụ cho các mục đích khác nhau.\u003c/p\u003e\n\u003cp\u003eĐiều này có thể gây nhầm lẫn, nhưng đây là một ví dụ về việc sử dụng các thế mạnh của cả hai kiến trúc trong cùng một sản phẩm.\u003c/p\u003e\n\u003cp\u003eGiải thích cụ thể:\u003c/p\u003e\n\u003ch3 id=\"intel-n100-và-kiến-trúc-x86\"\u003eIntel N100 và Kiến trúc x86:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eIntel N100\u003c/strong\u003e đây là một bộ \u003cstrong\u003evi xử lý x86\u003c/strong\u003e của Intel, thuộc dòng Alder Lake-N, sử dụng \u003ccode\u003ekiến trúc x86-64\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eX86\u003c/strong\u003e được sử dụng cho các tác vụ tính toán chính và phức tạp, thường là hệ điều hành chính (như Linux hoặc Windows) và các ứng dụng chạy trên đó.\u003c/li\u003e\n\u003cli\u003e\u003cmark\u003eỨng dụng\u003c/mark\u003e: X86 sẽ cung cấp sức mạnh xử lý chính cho hệ thống, đảm bảo khả năng tương thích với các phần mềm x86 truyền thống, đặc biệt là trong các ứng dụng đòi hỏi sức mạnh xử lý cao như các tác vụ máy tính để bàn hoặc server nhẹ.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"raspberry-pi-rp2040-và-kiến-trúc-arm\"\u003eRaspberry Pi RP2040 và Kiến trúc ARM:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRP2040\u003c/strong\u003e: Đây là một bộ \u003cstrong\u003evi điều khiển\u003c/strong\u003e dựa trên \u003ccode\u003ekiến trúc ARM Cortex-M0+\u003c/code\u003e do Raspberry Pi Foundation phát triển.\u003c/li\u003e\n\u003cli\u003eĐây là một vi điều khiển nhỏ, tiết kiệm năng lượng, được sử dụng chủ yếu cho các nhiệm vụ điều khiển và quản lý, như điều khiển thiết bị ngoại vi, quản lý nguồn, hoặc xử lý các tác vụ nhẹ nhàng trong thời gian thực.\u003c/li\u003e\n\u003cli\u003e\u003cmark\u003eỨng dụng\u003c/mark\u003e: ARM Cortex-M0+ trên RP2040 có thể được sử dụng để điều khiển các thiết bị ngoại vi, thực hiện các nhiệm vụ nhúng hoặc quản lý hệ thống con trong bo mạch. Điều này giúp giảm tải cho CPU x86 chính, tăng cường khả năng phản ứng thời gian thực và tiết kiệm năng lượng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tại-sao-sử-dụng-cả-x86-và-arm-trên-cùng-một-bo-mạch\"\u003eTại sao sử dụng cả x86 và ARM trên cùng một bo mạch?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSử dụng tối ưu tài nguyên:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003ex86\u003c/strong\u003e: Đảm nhận các tác vụ nặng hơn, như chạy hệ điều hành và ứng dụng đòi hỏi hiệu suất cao. \u003cbr\u003e\n\u003cstrong\u003eARM\u003c/strong\u003e: Đảm nhiệm các tác vụ điều khiển, quản lý các cảm biến, hoặc xử lý các tín hiệu trong thời gian thực, điều mà ARM rất phù hợp do tính hiệu quả năng lượng và khả năng phản hồi nhanh. \u003cbr\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTăng tính linh hoạt và hiệu suất:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSự kết hợp này cho phép thiết bị sử dụng sức mạnh của x86 cho các tác vụ chính\u003c/li\u003e\n\u003cli\u003eĐồng thời tận dụng tính tiết kiệm năng lượng và hiệu quả của ARM cho các nhiệm vụ nhẹ hơn.\u003c/li\u003e\n\u003cli\u003eĐiều này có thể tối ưu hóa hiệu năng tổng thể và kéo dài tuổi thọ pin trong các ứng dụng di động hoặc nhúng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTính khả dụng và kinh tế: Kết hợp cả hai kiến trúc có thể giảm chi phí phát triển bằng cách sử dụng các vi điều khiển ARM đã có sẵn và mạnh mẽ như RP2040 cho các nhiệm vụ mà không cần phải phát triển thêm phần cứng phức tạp cho những chức năng đơn giản.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kết-luận\"\u003eKết luận:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eRadxa X4 SBC mô tả việc \u003cstrong\u003ekết hợp cả hai kiến trúc trong một thiết bị\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eSử dụng x86 để xử lý các tác vụ nặng nề, trong khi ARM được dùng cho các nhiệm vụ quản lý, điều khiển hoặc xử lý tín hiệu trong thời gian thực.\u003c/li\u003e\n\u003cli\u003eĐây là một chiến lược thông minh để tận dụng thế mạnh của cả hai kiến trúc, tối ưu hóa hiệu suất và hiệu quả năng lượng cho hệ thống.\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/radxa_x4/",
      "date_published": "27086-27-09T839:2727:00+07:00",
      "date_modified": "27086-27-09T839:2727:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "34c808d0a63f277e04fb23a5f76cc83d0a3e024b",
      "title": "News",
      "summary": "",
      "content_text": "Changelog Ngày Mô tả 10/4/2024 Khởi tạo bài viết 26/8/2024 Cập nhật một số trang blog và youtube về chủ đề Hardware Hacking Đây là danh sách các kênh mà mình cập nhật tin tức. Cũng như bổ sung kiến thức. Danh sách các kênh tài liệu và Youtube để cập nhật kiến thức. Các trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm: NCSC VN Whitehat Còn trang của nước ngoài thì gồm (trong đó có telegram): Cyber Security News Telegram: Cyber Threat Intelligence Kênh youtube: Mình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới. Các kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System. Ngày 26/8/2024 Một số trang blog và kênh Youtube về Hardware Hacking\nNCC Group Matt Brown: IoT Pentester \u0026amp; Hardware Security Researcher Blog Youtube Channel: Matt Brown hextree.io: Một nền tảng học tập về hacking. Youtube Channel: LiveOverflow IoT Pentesting Guide IoTSecurity101 GameHacking.GG Trò chơi để luyện tập về reverse và hacking game. Github Hướng dẫn synacktiv Publications Advisories Resources ",
      "content_html": "\u003ch3 id=\"changelog\"\u003eChangelog\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNgày\u003c/th\u003e\n\u003cth\u003eMô tả\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e10/4/2024\u003c/td\u003e\n\u003ctd\u003eKhởi tạo bài viết\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e26/8/2024\u003c/td\u003e\n\u003ctd\u003eCập nhật một số trang blog và youtube về chủ đề Hardware Hacking\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là danh sách các kênh mà mình cập nhật tin tức.\u003c/li\u003e\n\u003cli\u003eCũng như bổ sung kiến thức.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"danh-sách-các-kênh-tài-liệu-và-youtube-để-cập-nhật-kiến-thức\"\u003eDanh sách các kênh tài liệu và Youtube để cập nhật kiến thức.\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác trang ngôn ngữ tiếng Việt mà mình cập nhật thông tin về giới bảo mật, bao gồm:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ncsc-vnhttpstinnhiemmangvnnoi-bat\"\u003e\u003ca href=\"https://tinnhiemmang.vn/noi-bat\"\u003eNCSC VN\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"whitehathttpswhitehatvn\"\u003e\u003ca href=\"https://whitehat.vn/\"\u003eWhitehat\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCòn trang của nước ngoài thì gồm (trong đó có telegram):\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"cyber-security-newshttpscybersecuritynewscom\"\u003e\u003ca href=\"https://cybersecuritynews.com/\"\u003eCyber Security News\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"telegram-cyber-threat-intelligencehttpstmectinow\"\u003e\u003ca href=\"https://t.me/ctinow\"\u003eTelegram: Cyber Threat Intelligence\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"kênh-youtube\"\u003eKênh youtube:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình đang theo dõi hầu hết các kênh được liệt kê trong hình dưới.\u003c/li\u003e\n\u003cli\u003eCác kênh này không chỉ giúp mình cập nhật về các lỗi CVE mới, mà còn giúp mình cập nhật kiến thức về Network, System.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Top_Youtube_Channel_Hacking.jpg\"\n  alt=\"Youtube\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"ngày-2682024\"\u003eNgày 26/8/2024\u003c/h2\u003e\n\u003cp\u003eMột số trang blog và kênh Youtube về Hardware Hacking\u003c/p\u003e\n\u003ch3 id=\"ncc-grouphttpsresearchnccgroupcomcategoryhardware-embedded-systems\"\u003e\u003ca href=\"https://research.nccgroup.com/category/hardware-embedded-systems/\"\u003eNCC Group\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"matt-brown-iot-pentester--hardware-security-researcher\"\u003eMatt Brown: IoT Pentester \u0026amp; Hardware Security Researcher\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://brownfinesecurity.com/blog/\"\u003eBlog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eYoutube Channel: \u003ca href=\"https://www.youtube.com/@mattbrwn\"\u003eMatt Brown\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hextreeiohttpsapphextreeio-một-nền-tảng-học-tập-về-hacking\"\u003e\u003ca href=\"https://app.hextree.io/\"\u003ehextree.io\u003c/a\u003e: Một nền tảng học tập về hacking.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eYoutube Channel: \u003ca href=\"https://www.youtube.com/@LiveOverflow\"\u003eLiveOverflow\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"iot-pentesting-guidehttpswwwiotpentestingguidecom\"\u003e\u003ca href=\"https://www.iotpentestingguide.com/\"\u003eIoT Pentesting Guide\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"iotsecurity101httpsv33rugithubioiotsecurity101\"\u003e\u003ca href=\"https://v33ru.github.io/IoTSecurity101/\"\u003eIoTSecurity101\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"gamehackinggghttpsgamehackinggg\"\u003e\u003ca href=\"https://gamehacking.gg/\"\u003eGameHacking.GG\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrò chơi để luyện tập về \u003cstrong\u003ereverse\u003c/strong\u003e và hacking game.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jhllc/Unity-Game\"\u003eGithub Hướng dẫn\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"synacktivhttpswwwsynacktivcomenour-publications\"\u003e\u003ca href=\"https://www.synacktiv.com/en/our-publications\"\u003esynacktiv\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/publications\"\u003ePublications\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/advisories\"\u003eAdvisories\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.synacktiv.com/en/ressources\"\u003eResources\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/news/",
      "date_published": "26086-26-09T827:2626:00+07:00",
      "date_modified": "26086-26-09T827:2626:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "261aa46d7ac1d848e6c22e49147fd08d6ad6071f",
      "title": "Protect_Camera",
      "summary": "",
      "content_text": "Lướt lát trên Internet, vô tình lụm được các bức ảnh (được cắt ra trên một seminar nào đó) nói về các cách bảo vệ Camera.\nSau khi đọc xong thì mình thấy các nội dung trong đây không chỉ dành riêng cho camera, mà có thể áp dụng tư duy và kỹ thuật này cả vào red-team và blue-team.\nKỹ thuật cho Red-Team Phishing Attacks Đây là kỹ thuật rất phổ biến và hay được dùng. Đính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web fake. Để rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này. Sử dụng phần mềm độc hại Hacker tạo ra các con malware, sau đó nhúng nó vào các file như file ảnh, pdf,\u0026hellip; Khi nạn nhân nhấp vào thì sẽ có các tiến trình chạy ẩn bên trong máy. Ví dụ như tạo ra backdoor kết nối về máy chủ C2 của hacker. Câu hỏi là làm sao dẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm Để làm được điều này thì một trong những kỹ thuật cần dùng là Phishing Attacks.\nKhai thác lỗ hổng phần mềm Phần mềm ở đây mang nghĩa cũng hơi rộng. Có thể là web, moblie hoặc một ứng dụng desktop. Chỉ cần phần mềm đó có lỗ hổng và mình khai thác (ví dụ như Reverse Shell hoặc RAT) được thì cũng làm được khá nhiều trò. Fake WIFI Cách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker. Hacker sẽ fake một free wifi, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet. Hoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,\u0026hellip; Tư duy Blue-Team Sử dụng Password mạnh mẽ Ít nhất 8 ký tự, có cả số lẫn chữ. Trong có phải bao gồm ít nhất phải có một ký tự đặc biệt, và một ký tự chữ in hoa. Sử dụng 2FA Xác thực OTP (One Time Password). Có thể dùng app GG Authen để xác thực 2 bước. Phân quyền Cận thận với những app cài đặt với quyền Admin. Phân quyền lại cho user, được phép và không được phép làm điều gì. Kiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng không thể leo thang đặc quyền được. Bảo vệ vật lý Hiểu nôm na là sử dụng công cụ vật lý để xác thực. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng. Ví dụ như sản phẩm FIDO2® Touch 1 của công ty VinCSS Công cụ khác Hãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng. Sử dụng Firewall (cả phần cứng và phần mềm) để bảo vệ hạ tầng và ứng dụng của bạn. Sử dụng VPN để bảo vệ thông tin của bạn. Sử dụng các công cụ diệt virus để bảo vệ máy tính của bạn. Và đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack (vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu). Human - Con người Dù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là con người Lỗ hổng này nằm trong tư duy, nhận thức về An toàn và Bảo mật thông tin. ",
      "content_html": "\u003cp\u003eLướt lát trên Internet, vô tình \u003cstrong\u003elụm\u003c/strong\u003e được các bức ảnh \u003cem\u003e(được cắt ra trên một seminar nào đó)\u003c/em\u003e nói về các cách bảo vệ Camera.\u003c/p\u003e\n\u003cp\u003eSau khi đọc xong thì mình thấy các nội dung trong đây \u003cstrong\u003ekhông chỉ dành riêng cho camera\u003c/strong\u003e, mà có thể áp dụng \u003cstrong\u003etư duy và kỹ thuật\u003c/strong\u003e này cả vào red-team và blue-team.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/1.jpg\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch2 id=\"kỹ-thuật-cho-red-team\"\u003eKỹ thuật cho Red-Team\u003c/h2\u003e\n\u003ch3 id=\"phishing-attacks\"\u003ePhishing Attacks\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/2.jpg\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là kỹ thuật rất phổ biến và hay được dùng.\u003c/li\u003e\n\u003cli\u003eĐính kèm một đường link đọc hại trong email, gửi cho nạn nhân và khi nạn nhân nhấp vô, thì sẽ được chuyển hướng đến các trang web \u003cstrong\u003efake\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eĐể rồi lấy cấp thông tin nếu như nạn nhân login vào trang fake này.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-phần-mềm-độc-hại\"\u003eSử dụng phần mềm độc hại\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/3.jpg\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHacker tạo ra các con \u003cstrong\u003emalware\u003c/strong\u003e, sau đó \u003cstrong\u003enhúng\u003c/strong\u003e nó vào các file như file ảnh, pdf,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eKhi nạn nhân nhấp vào thì sẽ có các \u003cstrong\u003etiến trình chạy ẩn\u003c/strong\u003e bên trong máy.\u003c/li\u003e\n\u003cli\u003eVí dụ như tạo ra \u003cstrong\u003ebackdoor\u003c/strong\u003e kết nối về \u003cstrong\u003emáy chủ C2\u003c/strong\u003e của hacker.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/4.jpg\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCâu hỏi là làm sao \u003cstrong\u003edẫn dụ nạn nhân nhấp tải hoặc cài đặt phần mềm\u003c/strong\u003e \u003cbr\u003e\nĐể làm được điều này thì một trong những kỹ thuật cần dùng là \u003cmark\u003ePhishing Attacks\u003c/mark\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"khai-thác-lỗ-hổng-phần-mềm\"\u003eKhai thác lỗ hổng phần mềm\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/5.jpg\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePhần mềm\u003c/strong\u003e ở đây mang nghĩa cũng hơi rộng. Có thể là \u003ccode\u003eweb\u003c/code\u003e, \u003ccode\u003emoblie\u003c/code\u003e hoặc một ứng dụng \u003ccode\u003edesktop\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eChỉ cần phần mềm đó có \u003cstrong\u003elỗ hổng\u003c/strong\u003e và mình khai thác (ví dụ như \u003cmark\u003eReverse Shell\u003c/mark\u003e hoặc \u003cstrong\u003eRAT\u003c/strong\u003e) được thì cũng làm được khá nhiều trò.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"fake-wifi\"\u003eFake WIFI\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/6.jpg\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCách này cũng phổ biến, và thường hay thấy trong các bộ phim về hacker.\u003c/li\u003e\n\u003cli\u003eHacker sẽ fake một \u003cstrong\u003efree wifi\u003c/strong\u003e, khi nạn nhân kết nối vào, hacker sẽ biết được nạn nhân đang làm gì trên Internet.\u003c/li\u003e\n\u003cli\u003eHoặc chuyển hướng link, cài đặt phần mềm bất hợp pháp,\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tư-duy-blue-team\"\u003eTư duy Blue-Team\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/7.jpg\"\n  alt=\"Hinh_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"sử-dụng-password-mạnh-mẽ\"\u003eSử dụng Password mạnh mẽ\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eÍt nhất \u003cstrong\u003e8 ký tự\u003c/strong\u003e, có cả số lẫn chữ.\u003c/li\u003e\n\u003cli\u003eTrong có phải bao gồm ít nhất phải có một \u003cstrong\u003eký tự đặc biệt\u003c/strong\u003e, và một ký tự \u003cstrong\u003echữ in hoa\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sử-dụng-2fa\"\u003eSử dụng 2FA\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXác thực \u003cstrong\u003eOTP\u003c/strong\u003e (One Time Password).\u003c/li\u003e\n\u003cli\u003eCó thể dùng app \u003cstrong\u003eGG Authen\u003c/strong\u003e để xác thực 2 bước.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"phân-quyền\"\u003ePhân quyền\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCận thận với những app cài đặt với quyền Admin\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003ePhân quyền lại cho \u003cstrong\u003euser\u003c/strong\u003e, được phép và không được phép làm điều gì.\u003c/li\u003e\n\u003cli\u003eKiểm tra lại phân quyền ứng dụng, nếu chẳng may ứng dụng đó có lỗ hổng và bị hack, thì hacker cũng \u003cstrong\u003ekhông thể leo thang đặc quyền\u003c/strong\u003e được.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bảo-vệ-vật-lý\"\u003eBảo vệ vật lý\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHiểu nôm na là sử dụng \u003cstrong\u003ecông cụ vật lý để xác thực\u003c/strong\u003e. Cũng là xác thực nhưng thay vì dùng phần mềm, thì sẽ dùng phần cứng.\u003c/li\u003e\n\u003cli\u003eVí dụ như sản phẩm \u003ca href=\"https://vincss.net/vi/product/khoa-xac-thuc-manh-vincss-fido2-touch-1-ket-noi-usb-type-a-ho-tro-xac-thuc-an-toan-khong-mat-khau-chuan-uaf-u2f-fido2-hang-chinh-hang/\"\u003eFIDO2® Touch 1\u003c/a\u003e của công ty \u003cstrong\u003eVinCSS\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-khác\"\u003eCông cụ khác\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/10.jpg\"\n  alt=\"Hinh_10\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHãy luôn cập nhật software, để đảm bảo an toàn cho ứng dụng.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003cstrong\u003eFirewall\u003c/strong\u003e \u003cem\u003e(cả phần cứng và phần mềm)\u003c/em\u003e để bảo vệ hạ tầng và ứng dụng của bạn.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003cstrong\u003eVPN\u003c/strong\u003e để bảo vệ thông tin của bạn.\u003c/li\u003e\n\u003cli\u003eSử dụng các công cụ \u003cstrong\u003ediệt virus\u003c/strong\u003e để bảo vệ máy tính của bạn.\u003c/li\u003e\n\u003cli\u003eVà đừng bao giờ truy cập những đường link lạ, cũng như cài đặt những phần mềm crack \u003cem\u003e(vì mình sẽ không biết bên trong phần mềm này đang chạy những gì đâu)\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"human---con-người\"\u003eHuman - Con người\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDù công cụ có bảo vệ có mạnh mẽ đến đâu, thì vẫn luôn tồn tại một lỗ hổng, đó là \u003cstrong\u003econ người\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eLỗ hổng này nằm trong \u003cstrong\u003etư duy\u003c/strong\u003e, \u003cstrong\u003enhận thức\u003c/strong\u003e về An toàn và Bảo mật thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Protect_Camera/8.jpg\"\n  alt=\"Hinh_8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/protect_camera/",
      "date_published": "18086-18-09T87:1818:00+07:00",
      "date_modified": "18086-18-09T87:1818:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "20ccc7228320b7e728440959d1e27bbe5951a067",
      "title": "RE_Tool_BinaryNinjaFree",
      "summary": "",
      "content_text": "Một bài viết về RE (Reverse Engineering)\nCông cụ IDA - The Interactive Disassembler Công cụ này có bản free và hỗ trợ cài đặt trên nhiều nền tảng. Mình tải và cài đặt bản free cho Windows. Tuy nhiên thì: Với bản free thì mình chỉ có thể dùng cho các file PE format. Là dạng các file .exe trên windows. Với bản free thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng. Công cụ Online - Decompiler Explorer Phần mềm Binary Ninja Binary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.\nVideo youtube tham khảo: How to Crack Software (Reverse Engineering) Learning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting An Intro to Binary Ninja (Free) for Malware Analysis Binary Ninja: 4.1 Feature Stream! Community provided Binary Ninja plugins: community-plugins Download Free Đây là một công cụ mạnh mẽ, nhưng được sử dụng free. Nếu so sánh thì phần mềm này ăn đứt IDA về tính năng của bản free: Supports x86, x86_64, and ARMv7 architectures. Hỗ trợ Disassemble (phân tích), Pseudo C (dịch ngược), HLIL. Mình đã tải và cài thử trên Windows, sau đó thử mở một file ELF (file code rust-tracking) Mình có thể dùng với Strings, Hex Editor,\u0026hellip; Công cụ quá mạnh mẽ. ",
      "content_html": "\u003cp\u003eMột bài viết về \u003ca href=\"https://whitehat.vn/threads/re1-gioi-thieu-ve-reverse-engineering.875/\"\u003eRE (Reverse Engineering)\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"công-cụ-ida---the-interactive-disassemblerhttpswhitehatvnthreadsre3-huong-dan-su-dung-ida913\"\u003e\u003ca href=\"https://whitehat.vn/threads/re3-huong-dan-su-dung-ida.913/\"\u003eCông cụ IDA - The Interactive Disassembler\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này có \u003ca href=\"https://hex-rays.com/ida-free/#download\"\u003ebản free\u003c/a\u003e và hỗ trợ cài đặt trên nhiều nền tảng.\u003c/li\u003e\n\u003cli\u003eMình tải và cài đặt bản free cho Windows. Tuy nhiên thì:\n\u003cul\u003e\n\u003cli\u003eVới bản free thì mình chỉ có thể dùng cho các file \u003cstrong\u003ePE format\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLà dạng các file \u003ccode\u003e.exe\u003c/code\u003e trên windows.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eVới bản \u003cem\u003efree\u003c/em\u003e thì có nhiều hạn chế quá, và nhìn cũng hơi khá dùng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"công-cụ-online---decompiler-explorerhttpsdogboltorg\"\u003eCông cụ Online - \u003ca href=\"https://dogbolt.org/\"\u003eDecompiler Explorer\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"phần-mềm-binary-ninjahttpsbinaryninja\"\u003ePhần mềm \u003ca href=\"https://binary.ninja/\"\u003eBinary Ninja\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eBinary Ninja is an interactive decompiler, disassembler, debugger, and binary analysis platform built by reverse engineers, for reverse engineers.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"video-youtube-tham-khảo\"\u003eVideo youtube tham khảo:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=FBwRTWEzGN0\u0026amp;list=WL\u0026amp;index=11\"\u003eHow to Crack Software (Reverse Engineering)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=tCcLhsTdFEw\"\u003eLearning Binary Ninja for Reverse Engineering - Workflows, UI Patching and Scripting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=-RaOeooSmug\"\u003eAn Intro to Binary Ninja (Free) for Malware Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=IdNFMIQ9roQ\"\u003eBinary Ninja: 4.1 Feature Stream!\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"community-provided-binary-ninja-plugins-community-pluginshttpsgithubcomvector35community-plugins\"\u003eCommunity provided Binary Ninja plugins: \u003ca href=\"https://github.com/Vector35/community-plugins\"\u003ecommunity-plugins\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"download-freehttpsbinaryninjafree\"\u003e\u003ca href=\"https://binary.ninja/free/\"\u003eDownload Free\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ mạnh mẽ, nhưng được sử dụng \u003cstrong\u003efree\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNếu so sánh thì phần mềm này \u003cstrong\u003eăn đứt IDA\u003c/strong\u003e về tính năng của bản free:\n\u003cul\u003e\n\u003cli\u003eSupports x86, x86_64, and ARMv7 architectures.\u003c/li\u003e\n\u003cli\u003eHỗ trợ \u003cstrong\u003eDisassemble\u003c/strong\u003e (phân tích), \u003cstrong\u003ePseudo C\u003c/strong\u003e (dịch ngược), \u003cstrong\u003eHLIL\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMình đã tải và cài thử trên Windows, sau đó thử mở một \u003cstrong\u003efile ELF\u003c/strong\u003e (file code rust-tracking)\u003c/li\u003e\n\u003cli\u003eMình có thể dùng với \u003cstrong\u003eStrings\u003c/strong\u003e, \u003cstrong\u003eHex Editor\u003c/strong\u003e,\u0026hellip;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCông cụ quá mạnh mẽ\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Binary_Ninja_Free.png\"\n  alt=\"Binary_Ninja_Free\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/re_tool_binaryninjafree/",
      "date_published": "16086-16-09T87:1616:00+07:00",
      "date_modified": "16086-16-09T87:1616:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8858de0373b9ed077f6a2e9fc778bc7ae286a217",
      "title": "Read_Write_UART_STM32Fx",
      "summary": "",
      "content_text": "Code Test Read Write Data trên UART của chip STM32F103 #![no_std] #![no_main] #![feature(type_alias_impl_trait)] #![feature(alloc_error_handler)] //------------------------- Define Macro Alloc ------------------------------------ extern crate alloc; use alloc_cortex_m::CortexMHeap; // this is the allocator the application will use #[global_allocator] static ALLOCATOR: CortexMHeap = CortexMHeap::empty(); const HEAP_SIZE: usize = 1024; // in bytes //----------------------------------------------------------------------------------- use defmt::*; use defmt_rtt as _; use embassy_executor::Spawner; use embassy_stm32::usart::{Config, Uart}; use embassy_stm32::{bind_interrupts, peripherals, usart}; use embassy_time::{with_timeout, Duration}; use panic_halt as _; bind_interrupts!(struct Irqs { USART1 =\u0026gt; usart::InterruptHandler\u0026lt;peripherals::USART1\u0026gt;; }); #[embassy_executor::main] async fn main(_spawner: Spawner) { // Initialize the allocator BEFORE you use it unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) } info!(\u0026#34;Test UART\u0026#34;); let p = embassy_stm32::init(Default::default()); let mut uart = Uart::new( p.USART1, p.PA10, p.PA9, Irqs, p.DMA1_CH4, p.DMA1_CH5, Config::default(), ) .unwrap(); uart.write(b\u0026#34;Start Test UART\\r\\n\u0026#34;).await.unwrap(); let mut response_data = [0u8; 25]; // Buffer for one byte at a time. loop { match with_timeout(Duration::from_millis(100), uart.read_until_idle(\u0026amp;mut response_data)).await { Ok(_) =\u0026gt; { println!(\u0026#34;Data Test: {}\u0026#34;, response_data); if let Ok(message) = core::str::from_utf8(\u0026amp;response_data) { println!(\u0026#34;DATA OK: {}\u0026#34;, message); } // clean buffer response_data.fill(0); } Err(_e) =\u0026gt; { // debug!(\u0026#34;Read UART Error\u0026#34;); } } } } // define what happens in an Out Of Memory (OOM) condition #[alloc_error_handler] fn alloc_error(_layout: core::alloc::Layout) -\u0026gt; ! { loop {} } Note Đoạn code này dùng timeout với read_until_idle. Với read_until_idle là để tự detect các ký tự xuống dòng như \\r\\n. Kết quả test thành công: ",
      "content_html": "\u003ch2 id=\"code-test-read-write-data-trên-uart-của-chip-stm32f103\"\u003eCode Test Read Write Data trên UART của chip STM32F103\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#![no_std]\n#![no_main]\n#![feature(type_alias_impl_trait)]\n#![feature(alloc_error_handler)]\n//------------------------- Define Macro Alloc ------------------------------------\nextern crate alloc;\nuse alloc_cortex_m::CortexMHeap;\n\n// this is the allocator the application will use\n#[global_allocator]\nstatic ALLOCATOR: CortexMHeap = CortexMHeap::empty();\n\nconst HEAP_SIZE: usize = 1024; // in bytes\n\n//-----------------------------------------------------------------------------------\nuse defmt::*;\nuse defmt_rtt as _;\nuse embassy_executor::Spawner;\nuse embassy_stm32::usart::{Config, Uart};\nuse embassy_stm32::{bind_interrupts, peripherals, usart};\nuse embassy_time::{with_timeout, Duration};\nuse panic_halt as _;\n\nbind_interrupts!(struct Irqs {\n    USART1 =\u0026gt; usart::InterruptHandler\u0026lt;peripherals::USART1\u0026gt;;\n});\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    // Initialize the allocator BEFORE you use it\n    unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) }\n\n    info!(\u0026#34;Test UART\u0026#34;);\n    let p = embassy_stm32::init(Default::default());\n\n    let mut uart = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        Irqs,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        Config::default(),\n    )\n    .unwrap();\n\n    uart.write(b\u0026#34;Start Test UART\\r\\n\u0026#34;).await.unwrap();\n    let mut response_data = [0u8; 25]; // Buffer for one byte at a time.\n\n    loop {\n        match with_timeout(Duration::from_millis(100), uart.read_until_idle(\u0026amp;mut response_data)).await {\n            Ok(_) =\u0026gt; {\n                println!(\u0026#34;Data Test: {}\u0026#34;, response_data);\n\n                if let Ok(message) = core::str::from_utf8(\u0026amp;response_data) {\n                    println!(\u0026#34;DATA OK: {}\u0026#34;, message);\n                }\n\n                // clean buffer\n                response_data.fill(0);\n            }\n            Err(_e) =\u0026gt; {\n                // debug!(\u0026#34;Read UART Error\u0026#34;);\n            }\n        }\n    }\n}\n\n// define what happens in an Out Of Memory (OOM) condition\n#[alloc_error_handler]\nfn alloc_error(_layout: core::alloc::Layout) -\u0026gt; ! {\n    loop {}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐoạn code này dùng \u003ccode\u003etimeout\u003c/code\u003e với \u003ccode\u003eread_until_idle\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eVới \u003ccode\u003eread_until_idle\u003c/code\u003e là để tự detect các ký tự xuống dòng như \u003ccode\u003e\\r\\n\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eKết quả test thành công:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/UART_Read_Write_Result.png\"\n  alt=\"Read_Write\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/read_write_uart_stm32fx/",
      "date_published": "14086-14-09T817:1414:00+07:00",
      "date_modified": "14086-14-09T817:1414:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d646756b3915b7869f9ba136ff457d3e000f4774",
      "title": "Dump_Firmware_NOR_Flash",
      "summary": "",
      "content_text": "Đây là video Youtube nói về việc Dump Firmware thiết bị: Extracting Firmware from Embedded Devices (SPI NOR Flash) ⚡\nMột video hay, thú vị, giải thích và hướng dẫn cơ bản về Flash Memory\nLoại NOR Flash này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như tracking. Còn NAND Flash thì mình thấy trong các thiết bị như Camera hành trình. Loại eMMC Flash thì mình thấy trong máy tính nhúng (như Pi). NOR Flash Trong video thì hướng dẫn và giải thích cơ bản về NOR Flash, cũng như cách dump firmware từ nó. Loại flash này dùng giao thức SPI: Làm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC. Nếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự. Dump Firmware Trong video tác giả sử dụng phần cứng HydraBus Đây là một dự án mã nguồn mở về phần cứng (hardware open-source): hydrabus project. Tài liệu về Cách sử dụng Hydrabus: Getting Started with HydraBus Dựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware: flashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c \u0026#34;MX25L6406E/MX25L6408E Note Để hiểu rõ hơn thì cần xem lại video nhiều lần. Ngoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash hydra_spiflash_nor_dump Một số hình ảnh khác về cách dùng cũng như công cụ bổ trợ: ",
      "content_html": "\u003cp\u003eĐây là video Youtube nói về việc \u003cstrong\u003eDump Firmware\u003c/strong\u003e thiết bị: \u003ca href=\"https://www.youtube.com/watch?v=nruUuDalNR0\u0026amp;list=WL\u0026amp;index=7\"\u003eExtracting Firmware from Embedded Devices (SPI NOR Flash) ⚡\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMột video hay, thú vị, giải thích và hướng dẫn cơ bản về \u003cstrong\u003eFlash Memory\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLoại \u003cstrong\u003eNOR Flash\u003c/strong\u003e này mình cũng có biết, và cũng thường hay thấy trong các thiết bị IoT. Thường là các thiết bị nhỏ, như \u003cstrong\u003etracking\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCòn \u003cstrong\u003eNAND Flash\u003c/strong\u003e thì mình thấy trong các thiết bị như \u003cstrong\u003eCamera hành trình\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLoại \u003cstrong\u003eeMMC Flash\u003c/strong\u003e thì mình thấy trong \u003cstrong\u003emáy tính nhúng\u003c/strong\u003e (như Pi).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nor-flash\"\u003eNOR Flash\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video thì hướng dẫn và giải thích cơ bản về \u003cstrong\u003eNOR Flash\u003c/strong\u003e, cũng như cách \u003cstrong\u003edump firmware\u003c/strong\u003e từ nó.\u003c/li\u003e\n\u003cli\u003eLoại flash này dùng giao thức \u003cstrong\u003eSPI\u003c/strong\u003e:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_3.png\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLàm gì thì làm, mình cũng phải luôn search và tìm datasheet của loại IC.\u003c/li\u003e\n\u003cli\u003eNếu không có đúng loại y như vậy, thì sẽ luôn có những dòng chip tương tự.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_4.png\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"dump-firmware\"\u003eDump Firmware\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong video tác giả sử dụng phần cứng \u003ca href=\"https://hydrabus.com/hydrabus-1-0-specifications/?v=e14da64a5617\"\u003eHydraBus\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/HydraFW_Default_PinAssignment.jpg\"\n  alt=\"HydraBus\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là \u003cstrong\u003emột dự án mã nguồn mở về phần cứng\u003c/strong\u003e (hardware open-source): \u003ca href=\"https://github.com/hydrabus/hydrabus\"\u003ehydrabus project\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eTài liệu về Cách sử dụng Hydrabus: \u003ca href=\"https://github.com/hydrabus/hydrafw/wiki/Getting-Started-with-HydraBus\"\u003eGetting Started with HydraBus\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDựa vào phần cứng này, cũng như thông tin datasheet, tác giả đã có thể tiến hành dump firmware:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eflashrom -p serprog:dev=/dev/ttyACM0 -r dump_spi.bin -c \u0026#34;MX25L6406E/MX25L6408E\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"note\"\u003eNote\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eĐể hiểu rõ hơn thì cần xem lại video nhiều lần.\u003c/li\u003e\n\u003cli\u003eNgoài ra có một số công cụ hỗ trợ khác được sử dụng: Script dump SPI Flash \u003ca href=\"https://github.com/hydrabus/hydrafw/tree/master/contrib/hydra_spiflash_nor_dump\"\u003e\u003ccode\u003ehydra_spiflash_nor_dump\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-số-hình-ảnh-khác-về-cách-dùng-cũng-như-công-cụ-bổ-trợ\"\u003eMột số hình ảnh khác về cách dùng cũng như công cụ bổ trợ:\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_5.png\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_6.png\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_7.png\"\n  alt=\"Hinh_7\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Dump_Firmware_NOR_Flash/Hinh_8.png\"\n  alt=\"Hinh_8\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/dump_firmware_nor_flash/",
      "date_published": "12086-12-09T844:1212:00+07:00",
      "date_modified": "12086-12-09T844:1212:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "e9b5355ef4d97f5d9b1f18a012a87fb12e896428",
      "title": "Shared_Access_Embassy",
      "summary": "",
      "content_text": "Như bài viết về Lifetime_Embassy mình bị vướng chỗ ownership UART.\nSau khi thăm hỏi ChatGPT và đọc lại các tài liệu cũng như xem sample code thì biết rằng: Rust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời \u0026ndash;\u0026gt; Gây lỗi cho chương trình.\nĐể giải quyết vấn đề này thì cần share quyền truy cập (Managing Shared Access).\nCách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột quyền sở hữu (ownership) hoặc mượn (borrow)\nVà để làm được điều này mình sẽ cần dùng đến Mutex, RefCell hoặc Arc. Arc\u0026lt;Mutex\u0026lt;Uart\u0026gt;\u0026gt; Tham khảo sample code về việc sử dụng Arc. Link\nvấn đề tiếp theo Xui một cái nữa là Arc không được khuyến nghị sử dụng trong embedded. và trong các example code có trong framwork embassy, mình cũng không thấy ví dụ nào về dùng Arc. Tiếp tục hỏi chatGPT về cách Shared Access trong framwork embassy, cuối cùng cũng đã có kết quả. Code sample Đây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được. Đoạn code này dùng: Mutex, NoopRawMutex và RefCell. use embassy_executor::Spawner; use embassy_stm32::usart::Uart; use embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1}; use embassy_stm32::gpio::{Output, Level, Speed}; use embassy_time::{Timer, Duration}; use embassy_sync::blocking_mutex::raw::NoopRawMutex; use embassy_sync::mutex::Mutex; use core::cell::RefCell; use core::future::Future; use core::sync::atomic::{AtomicBool, Ordering}; #[embassy_executor::task] pub async fn test_command( uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, message: \u0026amp;\u0026#39;static str, ) { let mut count = 0; loop { count += 1; { let uart = uart.lock().await; let mut uart = uart.borrow_mut(); uart.write(message.as_bytes()).await.unwrap(); uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap(); } if count == 10 { break; } Timer::after(Duration::from_millis(1000)).await; } } #[embassy_executor::task] pub async fn main_task_rfid( rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, mut power_pin_cr95hf: Output\u0026lt;\u0026#39;static, PA1\u0026gt;, ) { dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await; } async fn dbg_print( uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;, message: \u0026amp;str, ) { let uart = uart.lock().await; let mut uart = uart.borrow_mut(); uart.write(message.as_bytes()).await.unwrap(); uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap(); } #[embassy_executor::main] async fn main(spawner: Spawner) { let p = embassy_stm32::Peripherals::take().unwrap(); let usart_rfid = Uart::new( p.USART2, p.PA3, p.PA2, IrqsUART2, p.DMA1_CH7, p.DMA1_CH6, config_rfid, ) .unwrap(); let usart_debug = Uart::new( p.USART1, p.PA10, p.PA9, IrqsUART1, p.DMA1_CH4, p.DMA1_CH5, config_debug, ) .unwrap(); // Convert usart_rfid and usart_debug to \u0026#39;static lifetimes let usart_rfid_static = Box::leak(Box::new(usart_rfid)); let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug)))); // Create the ctr_rfid object let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low); let ctr_rfid_static = Box::leak(Box::new(ctr_rfid)); // Async task for test command spawner .spawn(test_command(usart_debug_static, \u0026#34;Test\u0026#34;)) .unwrap(); // Async task for RFID spawner .spawn(main_task_rfid( usart_rfid_static, usart_debug_static, ctr_rfid_static, )) .unwrap(); } Đã khắc phục và chạy code được thành công. ",
      "content_html": "\u003cp\u003eNhư bài viết về \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/iot/software/lifetime_embassy/\"\u003eLifetime_Embassy\u003c/a\u003e mình bị vướng chỗ ownership UART.\u003c/p\u003e\n\u003cp\u003eSau khi thăm hỏi \u003cstrong\u003eChatGPT\u003c/strong\u003e và đọc lại các tài liệu cũng như xem sample code thì biết rằng:\n\u003cstrong\u003eRust ngăn cắm việc dùm một biến cho multi task, vì lo sợ rằng các task này chạy đồng thời \u0026ndash;\u0026gt; Gây lỗi cho chương trình\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐể giải quyết vấn đề này thì cần share quyền truy cập (\u003cstrong\u003eManaging Shared Access\u003c/strong\u003e).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCách tiếp cận này đảm bảo rằng mỗi tác vụ đều có quyền truy cập an toàn vào UART, mà không gây ra xung đột \u003cstrong\u003equyền sở hữu\u003c/strong\u003e (\u003cem\u003eownership\u003c/em\u003e) hoặc \u003cstrong\u003emượn\u003c/strong\u003e (\u003cem\u003eborrow\u003c/em\u003e)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eVà để làm được điều này mình sẽ cần dùng đến \u003cstrong\u003eMutex\u003c/strong\u003e, \u003cstrong\u003eRefCell\u003c/strong\u003e hoặc \u003cstrong\u003eArc\u003c/strong\u003e. \u003ccode\u003eArc\u0026lt;Mutex\u0026lt;Uart\u0026gt;\u0026gt;\u003c/code\u003e\nTham khảo sample code về việc sử dụng Arc. \u003ca href=\"https://rust-classes.com/chapter_6_3\"\u003eLink\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"vấn-đề-tiếp-theo\"\u003evấn đề tiếp theo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eXui một cái nữa là \u003cstrong\u003eArc\u003c/strong\u003e không được khuyến nghị sử dụng trong \u003cstrong\u003eembedded\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003evà trong các example code có trong \u003cstrong\u003eframwork embassy\u003c/strong\u003e, mình cũng không thấy ví dụ nào về dùng \u003cstrong\u003eArc\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTiếp tục hỏi chatGPT về cách \u003cstrong\u003eShared Access trong framwork embassy\u003c/strong\u003e, cuối cùng cũng đã có kết quả.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"code-sample\"\u003eCode sample\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là code sample từ chatGPT, tất nhiên là cũng cần chỉnh sửa lại một chút để có thể chạy được.\u003c/li\u003e\n\u003cli\u003eĐoạn code này dùng: \u003cstrong\u003eMutex\u003c/strong\u003e, \u003cstrong\u003eNoopRawMutex\u003c/strong\u003e và \u003cstrong\u003eRefCell\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse embassy_executor::Spawner;\nuse embassy_stm32::usart::Uart;\nuse embassy_stm32::peripherals::{USART1, USART2, DMA1_CH4, DMA1_CH5, DMA1_CH6, DMA1_CH7, PA1};\nuse embassy_stm32::gpio::{Output, Level, Speed};\nuse embassy_time::{Timer, Duration};\nuse embassy_sync::blocking_mutex::raw::NoopRawMutex;\nuse embassy_sync::mutex::Mutex;\nuse core::cell::RefCell;\nuse core::future::Future;\nuse core::sync::atomic::{AtomicBool, Ordering};\n\n#[embassy_executor::task]\npub async fn test_command(\n    uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    message: \u0026amp;\u0026#39;static str,\n) {\n    let mut count = 0;\n    loop {\n        count += 1;\n\n        {\n            let uart = uart.lock().await;\n            let mut uart = uart.borrow_mut();\n            uart.write(message.as_bytes()).await.unwrap();\n            uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap();\n        }\n\n        if count == 10 {\n            break;\n        }\n\n        Timer::after(Duration::from_millis(1000)).await;\n    }\n}\n\n#[embassy_executor::task]\npub async fn main_task_rfid(\n    rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    mut power_pin_cr95hf: Output\u0026lt;\u0026#39;static, PA1\u0026gt;,\n) {\n    dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await;\n}\n\nasync fn dbg_print(\n    uart: \u0026amp;\u0026#39;static Mutex\u0026lt;NoopRawMutex, RefCell\u0026lt;Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;\u0026gt;\u0026gt;,\n    message: \u0026amp;str,\n) {\n    let uart = uart.lock().await;\n    let mut uart = uart.borrow_mut();\n    uart.write(message.as_bytes()).await.unwrap();\n    uart.write(b\u0026#34;\\r\\n\u0026#34;).await.unwrap();\n}\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let p = embassy_stm32::Peripherals::take().unwrap();\n\n    let usart_rfid = Uart::new(\n        p.USART2,\n        p.PA3,\n        p.PA2,\n        IrqsUART2,\n        p.DMA1_CH7,\n        p.DMA1_CH6,\n        config_rfid,\n    )\n    .unwrap();\n\n    let usart_debug = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        IrqsUART1,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        config_debug,\n    )\n    .unwrap();\n\n    // Convert usart_rfid and usart_debug to \u0026#39;static lifetimes\n    let usart_rfid_static = Box::leak(Box::new(usart_rfid));\n    let usart_debug_static = Box::leak(Box::new(Mutex::new(RefCell::new(usart_debug))));\n\n\n    // Create the ctr_rfid object\n    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);\n    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));\n\n    // Async task for test command\n    spawner\n        .spawn(test_command(usart_debug_static, \u0026#34;Test\u0026#34;))\n        .unwrap();\n\n    // Async task for RFID\n    spawner\n        .spawn(main_task_rfid(\n            usart_rfid_static,\n            usart_debug_static,\n            ctr_rfid_static,\n        ))\n        .unwrap();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"đã-khắc-phục-và-chạy-code-được-thành-công\"\u003e\u003cstrong\u003eĐã khắc phục và chạy code được thành công\u003c/strong\u003e.\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Result_Shared_Access_UART.png\"\n  alt=\"Result_Shared_Access_UART\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/shared_access_embassy/",
      "date_published": "10086-10-09T818:1010:00+07:00",
      "date_modified": "10086-10-09T818:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a16b4dd5414090a88aec578f8ac2b21db34beb7",
      "title": "Lifetime_Embassy",
      "summary": "",
      "content_text": "Trong quá trình code Rust cho RFID, khi sử dụng đến phần UART và dùng đến #[embassy_executor::task] thì bị báo lỗi về Lifetime\nLỗi lifetime về uart. Hiều nôm na thì rust đang báo là thời gian sống (thời gian tồn tại, hay vòng đời) của UART quá ngắn để thực hiện các tiến trình trong task.\nXem thêm video Rust Lifetimes Finally Explained!\nĐể khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: 'static, 'a, 'b,\u0026hellip;\nVà để khắc phục triệt để mình phải sử dụng thêm Box\nGiới thiệu sơ về Box All values in Rust are stack allocated by default. Values can be boxed (allocated on the heap) by creating a Box. A box is a smart pointer to a heap allocated value of type T. When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.\nĐể chuyển giá trị của Box thành một con trỏ với lifetime là 'static. Mình sẽ dùng đến cấu trúc Box::leak.\nCode mô tả: #[embassy_executor::task] pub async fn main_task_rfid( rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, power_pin_cr95hf: \u0026amp;\u0026#39;static mut Output\u0026lt;\u0026#39;_, PA1\u0026gt;, ) { // Use debug_uart here dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await; } #[embassy_executor::main] async fn main(spawner: Spawner) { let p = embassy_stm32::Peripherals::take().unwrap(); let mut usart_debug = Uart::new( p.USART1, p.PA10, p.PA9, IrqsUART1, p.DMA1_CH4, p.DMA1_CH5, config_debug, ).unwrap(); dbg_print(\u0026amp;mut usart_debug, \u0026#34;RFID CR95\u0026#34;).await; //------------------ RFID Task --------------------- let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low); // Convert references to \u0026#39;static by leaking the values let usart_rfid_static = Box::leak(Box::new(usart_rfid)); let usart_debug_static = Box::leak(Box::new(usart_debug)); let ctr_rfid_static = Box::leak(Box::new(ctr_rfid)); // Async task RFID spawner .spawn(task_rfid::main_task_rfid( usart_rfid_static, usart_debug_static, ctr_rfid_static, )) .unwrap(); Khi đã sử dụng usart_debug cho Box::leak (và được dùng cho task RFID) thì mình không còn dùng được usart_debug sau nữa.\nVì lúc này bị dính đến ownership.\n",
      "content_html": "\u003cp\u003eTrong quá trình code Rust cho RFID, khi sử dụng đến phần \u003cstrong\u003eUART\u003c/strong\u003e và dùng đến \u003ccode\u003e#[embassy_executor::task]\u003c/code\u003e thì bị báo lỗi về \u003cstrong\u003eLifetime\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLỗi lifetime về uart. Hiều nôm na thì rust đang báo là \u003cstrong\u003ethời gian sống\u003c/strong\u003e (thời gian tồn tại, hay \u003cstrong\u003evòng đời\u003c/strong\u003e) của \u003cstrong\u003eUART\u003c/strong\u003e quá ngắn để thực hiện các tiến trình trong task.\u003c/p\u003e\n\u003cp\u003eXem thêm video \u003ca href=\"https://www.youtube.com/watch?v=juIINGuZyBc\"\u003eRust Lifetimes Finally Explained!\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eĐể khắc phục lỗi về Lifetime thì mình sẽ cần thêm các thành phần như: \u003ccode\u003e'static\u003c/code\u003e, \u003ccode\u003e'a\u003c/code\u003e, \u003ccode\u003e'b\u003c/code\u003e,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eVà để khắc phục triệt để mình phải sử dụng thêm \u003ca href=\"https://doc.rust-lang.org/rust-by-example/std/box.html\"\u003eBox\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"giới-thiệu-sơ-về-box\"\u003eGiới thiệu sơ về Box\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAll values in Rust are stack allocated by default. Values can be \u003cem\u003eboxed\u003c/em\u003e (allocated on the heap) by creating a Box\u003cT\u003e.\nA \u003cstrong\u003ebox is a smart pointer\u003c/strong\u003e to a \u003cstrong\u003eheap allocated value of type T\u003c/strong\u003e.\nWhen a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Box_Rust.png\"\n  alt=\"Box\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eĐể chuyển giá trị của Box thành một con trỏ với lifetime là \u003ccode\u003e'static\u003c/code\u003e. Mình sẽ dùng đến cấu trúc \u003ccode\u003eBox::leak\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"code-mô-tả\"\u003eCode mô tả:\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#[embassy_executor::task]\npub async fn main_task_rfid(\n    rfid_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;\u0026#39;static mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n    power_pin_cr95hf: \u0026amp;\u0026#39;static mut Output\u0026lt;\u0026#39;_, PA1\u0026gt;,\n) {\n    // Use debug_uart here\n    dbg_print(debug_uart, \u0026#34;Inside RFID Task\u0026#34;).await;\n}\n\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let p = embassy_stm32::Peripherals::take().unwrap();\n\n    let mut usart_debug = Uart::new(\n        p.USART1,\n        p.PA10,\n        p.PA9,\n        IrqsUART1,\n        p.DMA1_CH4,\n        p.DMA1_CH5,\n        config_debug,\n    ).unwrap();\n\n    dbg_print(\u0026amp;mut usart_debug, \u0026#34;RFID CR95\u0026#34;).await;\n\n    //------------------ RFID Task ---------------------\n    let ctr_rfid = Output::new(p.PA1, Level::High, Speed::Low);\n\n    // Convert references to \u0026#39;static by leaking the values\n    let usart_rfid_static = Box::leak(Box::new(usart_rfid));\n    let usart_debug_static = Box::leak(Box::new(usart_debug));\n    let ctr_rfid_static = Box::leak(Box::new(ctr_rfid));\n\n    // Async task RFID\n    spawner\n        .spawn(task_rfid::main_task_rfid(\n            usart_rfid_static,\n            usart_debug_static,\n            ctr_rfid_static,\n        ))\n        .unwrap();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eKhi đã sử dụng \u003ccode\u003eusart_debug\u003c/code\u003e cho \u003cstrong\u003eBox::leak\u003c/strong\u003e (và được dùng cho \u003cstrong\u003etask RFID\u003c/strong\u003e) thì mình không còn dùng được \u003ccode\u003eusart_debug\u003c/code\u003e sau nữa.\u003c/p\u003e\n\u003cp\u003eVì lúc này bị dính đến \u003cstrong\u003eownership\u003c/strong\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/lifetime_embassy/",
      "date_published": "9086-09-09T88:99:00+07:00",
      "date_modified": "9086-09-09T88:99:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7345b57aedfb01ea55a4c03e7a63fddfa26356b3",
      "title": "Results_Rust",
      "summary": "",
      "content_text": "Một trong các ưu điểm của ngôn ngữ bậc cao là việc Handle Error.\nVà trong Rust thì chính là cách sử dụng Result.\nMình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.\nVideo Youtube: A Simpler Way to See Results Result vs Option Nói cách dễ hiểu thì:\nOption dùng khi mình chỉ muốn biểu đạt có giá trị hoặc không có giá trị. Result dùng khi mình muốn biểu đạt là có giá trị đúng và biết được thông tin lỗi. Ví dụ về việc trả về một giá trị và handle-error Ví dụ về việc trả về hai giá trị và handle-error Nếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code. Tuy nhiên nếu dùng thêm operator thì cách biểu đạt sẽ đơn giản hơn. ",
      "content_html": "\u003cp\u003eMột trong các ưu điểm của ngôn ngữ bậc cao là việc \u003cstrong\u003eHandle Error\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eVà trong Rust thì chính là cách sử dụng \u003cstrong\u003eResult\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_1.png\"\n  alt=\"Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eMình có đọc kha khá tài liệu và sample code về việc này, và video youtube này có vẻ là OK nhất.\u003c/p\u003e\n\u003ch3 id=\"video-youtube-a-simpler-way-to-see-resultshttpswwwyoutubecomwatchvs5s2ed5t-dc\"\u003eVideo Youtube: \u003ca href=\"https://www.youtube.com/watch?v=s5S2Ed5T-dc\"\u003eA Simpler Way to See Results\u003c/a\u003e\u003c/h3\u003e\n\u003ch2 id=\"result-vs-optionhttpsdhghomongithubioeasy_rustchapter_31html\"\u003e\u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_31.html\"\u003eResult vs Option\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_2.png\"\n  alt=\"Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eNói cách dễ hiểu thì:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOption\u003c/strong\u003e dùng khi mình chỉ muốn biểu đạt \u003cstrong\u003ecó giá trị\u003c/strong\u003e hoặc \u003cstrong\u003ekhông có giá trị\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eResult\u003c/strong\u003e dùng khi mình muốn biểu đạt là có \u003cstrong\u003egiá trị đúng\u003c/strong\u003e và biết được \u003cstrong\u003ethông tin lỗi\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_3.png\"\n  alt=\"Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ví-dụ-về-việc-trả-về-một-giá-trị-và-handle-error\"\u003eVí dụ về việc trả về \u003cstrong\u003emột giá trị\u003c/strong\u003e và handle-error\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_4.png\"\n  alt=\"Hinh_4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"ví-dụ-về-việc-trả-về-hai-giá-trị-và-handle-error\"\u003eVí dụ về việc trả về \u003cstrong\u003ehai giá trị\u003c/strong\u003e và handle-error\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu trả về 2 giá trị thì sẽ phức tạp, cụ thể là về cách biểu đạt bằng code.\u003c/li\u003e\n\u003cli\u003eTuy nhiên nếu dùng thêm \u003ca href=\"https://dhghomon.github.io/easy_rust/Chapter_33.html\"\u003eoperator\u003c/a\u003e thì cách biểu đạt sẽ đơn giản hơn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_5.png\"\n  alt=\"Hinh_5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Rust-lang/Result/Hinh_6.png\"\n  alt=\"Hinh_6\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/rust-lang/results_rust/",
      "date_published": "8086-08-09T87:88:00+07:00",
      "date_modified": "8086-08-09T87:88:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "372a4f104501fddb17ccf0cebf9ae4ae0fb586fa",
      "title": "UART_Embassy",
      "summary": "",
      "content_text": "Giới thiệu về Embassy Trong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này. Embassy một framework lập trình theo kiểu bất đồng bộ (async), dễ tiếp cận hơn việc setup một RTOS cho MCU. Async Embassy Dựa trên một file tài liệu mà mình tình cờ có được async-embedded thì Async là một cách tiếp cận về việc Xử lý đồng thời (Concurrency). Hơn nữa dựa trên Github Embassy thì framework này hỗ trợ kha khá dòng chip: Dòng nRF: embassy_nrf Dòng STM32: embassy-stm32 Dòng RP2040: embassy_rp Dòng ESP32: esp-rs Nhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust. UART Trong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.\nRead Trong STM32 phần Read UART có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng. blocking_read read read_until_idle Func blocking_read Function này sẽ mình đọc đầy đủ dữ liệu. Ban đầu mình có test thử giữa blocking_read với read, thì mình đọc được dữ liệu với blocking_read, còn với read thì không. Func read Mình sẽ thường dùng function read này kết hợp với timeout. Tức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra. Nhờ cách này mà mình tránh được việc bị treo chương trình. Đây là một đoạn code mẫu: // health_check_cr95hf // True: CR95HF OK // Flase: CR95HF not reponse -\u0026gt; Maybe lost connect with CR95HF async fn health_check_cr95hf( rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, ) -\u0026gt; bool { let echo_command_code: \u0026amp;[u8]; echo_command_code = cr95hf::cr95hf_echo_command(); dbg_print(debug_uart, \u0026#34;Health Check CR95HF\u0026#34;).await; // Buffer data reponse from CR95HF let mut response_code = [0u8; 1]; let _size_data: usize = 1; for _i in 1..3 { // Send command rfid_uart.blocking_write(\u0026amp;echo_command_code).unwrap(); // Read reponse from CR95HF match with_timeout( Duration::from_millis(30), rfid_uart.read(\u0026amp;mut response_code), ) .await { // match rfid_uart.blocking_read(\u0026amp;mut response_code) { Ok(_size_data) =\u0026gt; { // let _ = debug_uart.blocking_write(\u0026amp;response_code); // Data reponse from CR95 OK if response_code == echo_command_code { return true; } else { return false; } } Err(_e) =\u0026gt; { dbg_print(debug_uart, \u0026#34;Read UART Error - Func health_check_cr95hf\u0026#34;).await; // delay 10ms Timer::after(Duration::from_millis(10)).await; continue; } } } return false; } Func read_until_idle Để hiểu hơn về IDLE UART, mình đã tham khảo tài liệu: https://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette https://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/ Tức là với func này, nó sẽ chia ra thành từng block để đọc dữ liệu. Dưới đây là đoạn code với chức năng là: gửi command sau đó đọc 4 bytes dữ liệu, tuy nhiên chỉ lấy 2 bytes đầu để xử lý dữ liệu // no_tag_cr95hf: Check no_tag // Return true: if not detectd tag card async fn no_tag_cr95hf( rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;, debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;, ) -\u0026gt; bool { // First: Setup Protocol ISO15693 setup_protocol_iso15693(rfid_uart).await; // Second: Read data and check errors code // Define the initial byte array let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00]; for _i in 1..3 { // Send command rfid_uart.blocking_write(\u0026amp;sendrecv_command).unwrap(); // Buffer data reponse from CR95HF let mut response_data = [0u8; 4]; let _size_data: usize = 2; // Read reponse from CR95HF match rfid_uart.read_until_idle(\u0026amp;mut response_data).await { Ok(_size_data) =\u0026gt; { // let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data.clone()); let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data); // let _ = debug_uart.blocking_write(\u0026amp;response_data); // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes()); if is_no_tag == true { dbg_print(debug_uart, \u0026#34;NO TAG CARD\u0026#34;).await; return true; } else { return false; } } Err(_e) =\u0026gt; { // delay 10ms Timer::after(Duration::from_millis(10)).await; } } } return false; } ",
      "content_html": "\u003ch2 id=\"giới-thiệu-về-embassyhttpsembassydev\"\u003eGiới thiệu về \u003ca href=\"https://embassy.dev/\"\u003eEmbassy\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình tìm hiểu về lập trình nhúng bằng Rust, thì mình vô tình biết đến framework này.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEmbassy\u003c/strong\u003e một framework lập trình theo kiểu \u003cstrong\u003ebất đồng bộ (async)\u003c/strong\u003e, dễ tiếp cận hơn việc setup một \u003cstrong\u003eRTOS\u003c/strong\u003e cho MCU.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Embassy/Concurrency_Parallelism.jpg\"\n  alt=\"Concurrency_Parallelism\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"async-embassy\"\u003eAsync Embassy\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa trên một file tài liệu mà mình tình cờ có được \u003ca href=\"/docs/embassy/B4-async-embedded.pdf\"\u003easync-embedded\u003c/a\u003e thì \u003cstrong\u003eAsync\u003c/strong\u003e là một cách tiếp cận về việc \u003cstrong\u003eXử lý đồng thời (Concurrency)\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHơn nữa dựa trên \u003ca href=\"https://github.com/embassy-rs/embassy\"\u003eGithub Embassy\u003c/a\u003e thì framework này hỗ trợ kha khá dòng chip:\n\u003cul\u003e\n\u003cli\u003eDòng nRF: \u003ca href=\"https://docs.embassy.dev/embassy-nrf/git/nrf51/index.html\"\u003eembassy_nrf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng STM32: \u003ca href=\"https://docs.embassy.dev/embassy-stm32/git/stm32f730i8/index.html\"\u003eembassy-stm32\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng RP2040: \u003ca href=\"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html\"\u003eembassy_rp\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDòng ESP32: \u003ca href=\"https://github.com/esp-rs\"\u003eesp-rs\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eNhìn chung đây là framework tuyệt vời để bắt đầu code nhúng với Rust.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1 id=\"uart\"\u003eUART\u003c/h1\u003e\n\u003cp\u003eTrong quá trình sử dụng framework embassy, mình thường hay dùng UART nên mình sẽ note lại một số thứ cần lưu ý về UART.\u003c/p\u003e\n\u003ch2 id=\"read\"\u003eRead\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTrong STM32 phần \u003cstrong\u003eRead UART\u003c/strong\u003e có khá nhiều function, và đây là 3 func mà mình sẽ thường dùng.\n\u003cul\u003e\n\u003cli\u003eblocking_read\u003c/li\u003e\n\u003cli\u003eread\u003c/li\u003e\n\u003cli\u003eread_until_idle\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"func-blocking_read\"\u003eFunc \u003ccode\u003eblocking_read\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFunction này sẽ mình đọc đầy đủ dữ liệu.\u003c/li\u003e\n\u003cli\u003eBan đầu mình có test thử giữa \u003ccode\u003eblocking_read\u003c/code\u003e với \u003ccode\u003eread\u003c/code\u003e, thì mình \u003cstrong\u003eđọc\u003c/strong\u003e được dữ liệu với \u003ccode\u003eblocking_read\u003c/code\u003e, còn với \u003ccode\u003eread\u003c/code\u003e thì không.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"func-read\"\u003eFunc \u003ccode\u003eread\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình sẽ thường dùng function \u003cstrong\u003eread\u003c/strong\u003e này kết hợp với \u003cstrong\u003etimeout\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTức là mình sẽ cho một khoảng thời gian để đọc data từ uart, nếu không thấy data trong khoảng thời gian nhất định thì sẽ thoát ra.\u003c/li\u003e\n\u003cli\u003eNhờ cách này mà mình tránh được việc bị \u003cstrong\u003etreo\u003c/strong\u003e chương trình.\u003c/li\u003e\n\u003cli\u003eĐây là một đoạn code mẫu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// health_check_cr95hf\n// True: CR95HF OK\n// Flase: CR95HF not reponse -\u0026gt; Maybe lost connect with CR95HF\nasync fn health_check_cr95hf(\n    rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n) -\u0026gt; bool {\n    let echo_command_code: \u0026amp;[u8];\n    echo_command_code = cr95hf::cr95hf_echo_command();\n    dbg_print(debug_uart, \u0026#34;Health Check CR95HF\u0026#34;).await;\n\n    // Buffer data reponse from CR95HF\n    let mut response_code = [0u8; 1];\n    let _size_data: usize = 1;\n\n    for _i in 1..3 {\n        // Send command\n        rfid_uart.blocking_write(\u0026amp;echo_command_code).unwrap();\n\n        // Read reponse from CR95HF\n        match with_timeout(\n            Duration::from_millis(30),\n            rfid_uart.read(\u0026amp;mut response_code),\n        )\n        .await\n        {\n            // match rfid_uart.blocking_read(\u0026amp;mut response_code) {\n            Ok(_size_data) =\u0026gt; {\n                // let _ = debug_uart.blocking_write(\u0026amp;response_code);\n                // Data reponse from CR95 OK\n                if response_code == echo_command_code {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Err(_e) =\u0026gt; {\n                dbg_print(debug_uart, \u0026#34;Read UART Error - Func health_check_cr95hf\u0026#34;).await;\n                // delay 10ms\n                Timer::after(Duration::from_millis(10)).await;\n                continue;\n            }\n        }\n    }\n\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"func-read_until_idle\"\u003eFunc \u003ccode\u003eread_until_idle\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐể hiểu hơn về \u003cstrong\u003eIDLE UART\u003c/strong\u003e, mình đã tham khảo tài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://tapit.vn/huong-dan-su-dung-chuc-nang-uart-idle-dma/#google_vignette\nhttps://controllerstech.com/stm32-uart-5-receive-data-using-idle-line/\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTức là với func này, nó sẽ chia ra thành từng \u003cstrong\u003eblock\u003c/strong\u003e để đọc dữ liệu.\u003c/li\u003e\n\u003cli\u003eDưới đây là đoạn code với chức năng là: gửi command sau đó đọc \u003cstrong\u003e4 bytes\u003c/strong\u003e dữ liệu, tuy nhiên chỉ lấy \u003cstrong\u003e2 bytes\u003c/strong\u003e đầu để xử lý dữ liệu\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// no_tag_cr95hf: Check no_tag\n// Return true: if not detectd tag card\nasync fn no_tag_cr95hf(\n    rfid_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART2, DMA1_CH7, DMA1_CH6\u0026gt;,\n    debug_uart: \u0026amp;mut Uart\u0026lt;\u0026#39;static, USART1, DMA1_CH4, DMA1_CH5\u0026gt;,\n) -\u0026gt; bool {\n    // First: Setup Protocol ISO15693\n    setup_protocol_iso15693(rfid_uart).await;\n\n    // Second: Read data and check errors code\n    // Define the initial byte array\n    let sendrecv_command = [0x04, 0x03, 0x02, 0x20, 0x00];\n\n    for _i in 1..3 {\n        // Send command\n        rfid_uart.blocking_write(\u0026amp;sendrecv_command).unwrap();\n\n        // Buffer data reponse from CR95HF\n        let mut response_data = [0u8; 4];\n        let _size_data: usize = 2;\n\n        // Read reponse from CR95HF\n        match rfid_uart.read_until_idle(\u0026amp;mut response_data).await {\n            Ok(_size_data) =\u0026gt; {\n                // let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data.clone());\n                let is_no_tag = cr95hf::errors_tag_code(\u0026amp;response_data);\n                // let _ = debug_uart.blocking_write(\u0026amp;response_data);\n                // let _ = debug_uart.blocking_write(is_no_tag.to_string().as_bytes());\n                if is_no_tag == true {\n                    dbg_print(debug_uart, \u0026#34;NO TAG CARD\u0026#34;).await;\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Err(_e) =\u0026gt; {\n                // delay 10ms\n                Timer::after(Duration::from_millis(10)).await;\n            }\n        }\n    }\n\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/iot/software/uart_embassy/",
      "date_published": "7086-07-09T823:77:00+07:00",
      "date_modified": "7086-07-09T823:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "85f09ce2f3cf711d085e9963d1cd2f835cfcf5d6",
      "title": "IoT_Security_JD",
      "summary": "",
      "content_text": " Bữa lang thang trên diễn đàn CISSP trên facebook, mình thấy một JD về Security cho IoT. Mình thấy JD này đầy đủ và cụ thể:\nVNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị UAV, drone, IoT, satellite,\u0026hellip; Nếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn: Có kỹ năng dịch ngược phần mềm (Reverse Engineering) và tìm kiếm lỗ hổng từ file thực thi đó. Thông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware. Thông thạo kỹ năng khai thác lỗ hổng phần mềm, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v\u0026hellip;. Có kỹ năng Source code review + Pentest blackbox các các thiết bị IoT Đam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới Bạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm: Kiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v\u0026hellip; trước khi hòa mạng vào hệ thống mạng băng rộng VNPT Nghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …) Nghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, … Nghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile VCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT: Gia nhập VCI, bạn sẽ đóng vai chính cho các dự án Làm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh Chế độ đãi ngộ hấp dẫn và review lương theo năng lực Chúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân Nếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé! Hồ sơ ứng viên xin gửi về địa chỉ email: security@vnpt.vn Reverse Đây là kỹ năng mà mình cần rèn luyện và trau dồi.\nDịch ngược Phần cứng Việc bóc tách chip nhớ thì sẽ có 2 mục tiêu chính: Thứ 1: Đọc các dữ liệu được lưu trữ không Flash Thứ 2: Dump Firmware Mình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại. Việc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị. Khai thác lỗ hổng Khi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn. Trong JD có các thuật ngữ mà mình không hiểu, ngoại trừ command injection. Cái này phức tạp vãi chưởng luôn. Pentest blackbox Các thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là Pentest Web. Hoặc có thể là lấy thông tin từ Debug UART, tìm kiếm IP Gateway Server, FTP Server,\u0026hellip; =\u0026gt; Pentest Web. Kiểm định, đánh giá an toàn bảo mật Các giao thức truyền thông IoT thì mình biết, nhưng mà để đánh giá ATTT thì mình chưa rõ. Không lẻ lấy theo tiêu chuẩn NIS2 Nhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.\nBiết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là điều kiện thực hành.\nMình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.\nVì trong IoT còn có những mảng nhỏ khác như:\nDesign (vẽ Schematic, PCB) Code nhúng Firmware cho MCU Code nhúng cho Linux Cũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]\n",
      "content_html": "\u003cp\u003e\u003cimg\n  src=\"/image/IoT/IoT_Security.jpg\"\n  alt=\"IoT_Security\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eBữa lang thang trên diễn đàn \u003cstrong\u003eCISSP trên facebook\u003c/strong\u003e, mình thấy một \u003cstrong\u003eJD về Security cho IoT\u003c/strong\u003e. Mình thấy JD này đầy đủ và cụ thể:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eVNPT Cyber Immunity tìm kiếm ứng viên đam mê làm Security cho các thiết bị \u003cstrong\u003eUAV, drone, IoT, satellite,\u0026hellip;\u003c/strong\u003e \u003c/br\u003e\nNếu trái tim bạn rực cháy với niềm đam mê nghiên cứu bảo mật, hãy để VCI tiếp lửa cho bạn. Bạn sẽ là mảnh ghép VCI, nếu bạn: \u003c/br\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCó kỹ năng \u003cstrong\u003edịch ngược phần mềm (Reverse Engineering)\u003c/strong\u003e và tìm kiếm lỗ hổng từ file thực thi đó. \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eThông thạo kỹ năng dịch ngược phần cứng, bóc tách chip nhớ của mạch IoT, đọc sửa chip nhớ, mod firmware. \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eThông thạo kỹ năng \u003cstrong\u003ekhai thác lỗ hổng phần mềm\u003c/strong\u003e, tối thiểu nắm vững các kỹ thuật khai thác cơ bản như: BoF, ROP, bypass DEP, command injection, v.v\u0026hellip;. \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eCó kỹ năng \u003cstrong\u003eSource code review + Pentest blackbox\u003c/strong\u003e các các thiết bị IoT \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eĐam mê với lĩnh vực bảo mật thiết bị IoT và luôn tìm kiếm sự đổi mới \u003c/br\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBạn sẽ là vai chính trong các dự án lớn nhỏ của chúng mình và đảm nhận trách nhiệm: \u003c/br\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKiểm định, đánh giá an toàn bảo mật với các thiết bị IoT, router, wifi, mesh, v.v\u0026hellip; trước khi hòa mạng vào hệ thống mạng băng rộng VNPT \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eNghiên cứu, đánh giá ATTT các thiết bị, sản phẩm kết nối không dây, điều khiển không dây (Vệ tinh, UAV, DRONE, …) \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eNghiên cứu, đánh giá ATTT các hạ tầng truyền dẫn, các giao thức truyền thông radio IoT, giao thức tầng ứng dụng MQTT, CoAPP, Socket, … \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eNghiên cứu phát triển các giải pháp đảm bảo ATTT (Giải pháp VNPT IoT Guard,…) cho các thiết bị IoT, Mobile \u003c/br\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVCI sẽ là người bạn đồng hành cùng bạn trên chặng đường chinh phục bảo mật IoT: \u003c/br\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGia nhập VCI, bạn sẽ đóng vai chính cho các dự án \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eLàm việc trong môi trường chuyên nghiệp, trẻ trung, hiện đại với nhiều cơ hội phát triển nghề nghiệp, nơi mọi ý tưởng đều được hoan nghênh \u003c/br\u003e\u003c/li\u003e\n\u003cli\u003eChế độ đãi ngộ hấp dẫn và review lương theo năng lực \u003c/br\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eChúng mình bắt đầu làm việc từ 8h và tan làm lúc 17h từ thứ 2 đến thứ 6, và dùng cuối tuần để tận hưởng thời gian riêng cho bản thân \u003c/br\u003e\nNếu bạn cảm thấy “match” với tần số của chúng mình, hãy gửi hồ sơ (CV) để ứng tuyển ngay nhé! \u003c/br\u003e\nHồ sơ ứng viên xin gửi về địa chỉ email: \u003ca href=\"mailto:security@vnpt.vn\"\u003esecurity@vnpt.vn\u003c/a\u003e \u003c/br\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"reverse\"\u003eReverse\u003c/h2\u003e\n\u003cp\u003eĐây là kỹ năng mà mình cần rèn luyện và trau dồi.\u003c/p\u003e\n\u003ch3 id=\"dịch-ngược-phần-cứng\"\u003eDịch ngược Phần cứng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eViệc \u003cstrong\u003ebóc tách chip nhớ\u003c/strong\u003e thì sẽ có 2 mục tiêu chính:\n\u003cul\u003e\n\u003cli\u003eThứ 1: Đọc các dữ liệu được lưu trữ không Flash\u003c/li\u003e\n\u003cli\u003eThứ 2: Dump Firmware\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMình liên tưởng đến các thiết bị Tracking, các dữ liệu khi chưa gửi kịp lên Server thì sẽ được lưu trữ lại.\u003c/li\u003e\n\u003cli\u003eViệc đọc chip nhớ có thể giúp mình lấy được data backup của thiết bị, từ trạng thái ON/OFF cho đến location (lat, long) của thiết bị.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"khai-thác-lỗ-hổng\"\u003eKhai thác lỗ hổng\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi đã có firmware thì mình có thể dùng tool để dịch ngược mã nguồn.\u003c/li\u003e\n\u003cli\u003eTrong JD có các thuật ngữ mà mình không hiểu, ngoại trừ \u003cstrong\u003ecommand injection\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCái này phức tạp vãi chưởng luôn.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"pentest-blackbox\"\u003ePentest blackbox\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác thiết bị IoT thường sẽ có giao diện web, nên mình nghĩ nếu pentest thì thường sẽ là \u003cstrong\u003ePentest Web\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eHoặc có thể là lấy thông tin từ \u003cstrong\u003eDebug UART\u003c/strong\u003e, tìm kiếm IP Gateway Server, FTP Server,\u0026hellip; =\u0026gt; Pentest Web.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kiểm-định-đánh-giá-an-toàn-bảo-mật\"\u003eKiểm định, đánh giá an toàn bảo mật\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCác giao thức truyền thông IoT thì mình biết, nhưng mà để \u003cstrong\u003eđánh giá ATTT\u003c/strong\u003e thì mình chưa rõ.\u003c/li\u003e\n\u003cli\u003eKhông lẻ lấy theo tiêu chuẩn \u003ca href=\"https://blog.vinhld-homelab.io.vn/posts/cybersecurity/technical/nis2/\"\u003eNIS2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eNhìn chung thì nếu dựa trên JD này thì thật sự mình thiếu khá nhiều.\u003c/p\u003e\n\u003cp\u003eBiết thì mình có biết đấy, nhưng để làm được thì chưa. Nguyên nhân có thể là \u003cstrong\u003eđiều kiện thực hành\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMình khá chắc rằng một người làm trong mảng IoT (hay Embedded) nhiều năm cũng chưa chắc đã đáp ứng đc hết yêu cầu trên.\u003c/p\u003e\n\u003cp\u003eVì trong IoT còn có những mảng nhỏ khác như:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDesign (vẽ Schematic, PCB)\nCode nhúng Firmware cho MCU\nCode nhúng cho Linux\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCũng may là mình biết một chút về Security (và đang trên con đường định hướng về IoT Security) nên JD này là cái mà mình cần tham khảo. =]]\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/iot_security_jd/",
      "date_published": "4086-04-09T84:44:00+07:00",
      "date_modified": "4086-04-09T84:44:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "588a7f7dd0c3320660bf06f7cbd7a404d2ae850d",
      "title": "Docklight",
      "summary": "",
      "content_text": " Bữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn. Gửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết. Sang tuần mới có board mạch hoàn chỉnh. Lúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để giả lập data Serial.\nCông cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án Công lạnh.\nTool giả lập data cho Serial Mục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code. Những thông tin, data, command id,\u0026hellip; tất cả mình đã có hết. Lúc này mình sẽ dùng Docklight để giả lập data (tương tự như cách CR95 phản hồi command từ MCU). Docklight Đây là công cụ có bản quyền, phải trả phí. Tuy nhiên để dùng free thì mình cần tải phiên bản Docklight 2.2 trở xuống. Download Docklight 2.2 Download Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016) Và đây là Key number để kích hoạt: KEY NUMBER 010111323344556 ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eBữa đang nghiên cứu code Rust cho CR95, thì phần cứng nó cứ chập chờn.\u003c/li\u003e\n\u003cli\u003eGửi lệnh cho thiết bị thì lúc có phản hồi, lúc không. Có thể cắm dây nó lỏng hay gì đó thì không biết.\u003c/li\u003e\n\u003cli\u003eSang tuần mới có board mạch hoàn chỉnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLúc này mình mới nhớ ra là có một công cụ mà lúc trước mình có dùng để \u003cstrong\u003egiả lập data Serial\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eCông cụ này được một người anh giới thiệu sử dụng, lúc mà còn làm ở Vietmap, nghiên cứu cho dự án \u003cstrong\u003eCông lạnh\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"tool-giả-lập-data-cho-serial\"\u003eTool giả lập data cho Serial\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMục tiêu là mình không cần quá phụ thược vào phần cứng module CR95HF nữa. Mà chỉ cần tập trung code.\u003c/li\u003e\n\u003cli\u003eNhững thông tin, data, command id,\u0026hellip; tất cả mình đã có hết.\u003c/li\u003e\n\u003cli\u003eLúc này mình sẽ dùng \u003cstrong\u003eDocklight\u003c/strong\u003e để \u003cstrong\u003egiả lập data\u003c/strong\u003e (tương tự như cách CR95 phản hồi command từ MCU).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"docklight\"\u003eDocklight\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là công cụ có bản quyền, phải trả phí.\u003c/li\u003e\n\u003cli\u003eTuy nhiên để dùng \u003cstrong\u003efree\u003c/strong\u003e thì mình cần tải phiên bản \u003cstrong\u003eDocklight 2.2\u003c/strong\u003e trở xuống.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://docklight.de/downloads/\"\u003eDocklight 2.2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eDownload Docklight V2.2.8 for Windows 10, Windows 8, Windows 7, Windows Vista (4.7 MB, Release 11/2016)\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eVà đây là \u003cstrong\u003eKey number\u003c/strong\u003e để kích hoạt:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eKEY NUMBER\n010111323344556\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg\n  src=\"https://docklight.de/wp-content/uploads/2018/09/app3_docklight_screenshot_simulator_based_on_log_data.png\"\n  alt=\"docklight\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/docklight/",
      "date_published": "3086-03-09T824:33:00+07:00",
      "date_modified": "3086-03-09T824:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "bbc6371e5a3df28e5b52599641e63196f8c43b5b",
      "title": "ParamSpider",
      "summary": "",
      "content_text": "Bữa có coi video trên Youtube có tựa đề: 5 Hacking Tools I Can\u0026rsquo;t Live Without\nTrong đó có đề cập đến các công cụ dành cho việc Pentest Web:\n1. DevTools 2. BURP Suite 3. Containers 4. FFUF 5. ParamSpider Mấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.\nGithub ParamSpider Dựa vào thông tin trên github công cụ giống như Wayback Machine Tuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian. Công cụ này cũng ổn áp \u0026ldquo;phết\u0026rdquo;. ",
      "content_html": "\u003cp\u003eBữa có coi video trên Youtube có tựa đề: \u003ca href=\"https://www.youtube.com/watch?v=JHRzVEvpHSM\u0026amp;list=WL\u0026amp;index=2\"\u003e5 Hacking Tools I Can\u0026rsquo;t Live Without\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTrong đó có đề cập đến các công cụ dành cho việc Pentest Web:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. DevTools\n2. BURP Suite\n3. Containers\n4. FFUF\n5. ParamSpider\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMấy công cụ đầu thì mình cũng có biết qua, có công cụ cuối cùng là cần note lại.\u003c/p\u003e\n\u003ch3 id=\"github-paramspiderhttpsgithubcomdevanshbathamparamspider\"\u003e\u003ca href=\"https://github.com/devanshbatham/ParamSpider\"\u003eGithub ParamSpider\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDựa vào thông tin trên github công cụ giống như \u003ca href=\"https://web.archive.org/\"\u003eWayback Machine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTuy nhiên nó giúp mình lọc bớt những thông tin thừa thải, chỉ như vậy thôi cũng đã giúp pentester tiết kiệm kha khá thời gian.\u003c/li\u003e\n\u003cli\u003eCông cụ này cũng ổn áp \u0026ldquo;phết\u0026rdquo;.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://raw.githubusercontent.com/devanshbatham/ParamSpider/master/static/paramspider.png\"\n  alt=\"paramspider\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/paramspider/",
      "date_published": "3086-03-09T824:33:00+07:00",
      "date_modified": "3086-03-09T824:33:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1a0a7c8213b1aec2b91bd5b2214fd070ecf7037c",
      "title": "Research_CR95",
      "summary": "",
      "content_text": "Giới thiệu: CR95 là dòng chip dùng để đọc RFID và NFC. Các thiết bị Giám sát hành trình theo QCVN31 đều phải có bộ RFID, để đọc thẻ tài xế. Công ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại IC CR95 (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này). Yêu cầu: Nghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART. Dùng ngôn ngữ lập trình Rust để viết Firmware. Research Sau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là SPI. Mình cần xem lại datasheet của CR95. Về phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware. May mắn thay Lúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART. Source code anh này được viết bằng C, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một board phần cứng CR95 khác Sau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là: Echo: 0x55 Info: 0x0100 Set Protocol: 0x02020109 SendRecv: 0x0403022000 Tới đây thì mình bó tay, không hiều làm sao mà có thể đọc được thông tin ID, tên tài xế, giấy phép lái xe của thẻ RFID Và mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,\u0026hellip; Nhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp. Đọc tín hiệu xung Khi gần như bế tắc thì anh Sơn đã gợi ý là đọc tín hiệu xung. Và mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng board logic analyzer Board này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại phần mềm hỗ trợ cho board này lại cực xịn (đánh giá cá nhân). Từ hình 1 và hình 2 là mình biết rằng những lệnh command ban đầu của mình đã đúng. Tiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế: Cuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi SendRecv thì nó chỉ đọc được số lượng byte nhất định, nên để đọc được hết thông tin thì mình cần gửi: 0x0403022000 0x0403022001 0x0403022002 0x0403022003 0x0403022004 . . . . . . Cứ thế gửi cho đến khi đọc hết thông tin. Nhiệm vụ tiếp theo Bây giờ đã rõ hết cấu trúc bản tin. Nhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết. Parse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh. Suy nghĩ: Lúc trước mình có xem một video về các công cụ hardware hacking dành cho việc Firmware Reverse, thì Logic Analyzer là một trong các công cụ đó. Mình thấy một Hardware Engineer công việc cũng giống như một IoT Hacker, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế. Chỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,\u0026hellip; Mình có thể mường tưởng ra cách Trung Quốc họ copy: Mua sản phẩm Kiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng) Dịch ngược bằng cách: bắt tín hiệu xung, dump firmware. Đến bây giờ mình mới có thể hiểu. =]] ",
      "content_html": "\u003ch3 id=\"giới-thiệu\"\u003eGiới thiệu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCR95\u003c/strong\u003e là dòng chip dùng để đọc \u003cstrong\u003eRFID\u003c/strong\u003e và \u003cstrong\u003eNFC\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eCác thiết bị Giám sát hành trình theo \u003cstrong\u003eQCVN31\u003c/strong\u003e đều phải có bộ RFID, để đọc thẻ tài xế.\u003c/li\u003e\n\u003cli\u003eCông ty đang dùng một bộ RFID với dòng chip cũ, nên sếp yêu cầu thiết kế và nghiên cứu dùng loại \u003cstrong\u003eIC CR95\u003c/strong\u003e (vì loại này rất phổ biến, và hầu hết các thiết bị tracking có RFID đều dùng loại này).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"yêu-cầu\"\u003eYêu cầu:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNghiên cứu dùng STM32F103 + CR95, kết nối thông qua UART.\u003c/li\u003e\n\u003cli\u003eDùng ngôn ngữ lập trình Rust để viết Firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"research\"\u003eResearch\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi tìm hiểu các library dùng cho CR95, thì mình thấy rằng hầu hết đều dùng chuẩn kết nối là \u003cstrong\u003eSPI\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình cần xem lại \u003ca href=\"https://www.st.com/resource/en/datasheet/cr95hf.pdf\"\u003edatasheet của CR95\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eVề phần cứng thì mình không cần phải lo (vì đã có một anh (anh Sơn) trong cty lo về hardware), nhiệm vụ của mình là cần tìm hiều cách đọc bản tin, giao tiếp và viết firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"may-mắn-thay\"\u003eMay mắn thay\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước có một anh khác trong cty (anh này cũng tên Vinh và hiện tại thì đã off) đã làm được và kết nối thành công với CR95 bằng UART.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSource code\u003c/strong\u003e anh này được viết \u003cstrong\u003ebằng C\u003c/strong\u003e, mình đọc source code, kết hợp với việc đọc lại datasheet và test command trên một \u003ca href=\"http://www.tme.vn/product.aspx?id=2095#page=pro_info\"\u003eboard phần cứng CR95 khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/CR95HF-BRD.jpg\"\n  alt=\"CR95HF-BRD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSau khi thử và test thì mình tìm được gần như tất cả các command giao tiếp, đó là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eEcho: 0x55\nInfo: 0x0100\nSet Protocol: 0x02020109\nSendRecv: 0x0403022000\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTới đây thì mình \u003cstrong\u003ebó tay\u003c/strong\u003e, không hiều làm sao mà có thể đọc được \u003cstrong\u003ethông tin ID, tên tài xế, giấy phép lái xe\u003c/strong\u003e của thẻ RFID\u003c/li\u003e\n\u003cli\u003eVà mình vướng, mình đã dùng khá nhiều cách như: đọc bản tin giao tiếp qua lại, giả lập bản tin hex,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eNhưng kết quả đều không rõ ràng và không còn ý tưởng nào để làm tiếp.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"đọc-tín-hiệu-xung\"\u003eĐọc tín hiệu xung\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi gần như bế tắc thì anh Sơn đã gợi ý là \u003cstrong\u003eđọc tín hiệu xung\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà mình nhớ ra là mình có công cụ để làm điều đó, đó là dùng \u003ca href=\"https://hshop.vn/products/mach-usb-saleae-8ch-24mhz-logic-analyzer\"\u003eboard logic analyzer\u003c/a\u003e\n\u003cimg\n  src=\"https://product.hstatic.net/1000069225/product/c583f4e0-da4c-4abe-9e29-16844f44de69_1_201_a_9a3822254fa44d8e9e2fb043ec157eaf_1024x1024.jpg\"\n  alt=\"logic analyzer\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/li\u003e\n\u003cli\u003eBoard này tức nhiên là không bằng cách máy Oscilloscope, nhưng bù lại \u003ca href=\"https://www.saleae.com/pages/downloads\"\u003ephần mềm hỗ trợ\u003c/a\u003e cho board này lại cực xịn (đánh giá cá nhân).\u003c/li\u003e\n\u003cli\u003eTừ \u003cstrong\u003ehình 1\u003c/strong\u003e và \u003cstrong\u003ehình 2\u003c/strong\u003e là mình biết rằng những lệnh command ban đầu của mình đã đúng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_1.png\"\n  alt=\"CR95-Hinh_1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_2.png\"\n  alt=\"CR95-Hinh_2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTiếp đến là bước quan trọng, đó là việc đọc thông tin thẻ tài xế:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/Research_CR95/Hinh_3.png\"\n  alt=\"CR95-Hinh_3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCuối cùng mình cũng đã biết nguyên nhân mình bị thiếu. Đó là mỗi lần gửi \u003cstrong\u003eSendRecv\u003c/strong\u003e thì nó chỉ đọc được số lượng \u003cstrong\u003ebyte\u003c/strong\u003e nhất định, nên để đọc được hết thông tin thì mình cần gửi:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e0x0403022000\n0x0403022001\n0x0403022002\n0x0403022003\n0x0403022004\n.\n.\n.\n.\n.\n.\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eCứ thế gửi cho đến khi đọc hết thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nhiệm-vụ-tiếp-theo\"\u003eNhiệm vụ tiếp theo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBây giờ đã rõ hết cấu trúc bản tin.\u003c/li\u003e\n\u003cli\u003eNhiệm vụ tiếp theo là mình cần viết lại một library bằng Rust giao tiếp với CR95 với những command đã biết.\u003c/li\u003e\n\u003cli\u003eParse data để lấy những dữ liệu cần thiết, và gửi format lại thành một cấu trúc bản tin hoàn chỉnh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"suy-nghĩ\"\u003eSuy nghĩ:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLúc trước mình có xem một video về các công cụ hardware hacking dành cho việc \u003cstrong\u003eFirmware Reverse\u003c/strong\u003e, thì \u003cstrong\u003eLogic Analyzer\u003c/strong\u003e là một trong các công cụ đó.\u003c/li\u003e\n\u003cli\u003eMình thấy một \u003cstrong\u003eHardware Engineer\u003c/strong\u003e công việc cũng giống như một \u003cstrong\u003eIoT Hacker\u003c/strong\u003e, cũng dựa trên các công cụ và hiểu biết để nghiên cứu hành vi, hiểu rõ cơ chế.\u003c/li\u003e\n\u003cli\u003eChỉ có nghiên cứu sản phẩm thôi mà cũng thấy mệt mệt rồi, đọc tài liệu, phân tích mã hex, đọc xung,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eMình có thể mường tưởng ra cách Trung Quốc họ copy:\n\u003cul\u003e\n\u003cli\u003eMua sản phẩm\u003c/li\u003e\n\u003cli\u003eKiểm tra loại chip (soi bằng kính hiển vi, hoặc đoán dựa trên tính năng)\u003c/li\u003e\n\u003cli\u003eDịch ngược bằng cách: bắt tín hiệu xung, dump firmware.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐến bây giờ mình mới có thể hiểu. =]]\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/research_cr95/",
      "date_published": "28076-28-09T712:2828:00+07:00",
      "date_modified": "28076-28-09T712:2828:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "3773da73191fa8a6069587b66c683bd684be80dd",
      "title": "Tails_OS",
      "summary": "",
      "content_text": "Ẩn danh - Anonymous Mình có đọc hết cuốn Nghệ Thuật Ẩn Mình, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay. Tựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.\nDùng sóng di động (nói chung là dùng sim4G) Sử dụng VPN, Proxy. Sử dụng Tor Browser Hôm nay khi xem video trên Youtube, thì mình biết đến Tails\nHow To Access the DARK WEB in 2024 (3 Levels) Tails Linux USB with Persistence (Be invisible online in 7 minutes) Tails OS Tails tương tự như việc mình chạy một hệ điều hành song song vậy (và ở đây là trên USB). Bản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như Tor Browser. Như mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,\u0026hellip; Ngay cả khi mình tắt máy, thì những thông tin đó vẫn được lưu trữ trên RAM. Và đây là lúc Tails phát huy ưu điểm nổi bật chính là không lưu trữ bất kỳ thứ gì sau khi tắt máy. Tức là những thao tác trên máy, thông tin hoặc vô tình bị dính malware đều sẽ biến mất hết khi mình rút USB. HAY THẬT Suy nghĩ về Ẩn danh Nói ẩn danh cho vui vậy thôi, chứ nhà nước mà muốn mò ra thì mò cái một. Đơn giản là vì nhà mạng nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là vấn đề thời gian. Do đó nếu muốn ẩn danh thật sự thì tốt nhất đừng làm gì liên quan đến Chính phủ. =]] Mình thì không có nhu cầu vào Dark Web, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên Tails OS vẫn là một biện pháp hay ho khi mình muốn làm gì đó mà không muốn người khác biết. ",
      "content_html": "\u003ch3 id=\"ẩn-danh---anonymous\"\u003eẨn danh - Anonymous\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMình có đọc hết cuốn \u003ca href=\"https://tiki.vn/nghe-thuat-an-minh-p8845822.html\"\u003eNghệ Thuật Ẩn Mình\u003c/a\u003e, là một người đang dấn thân vào mảng Security thì cuốn này cũng hay.\n\u003cimg\n  src=\"https://salt.tikicdn.com/cache/750x750/ts/product/47/4b/45/6386ab1926fd23aad2b93d8f83429769.jpg.webp\"\n  alt=\"Nghệ Thuật Ẩn Mình\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTựu chung thì mình nắm được vài keywork khi muốn truy cập ẩn danh trên Internet.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDùng sóng di động (nói chung là \u003cstrong\u003edùng sim4G\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003eSử dụng VPN, Proxy.\u003c/li\u003e\n\u003cli\u003eSử dụng \u003ca href=\"https://www.torproject.org/download/\"\u003eTor Browser\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHôm nay khi xem video trên Youtube, thì mình biết đến \u003ca href=\"https://tails.net/\"\u003eTails\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=U2-JPqrALsA\u0026amp;list=WL\u0026amp;index=2\"\u003eHow To Access the DARK WEB in 2024 (3 Levels)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=gO9fTnMxwYw\"\u003eTails Linux USB with Persistence (Be invisible online in 7 minutes)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tails-os\"\u003eTails OS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTails\u003c/strong\u003e tương tự như việc mình chạy một \u003cstrong\u003ehệ điều hành\u003c/strong\u003e song song vậy (và ở đây là trên USB).\u003c/li\u003e\n\u003cli\u003eBản thân OS này đã tích hợp sẵn các công cụ ẩn danh khác như \u003cstrong\u003eTor Browser\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eNhư mình được biết thì với OS thông thường như Windows, những thao tác của chúng ta sẽ được lưu trữ lại trên máy như lúc duyệt web, cài phần mềm,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eNgay cả khi mình tắt máy, thì những thông tin đó vẫn được \u003cstrong\u003elưu trữ trên RAM\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà đây là lúc \u003cstrong\u003eTails\u003c/strong\u003e phát huy ưu điểm nổi bật chính là \u003cstrong\u003ekhông lưu trữ bất kỳ thứ gì sau khi tắt máy\u003c/strong\u003e. Tức là những thao tác trên máy, thông tin hoặc vô tình \u003cstrong\u003ebị dính malware\u003c/strong\u003e đều sẽ biến mất hết khi mình rút USB.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHAY THẬT\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"suy-nghĩ-về-ẩn-danh\"\u003eSuy nghĩ về Ẩn danh\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNói \u003cstrong\u003eẩn danh\u003c/strong\u003e cho vui vậy thôi, chứ nhà nước mà muốn \u003cstrong\u003emò\u003c/strong\u003e ra thì mò cái một. Đơn giản là vì \u003cstrong\u003enhà mạng\u003c/strong\u003e nằm dưới quyền kiểm soát của chính phủ, tìm ra mình chỉ là \u003cstrong\u003evấn đề thời gian\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDo đó nếu muốn \u003cstrong\u003eẩn danh thật sự\u003c/strong\u003e thì tốt nhất đừng làm gì liên quan đến \u003cstrong\u003eChính phủ\u003c/strong\u003e. =]]\u003c/li\u003e\n\u003cli\u003eMình thì không có nhu cầu vào \u003cstrong\u003eDark Web\u003c/strong\u003e, những thông tin search trên google thôi đã quá rộng lớn đối với mình rồi. Tuy nhiên \u003cstrong\u003eTails OS\u003c/strong\u003e vẫn là một biện pháp hay ho khi mình \u003cstrong\u003emuốn làm gì đó mà không muốn người khác biết\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Google_vs_DuckDuckGo.jpg\"\n  alt=\"Search\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/tails_os/",
      "date_published": "21076-21-09T734:2121:00+07:00",
      "date_modified": "21076-21-09T734:2121:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "7966a7585a1eca2b3277bf71ec1d0a822315c7b7",
      "title": "Suy_nghi_ve_Hardware_Hacking",
      "summary": "",
      "content_text": "Sau khi mình đã đọc hết cuốn Vùng tối. Những hacker đời đầu chính là các nhà vật lý, những người kỹ sư, kỹ thuật điện tử.\nKhi thế giới vẫn còn điện tử tương tự, các điệp viên đã dùng các kỹ thuật để chặn, bắt tín hiệu.\nĐể rồi khi thế giới chuyển sang điện tử số, sự ra đời của internet. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,\u0026hellip;\nDạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.\nCũng như trong Show Ryan: What Does a Former Black Hat Hacker Carry Everyday? có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể thu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu. Mình nhớ kỹ thuật này gọi là Relay Atack\nLà một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự quá hay và ghê gớm.\nNgười làm ra những thiết bị này đúng là tay chơi về phần cứng, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.\nLà hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.\nMình cần rèn luyện kỹ năng, và ghi nhớ Hack to learn and not Learn to Hack.\nMột bài viết khác về Hardware hacking - Tấn công HID Tổng hợp các tài liệu về IoT Hacking: https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/ https://v33ru.github.io/IoTSecurity101/ https://github.com/nebgnahz/awesome-iot-hacks https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme https://www.iotpentestingguide.com/ https://p.ost2.fyi/courses IoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.\nCó lẻ vậy.\nTổng hợp các ý hay trong cuốn Vùng tối Nền tảng của Tác chiến Thông tin: Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.\nCNE (Computer Network Exploitation) - Khai thác Mạng máy tính: Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.\n",
      "content_html": "\u003cp\u003eSau khi mình đã đọc hết cuốn \u003ca href=\"https://tiki.vn/khoa-hoc-kham-pha-vung-toi-lich-su-bi-an-cua-chien-tranh-mang-p251393388.html\"\u003eVùng tối\u003c/a\u003e. Những \u003cstrong\u003ehacker đời đầu\u003c/strong\u003e chính là các \u003cstrong\u003enhà vật lý\u003c/strong\u003e, những người \u003cstrong\u003ekỹ sư, kỹ thuật điện tử\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://salt.tikicdn.com/cache/540x540/ts/product/46/60/43/e4ff35baeeaf8bb049e0c864e6132c6b.jpg\"\n  alt=\"Vùng tối - Book\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eKhi thế giới vẫn còn \u003cstrong\u003eđiện tử tương tự\u003c/strong\u003e, các điệp viên đã dùng các kỹ thuật để \u003cstrong\u003echặn, bắt tín hiệu\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eĐể rồi khi thế giới chuyển sang \u003cstrong\u003eđiện tử số\u003c/strong\u003e, sự ra đời của \u003cstrong\u003einternet\u003c/strong\u003e. Các kỹ thuật Hacking dần dần chuyển thành software, web hacking,\u0026hellip;\u003c/p\u003e\n\u003cp\u003eDạo gần đây, sự trỗi dậy của IoT, các vấn đề về Hardware đã dần quay trở lại.\u003c/p\u003e\n\u003cp\u003eCũng như trong \u003ca href=\"https://www.youtube.com/watch?v=7MIoFxwawc0\u0026amp;list=WL\u0026amp;index=4\u0026amp;t=1s\"\u003eShow Ryan: What Does a Former Black Hat Hacker Carry Everyday?\u003c/a\u003e có giới thiệu, chỉ với các thiết bị nhỏ như vậy, đã có thể \u003cstrong\u003ethu thập, chặn bắt tín hiệu RF và giả mạo tín hiệu\u003c/strong\u003e. Mình nhớ kỹ thuật này gọi là \u003cstrong\u003eRelay Atack\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLà một người yêu thích điện tử và hacking, mình thấy những thiết bị này thật sự \u003cstrong\u003equá hay và ghê gớm\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNgười làm ra những thiết bị này đúng là \u003cstrong\u003etay chơi về phần cứng\u003c/strong\u003e, không những hiểu về tín hiệu RF, mà còn giỏi về phần cứng và cả về Firmware.\u003c/p\u003e\n\u003cp\u003eLà hacker thì đi hack người khác thì có vẻ vui đấy. Nhưng là người làm về sản phẩm phần cứng, mình mà bị hack thì đó lại là câu chuyện khác.\u003c/p\u003e\n\u003cp\u003eMình cần rèn luyện kỹ năng, và ghi nhớ \u003cstrong\u003eHack to learn and not Learn to Hack\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"một-bài-viết-khác-về-hardware-hacking---tấn-công-hidhttpswhitehatvnthreadstan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao18012\"\u003e\u003ca href=\"https://whitehat.vn/threads/tan-cong-hid-la-gi-minh-da-de-dang-che-tao-usb-theo-doi-danh-cap-du-lieu-nhu-the-nao.18012/\"\u003eMột bài viết khác về Hardware hacking - Tấn công HID\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-tài-liệu-về-iot-hacking\"\u003eTổng hợp các tài liệu về IoT Hacking:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/\"\u003ehttps://www.linkedin.com/feed/update/urn:li:activity:7219979516855664640/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://v33ru.github.io/IoTSecurity101/\"\u003ehttps://v33ru.github.io/IoTSecurity101/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/nebgnahz/awesome-iot-hacks\"\u003ehttps://github.com/nebgnahz/awesome-iot-hacks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme\"\u003ehttps://github.com/CyberSecurityUP/Awesome-Hardware-and-IoT-Hacking#readme\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.iotpentestingguide.com/\"\u003ehttps://www.iotpentestingguide.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://p.ost2.fyi/courses\"\u003ehttps://p.ost2.fyi/courses\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIoT Hacking hay Hardware Hacking có vẻ chính là con đường giao thoa, thỏa mãn cả 2 yếu tố Điện tử/IoT và Cyber-Security.\u003c/p\u003e\n\u003cp\u003eCó lẻ vậy.\u003c/p\u003e\n\u003ch3 id=\"tổng-hợp-các-ý-hay-trong-cuốn-vùng-tối\"\u003eTổng hợp các ý hay trong cuốn \u003cstrong\u003eVùng tối\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eNền tảng của Tác chiến Thông tin:\u003c/strong\u003e Bất kỳ hành động nào để làm nghẽn, khai thác, thao túng, hoặc phá hủy thông tin của kẻ thù và hoạt động của nó. Với mục tiêu cuối cùng là làm suy giảm ý chí hoặc khả năng chiến đấu của quân địch.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCNE (Computer Network Exploitation) - Khai thác Mạng máy tính:\u003c/strong\u003e Sử dụng máy tính để khai thác lỗ hổng trong các hệ thống mạng của kẻ thù - xâm nhập vào các mạng đó, nhằm thu thập thêm thông tin tình báo.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_0.jpg\"\n  alt=\"Hình 0\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_1.jpg\"\n  alt=\"Hình 1\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_2.jpg\"\n  alt=\"Hình 2\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_3.jpg\"\n  alt=\"Hình 3\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_4.jpg\"\n  alt=\"Hình 4\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Hardware_Hacking/Hinh_5.jpg\"\n  alt=\"Hình 5\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/suy_nghi_ve_hardware_hacking/",
      "date_published": "10076-10-09T734:1010:00+07:00",
      "date_modified": "10076-10-09T734:1010:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c4bdccacc5a8e26c6238ec72e87ccc4b188451b2",
      "title": "Goc_nhin_ve_Ngoai_ngu",
      "summary": "",
      "content_text": "Một góc nhìn cá nhân về Ngoại ngữ Là một người thiên về Khoa học Kỹ thuật thì với mình, Ngoại ngữ là một công cụ. Mình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là một cái gì đó. Tại sao mình có suy nghĩ Ngoại ngữ là một công cụ Thú thật thì mình là một đứa ngu ngốc về ngoại ngữ (cụ thể là Anh văn). Chả biết là do mình yếu Anh văn \u0026ndash;\u0026gt; Không coi trọng, hay là vì Không coi trọng \u0026ndash;\u0026gt; Yếu Anh văn ??? Nhưng có một điều chắc chắn là mình biết anh văn quan trọng, nhưng chưa phải là yếu tố quyết định. Mục tiêu của mình đối với Anh văn chỉ đơn giản, đó là cầu nối với kiến thức của nhân loại. Anh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì. Tại sao lại thế? Mình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có sự yêu thích và đam mê nhất định thì mới theo được. Mình cũng vậy, khi có sự yêu thích sẽ dẫn đến nhu cầu tìm hiểu, học hỏi cái mới. Và đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào: Search keyword bằng tiếng anh. Đọc hiểu tài liệu tiếng anh. Đó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân). Một tình huống hài hước khác. Có những lúc đi hội thảo, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh. Có những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày. Nhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu: Ông này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.\nSuy nghĩ khác Nếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì Trời đất, họ sẽ thăng tiến kinh lắm. Chưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là leader, Manager,\u0026hellip; Lương sẽ khủng lắm đây. Mà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.\nNgười ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân.\n",
      "content_html": "\u003ch2 id=\"một-góc-nhìn-cá-nhân-về-ngoại-ngữ\"\u003eMột \u003cstrong\u003egóc nhìn cá nhân\u003c/strong\u003e về Ngoại ngữ\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLà một người thiên về Khoa học Kỹ thuật thì với mình, \u003cstrong\u003eNgoại ngữ là một công cụ\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMình có gặp một vài người cũng là dân kỹ thuật, nhung họ có cái nhìn khác, họ rất coi trọng ngoại ngữ. Với họ ngoại ngữ không chỉ là công cụ, mà là \u003cstrong\u003emột cái gì đó\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-mình-có-suy-nghĩ-ngoại-ngữ-là-một-công-cụ\"\u003eTại sao mình có suy nghĩ \u003cstrong\u003eNgoại ngữ là một công cụ\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eThú thật thì mình là một đứa \u003cstrong\u003engu ngốc\u003c/strong\u003e về ngoại ngữ (cụ thể là \u003cstrong\u003eAnh văn\u003c/strong\u003e).\u003c/li\u003e\n\u003cli\u003eChả biết là do mình \u003cstrong\u003eyếu Anh văn \u0026ndash;\u0026gt; Không coi trọng\u003c/strong\u003e, hay là vì \u003cstrong\u003eKhông coi trọng \u0026ndash;\u0026gt; Yếu Anh văn\u003c/strong\u003e ???\u003c/li\u003e\n\u003cli\u003eNhưng có một điều chắc chắn là mình biết \u003cstrong\u003eanh văn quan trọng\u003c/strong\u003e, nhưng chưa phải là \u003cstrong\u003eyếu tố quyết định\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eMục tiêu của mình đối với Anh văn chỉ đơn giản, đó là \u003cstrong\u003ecầu nối với kiến thức của nhân loại\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eAnh văn là một công cụ vô cùng hữu ích cho việc mở mang tri thức, có thì quá tốt, nhưng nếu không thì cũng chả có vấn đề gì.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tại-sao-lại-thế\"\u003eTại sao lại thế?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMình không biết những ngành nghề khác như thế nào, nhưng với dân kỹ thuật thì phải có \u003cstrong\u003esự yêu thích và đam mê nhất định\u003c/strong\u003e thì mới theo được.\u003c/li\u003e\n\u003cli\u003eMình cũng vậy, khi có sự yêu thích sẽ dẫn đến \u003cstrong\u003enhu cầu tìm hiểu, học hỏi cái mới\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eVà đó chính là lúc mình cần đến ngoại ngữ. Lúc này mình chỉ tập trung vào:\n\u003cul\u003e\n\u003cli\u003eSearch keyword bằng tiếng anh.\u003c/li\u003e\n\u003cli\u003eĐọc hiểu tài liệu tiếng anh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eĐó là tất cả những gì mình cần đối với Anh văn (mình vẫn trau dồi vốn từ vựng cho bản thân).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-tình-huống-hài-hước-khác\"\u003eMột tình huống hài hước khác.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCó những lúc đi \u003cstrong\u003ehội thảo\u003c/strong\u003e, khách mời là người nước ngoài, nên khi họ trình bày sẽ bằng tiếng Anh.\u003c/li\u003e\n\u003cli\u003eCó những tai nghe để sẵn, mục tiêu là để phiên dịch ra cho người nghe hiểu nội dung đang trình bày.\u003c/li\u003e\n\u003cli\u003eNhưng đôi khi mình nghe phiên dịch thì suy nghĩ mình kiểu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eÔng này dịch chán thế nhỉ, tôi đọc slide và tìm keyword thôi cũng hiểu kha khá nội dung rồi.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"suy-nghĩ-khác\"\u003eSuy nghĩ khác\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNếu một người vừa có chuyên môn, vừa giỏi ngoại ngữ thì \u003cstrong\u003eTrời đất, họ sẽ thăng tiến kinh lắm\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eChưa kể, nếu giỏi ngoại ngữ mà còn có thêm kỹ năng mềm như quản lý, thì họ sẽ là \u003cstrong\u003eleader\u003c/strong\u003e, \u003cstrong\u003eManager\u003c/strong\u003e,\u0026hellip;\u003c/li\u003e\n\u003cli\u003eLương sẽ khủng lắm đây.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMà thôi, tiền nhiều thì sẽ gắn với nhiều trách nhiệm.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNgười ta sao thì kệ họ, mình theo hướng Chuyên môn hóa, và Ngoại ngữ vẫn chỉ là Công cụ để mình mở rộng cái giếng của bản thân\u003c/strong\u003e.\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/others/goc_nhin_ve_ngoai_ngu/",
      "date_published": "7076-07-09T73:77:00+07:00",
      "date_modified": "7076-07-09T73:77:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4fa8cc860c52b268dc6a3adcde7305e9415db5bb",
      "title": "Tools",
      "summary": "",
      "content_text": "Tool: Git-Dumper Trong quá trình recon một trang web, mà mình thấy có đường dẫn .git Thì có thể dùng tool git-dumper này để lấy thông tin. Tool Web Check Đây là một công cụ có thể sử dụng online, hoặc build ở local. Công cụ này giúp mình recon những thông số cơ bản của một trang web. Tài liệu: 1. https://github.com/lissy93/web-check 2. https://web-check.xyz/about#api-documentation Caido Công cụ này có chức năng tương tự như Burp-Suite, nhưng mà là ở giao diện Web. Tham khảo Youtube: How to Hack Web Apps with Caido Tài liệu: Docs Github Project Một bài viết về các bài lab cho công cụ Caido Labs Caido Cuckoo Sandbox https://cuckoosandbox.org/download https://cuckoo.sh/docs/ https://cuckoo.sh/docs/installation/host/requirements.html https://cuckoosandbox.org/blog/207-interim-release Bunkerweb - WAF https://github.com/bunkerity/bunkerweb https://www.bunkerweb.io/ https://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview https://demo.bunkerweb.io/ https://www.youtube.com/@bunkerity4183/videos Nettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management Github Project: Nettacker Documents: https://owasp.org/www-project-nettacker/ Note: Nhìn chung mình thấy tool này khá giống với tool reNgine, hoặc một số công cụ auto-scan khác. AESCrypt: Công cụ mã hóa file Đây là một phần mềm mã nguồn mở, hỗ trợ mã hóa file. Video giới thiệu về công cụ này: AESCrypt - Mã hoá file Một bài viết khác ",
      "content_html": "\u003ch3 id=\"tool-git-dumperhttpsgithubcomarthaudgit-dumper\"\u003e\u003ca href=\"https://github.com/arthaud/git-dumper\"\u003eTool: Git-Dumper\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTrong quá trình \u003cstrong\u003erecon\u003c/strong\u003e một trang web, mà mình thấy có đường dẫn \u003ccode\u003e.git\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThì có thể dùng tool \u003cstrong\u003egit-dumper\u003c/strong\u003e này để lấy thông tin.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tool-web-checkhttpsweb-checkxyz\"\u003e\u003ca href=\"https://web-check.xyz/\"\u003eTool Web Check\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một công cụ có thể sử dụng online, hoặc build ở local.\u003c/li\u003e\n\u003cli\u003eCông cụ này giúp mình recon những thông số cơ bản của một trang web.\u003c/li\u003e\n\u003cli\u003eTài liệu:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. https://github.com/lissy93/web-check\n2. https://web-check.xyz/about#api-documentation\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"caidohttpscaidoio\"\u003e\u003ca href=\"https://caido.io/\"\u003eCaido\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCông cụ này có chức năng tương tự như \u003cstrong\u003eBurp-Suite\u003c/strong\u003e, nhưng mà là ở \u003cstrong\u003egiao diện Web\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=5Di0VVK9JiQ\u0026amp;list=WL\u0026amp;index=2\"\u003eTham khảo Youtube: How to Hack Web Apps with Caido\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eTài liệu:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.caido.io/\"\u003eDocs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/caido\"\u003eGithub Project\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.linkedin.com/feed/update/urn:li:activity:7376427265586311168/\"\u003eMột bài viết về các bài lab cho công cụ \u003cstrong\u003eCaido\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://labs.cai.do/\"\u003eLabs Caido\u003c/a\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Tools/Labs_Caido.png\"\n  alt=\"Labs Caido\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003ch3 id=\"cuckoo-sandbox\"\u003eCuckoo Sandbox\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ehttps://cuckoosandbox.org/download\nhttps://cuckoo.sh/docs/\nhttps://cuckoo.sh/docs/installation/host/requirements.html\nhttps://cuckoosandbox.org/blog/207-interim-release\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"bunkerweb---waf\"\u003eBunkerweb - WAF\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/bunkerity/bunkerweb\"\u003ehttps://github.com/bunkerity/bunkerweb\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.bunkerweb.io/\"\u003ehttps://www.bunkerweb.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview\"\u003ehttps://docs.bunkerweb.io/latest/?utm_campaign=self\u0026amp;utm_source=bunkerwebio#overview\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://demo.bunkerweb.io/\"\u003ehttps://demo.bunkerweb.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/@bunkerity4183/videos\"\u003ehttps://www.youtube.com/@bunkerity4183/videos\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nettacker-automated-penetration-testing-framework---open-source-vulnerability-scanner---vulnerability-management\"\u003eNettacker: Automated Penetration Testing Framework - Open-Source Vulnerability Scanner - Vulnerability Management\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGithub Project: \u003ca href=\"https://github.com/OWASP/Nettacker\"\u003eNettacker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDocuments: \u003ca href=\"https://owasp.org/www-project-nettacker/\"\u003ehttps://owasp.org/www-project-nettacker/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Nhìn chung mình thấy tool này khá giống với tool \u003cstrong\u003ereNgine\u003c/strong\u003e, hoặc một số công cụ auto-scan khác.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"aescrypthttpswwwaescryptcom-công-cụ-mã-hóa-file\"\u003e\u003ca href=\"https://www.aescrypt.com/\"\u003eAESCrypt\u003c/a\u003e: Công cụ mã hóa file\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eĐây là một phần mềm \u003cstrong\u003emã nguồn mở\u003c/strong\u003e, hỗ trợ mã hóa file.\u003c/li\u003e\n\u003cli\u003eVideo giới thiệu về công cụ này: \u003ca href=\"https://www.youtube.com/watch?v=zA4dDlslDXo\"\u003eAESCrypt - Mã hoá file\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://services.udel.edu/TDClient/32/Portal/KB/ArticleDet?ID=366\"\u003eMột bài viết khác\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/tools/",
      "date_published": "6076-06-09T736:66:00+07:00",
      "date_modified": "6076-06-09T736:66:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4f09e909e9a87e6f4fa1e981ddc482695a0ed92a",
      "title": "TheHive",
      "summary": "",
      "content_text": " Theo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình: Phát hiện Báo cáo Xử lý Công cụ TheHive là nằm trong giai đoạn 2. Ví dụ dễ hiểu như sau: Khi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này. Nếu không xử lý được, hoặc mức độ phức tạp cao thì tạo Ticket mô tả và cung cấp đầy đủ thông tin. (Giai đoạn này là bước sử dụng TheHive). Người có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý. TheHive TheHive cũng có chức năng như JIRA, tuy nhiên TheHive là open-source. Documents: - https://thehive-project.org/ - http://docs.thehive-project.org/cortex/ - https://github.com/thehive-project/Cortex/ - https://blog.thehive-project.org/ - https://docs.thehive-project.org/ - https://github.com/TheHive-Project/Cortex Tham khảo TheHive với Graylog - https://blog.reconinfosec.com/integrating-graylog-with-thehive - https://github.com/ReconInfoSec/graylog2thehive ",
      "content_html": "\u003cul\u003e\n\u003cli\u003eTheo mình nghiên cứu và hiểu thì SOC sẽ gồm các quá trình:\n\u003cul\u003e\n\u003cli\u003ePhát hiện\u003c/li\u003e\n\u003cli\u003eBáo cáo\u003c/li\u003e\n\u003cli\u003eXử lý\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCông cụ \u003cstrong\u003eTheHive\u003c/strong\u003e là nằm trong giai đoạn 2.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ví-dụ-dễ-hiểu-như-sau\"\u003eVí dụ dễ hiểu như sau:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eKhi nhận cảnh báo về một sự kiện nào đó, nhân viên A sẽ làm check và xử lý cơ bản tác vụ này.\u003c/li\u003e\n\u003cli\u003eNếu không xử lý được, hoặc mức độ phức tạp cao thì tạo \u003cstrong\u003eTicket\u003c/strong\u003e mô tả và cung cấp đầy đủ thông tin.\n(Giai đoạn này là bước sử dụng \u003cstrong\u003eTheHive\u003c/strong\u003e).\u003c/li\u003e\n\u003cli\u003eNgười có trách nhiệm, hoặc chuyên môn cao sẽ nhận ticket này và tiếp tục xử lý.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"thehive\"\u003eTheHive\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTheHive cũng có chức năng như \u003cstrong\u003eJIRA\u003c/strong\u003e, tuy nhiên TheHive là \u003cstrong\u003eopen-source\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eDocuments:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- https://thehive-project.org/\n- http://docs.thehive-project.org/cortex/\n- https://github.com/thehive-project/Cortex/\n- https://blog.thehive-project.org/\n- https://docs.thehive-project.org/\n- https://github.com/TheHive-Project/Cortex\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tham-khảo-thehive-với-graylog\"\u003eTham khảo TheHive với Graylog\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e- https://blog.reconinfosec.com/integrating-graylog-with-thehive\n- https://github.com/ReconInfoSec/graylog2thehive\n\u003c/code\u003e\u003c/pre\u003e",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/thehive/",
      "date_published": "15066-15-09T64:1515:00+07:00",
      "date_modified": "15066-15-09T64:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "d301d9e6e4aeff77c37f37bb07966a98039f0832",
      "title": "OSINT",
      "summary": "",
      "content_text": "OSINT - Open Source Intelligence Bước đầu tiên trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là thu thập các thông tin giá trị về mục tiêu. Thu thập thông tin thì có 2 dạng là: Passive Reconnaissance - Thu thập thông tin thụ động Active Reconnaissance - Thu thập thông tin chủ động Trong đó việc thu thập thông tin thụ động thường được gọi là OSINT. Bất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí. Others Documents https://www.hackers-arise.com/osint Top 10 công cụ OSINT tốt nhất 2020 Một số công cụ theo OSINT Framework mà mình biết: VirusTotal Shodan Wayback Machine ANY.RUN ",
      "content_html": "\u003ch3 id=\"osint---open-source-intelligencehttpsanonyvietcomosint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet\"\u003e\u003ca href=\"https://anonyviet.com/osint-la-gi-osint-duoc-su-dung-nhu-the-nao-de-truy-vet-qua-internet/\"\u003eOSINT - Open Source Intelligence\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBước đầu tiên\u003c/strong\u003e trong một cuộc tấn công có chủ đích – hoặc kiểm tra thâm nhập của Red Team – là \u003cstrong\u003ethu thập các thông tin\u003c/strong\u003e giá trị về mục tiêu.\u003c/li\u003e\n\u003cli\u003eThu thập thông tin thì có 2 dạng là:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePassive Reconnaissance - Thu thập thông tin thụ động\nActive Reconnaissance - Thu thập thông tin chủ động\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eTrong đó việc \u003cstrong\u003ethu thập thông tin thụ động\u003c/strong\u003e thường được gọi là \u003cstrong\u003eOSINT\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eBất kỳ thông tin công khai nào được tìm thấy đều là OSINT cho dù đó là sách hoặc báo cáo, bài viết trên báo chí hay tuyên bố trong thông cáo báo chí.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"others-documents\"\u003eOthers Documents\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.hackers-arise.com/osint\"\u003ehttps://www.hackers-arise.com/osint\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://anonyviet.com/cac-tool-osint-truy-vet-toi-pham-tren-internet/\"\u003eTop 10 công cụ OSINT tốt nhất 2020\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"một-số-công-cụ-theo-osint-frameworkhttpsosintframeworkcom-mà-mình-biết\"\u003eMột số công cụ theo \u003ca href=\"https://osintframework.com/\"\u003eOSINT Framework\u003c/a\u003e mà mình biết:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.virustotal.com/gui/home/upload\"\u003eVirusTotal\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.shodan.io/\"\u003eShodan\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://archive.org/web/\"\u003eWayback Machine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://any.run/\"\u003eANY.RUN\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/osint/",
      "date_published": "15066-15-09T62:1515:00+07:00",
      "date_modified": "15066-15-09T62:1515:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "c63929f0d793b4d6bd0bdcf6149015836543e3ec",
      "title": "ESD",
      "summary": "",
      "content_text": "ESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện Là dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.\nĐây là một video nói về cách chống tĩnh điện, dựa trên các linh kiện:\nTVS - Transient Voltage Suppressor MOV - Metal Oxide Varistor GDT - Gas Discharge Tube TVS Diode Một video giải thích cách hoạt động của TVS Diode\nTrong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.\nMột ví dụ về linh kiện TVS, Semtech SMF05C.TCT\nMOV Linh kiện Bourns MOV-10D470KKTR GDT Linh kiện Bourns GDT25-47-S1-RP ",
      "content_html": "\u003ch2 id=\"esd-electrostatic-sensitive-devices---sự-phóng-tĩnh-điện\"\u003eESD (Electrostatic Sensitive Devices) - Sự phóng tĩnh điện\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLà dòng điện chạy đột ngột và tức thời giữa hai vật nhiễm điện do tiếp xúc, đoản mạch hoặc đánh thủng điện môi.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eĐây là một \u003ca href=\"https://www.youtube.com/watch?v=MzxBBXpgwrE\"\u003evideo\u003c/a\u003e nói về cách \u003cstrong\u003echống tĩnh điện\u003c/strong\u003e, dựa trên các linh kiện:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eTVS - Transient Voltage Suppressor\nMOV - Metal Oxide Varistor\nGDT - Gas Discharge Tube\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tvs-diode\"\u003eTVS Diode\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=oKACLpBYhxU\"\u003eMột video giải thích cách hoạt động của TVS Diode\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrong thiết kế bộ nguồn, TVS còn dùng để dập xung ổn định điện áp.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMột ví dụ về linh kiện TVS, \u003ca href=\"https://www.mouser.vn/ProductDetail/Semtech/SMF05C.TCT?qs=rBWM4%252BvDhIcdGOAFdL4XAA%3D%3D\u0026amp;_gl=1*109bc2w*_ga*ODE4NDU2NjY3LjE3MTM3NzI5OTI.*_ga_15W4STQT4T*MTcxMzc3Mjk5Mi4xLjAuMTcxMzc3Mjk5My41OS4wLjA.\"\u003eSemtech SMF05C.TCT\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mov\"\u003eMOV\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLinh kiện \u003ca href=\"https://www.mouser.vn/ProductDetail/Bourns/MOV-10D470KKTR?qs=ST9lo4GX8V0v1uLdRAW6Kg%3D%3D\u0026amp;_gl=1*17bo42l*_ga*MTY3MzQ3NTE2Ni4xNzEzNzcyOTg0*_ga_15W4STQT4T*MTcxMzc3Mjk4My4xLjEuMTcxMzc3Mjk5MC41My4wLjA.\"\u003eBourns MOV-10D470KKTR\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"gdt\"\u003eGDT\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLinh kiện \u003ca href=\"https://www.mouser.vn/ProductDetail/Bourns/GDT25-47-S1-RP?qs=2MMvu9PpTS3BszAgeO7ppQ%3D%3D\"\u003eBourns GDT25-47-S1-RP\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/ESD_Electronics.png\"\n  alt=\"ESD\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/esd/",
      "date_published": "25056-25-09T559:2525:00+07:00",
      "date_modified": "25056-25-09T559:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "fd7800093460ca577e6a1fdff2b8aa97568c6540",
      "title": "DFLab_VNCERT",
      "summary": "",
      "content_text": "Bài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC)) Bài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích log. Trong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân: Hayabusa Hayabusa là một công cụ xử lý nhanh Windows Event Log, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v\u0026hellip;\nGoAccess GoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.\nGet Started GoAccess\nHow to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04\n",
      "content_html": "\u003ch2 id=\"bài-viết---công-cụ-điều-tra-nhật-ký-sự-kiện-của-digital-forensics-lab---cục-an-toàn-thông-tin-vncertcchttpsdfirlabvndocstoolslog\"\u003e\u003ca href=\"https://df.irlab.vn/docs/tools/log/\"\u003eBài viết - Công cụ điều tra nhật ký sự kiện (của Digital Forensics Lab - Cục An toàn thông tin (VNCERT/CC))\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eBài viết cung cấp thông tin những công cụ hữu ích và miễn phí giúp thu thập và phân tích \u003cstrong\u003elog\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eTrong đó, mình thấy có những công cụ khá hay ho, có thể nghiên cứu sâu hơn và có thể tận dụng cho môi trường lab của bản thân:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hayabusahttpsgithubcomyamato-securityhayabusa\"\u003e\u003ca href=\"https://github.com/Yamato-Security/hayabusa\"\u003eHayabusa\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHayabusa là một công cụ xử lý nhanh \u003cstrong\u003eWindows Event Log\u003c/strong\u003e, tạo timeline và tìm kiếm mối đe dọa do Yamato Security ở Nhật Bản phát triển. Nó được viết bằng Rust và hỗ trợ xử lý đa luồng. Hayabusa có thể chạy trên các hệ thống đang hoạt động để phân tích trực tiếp, bằng cách thu thập Event Logs từ một hoặc nhiều hệ thống để phân tích ngoại tuyến hoặc bằng cách chạy công cụ Hayabusa với Velociraptor để tìm kiếm mối đe dọa và ứng phó sự cố trên quy mô lớn. Báo cáo là một timeline trên CSV để dễ dàng phân tích trong Excel, Timeline Explorer, Elastic Stack, Timesketch, v.v\u0026hellip;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"goaccesshttpsgithubcomallinurlgoaccess\"\u003e\u003ca href=\"https://github.com/allinurl/goaccess\"\u003eGoAccess\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGoAccess là trình phân tích nhật ký web, có thể quan sát theo thời gian thực và trình xem tương tác mã nguồn mở chạy trong terminal trong các hệ thống.. Cung cấp số liệu thống kê HTTP nhanh chóng và có giá trị cho các quản trị viên hệ thống yêu cầu báo cáo máy chủ trực quan một cách nhanh chóng.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://goaccess.io/get-started\"\u003eGet Started GoAccess\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=PbKpdHeuG2A\"\u003eHow to Install GoAccess Web Log Analyzer on Ubuntu 20.04 - 22.04\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/dflab_vncert/",
      "date_published": "25056-25-09T556:2525:00+07:00",
      "date_modified": "25056-25-09T556:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "8ab10c1348d533258955d2c165104e8fc6b6fb36",
      "title": "Firewall_CheckList",
      "summary": "",
      "content_text": "Có thể coi Firewall Checklist là phương pháp để mình Pentest Network Dùng các công cụ để test hạ tầng Network: Nmap Ettercap Firewalk Wireshark Check version của Firewall + CVE, tìm các cách khắc phục. Dựa vào file Firewall_Checklist để áp dụng cách đặt rule. Documents Firewall_Checklist ",
      "content_html": "\u003ch3 id=\"có-thể-coi-firewall-checklist-là-phương-pháp-để-mình-pentest-network\"\u003eCó thể coi \u003ccode\u003eFirewall Checklist\u003c/code\u003e là phương pháp để mình Pentest Network\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDùng các công cụ để test hạ tầng Network:\n\u003cul\u003e\n\u003cli\u003eNmap\u003c/li\u003e\n\u003cli\u003eEttercap\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kali.org/tools/firewalk/\"\u003eFirewalk\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eWireshark\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eCheck version của Firewall + CVE, tìm các cách khắc phục.\u003c/li\u003e\n\u003cli\u003eDựa vào file \u003cstrong\u003eFirewall_Checklist\u003c/strong\u003e để áp dụng cách đặt rule.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"documents-firewall_checklistdocsfirewallchecklistpdf\"\u003e\u003ca href=\"/docs/FirewallChecklist.pdf\"\u003eDocuments Firewall_Checklist\u003c/a\u003e\u003c/h3\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/CyberSecurity/Firewall_Cheatsheet.jpg\"\n  alt=\"Firewall Checklist\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/firewall_checklist/",
      "date_published": "25056-25-09T548:2525:00+07:00",
      "date_modified": "25056-25-09T548:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "a8e9a70dc4d226a2d6960103dadfbaf851de55b7",
      "title": "NIS2",
      "summary": "",
      "content_text": "Bài viết: Tuân thủ NIS2 cho các mạng công nghiệp NIS2 Compliance for Industries White Paper Tổng hợp các thông tin cần biết trong bài viết: Các phần tử kết nối mạng OT cần được chứng nhận an toàn:\nCác tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì. Vì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên. Đánh giá và xếp loại ưu tiên các rủi ro mạng OT:\nNhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ. NIS2 yêu cầu bạn có khả năng \u0026ldquo;nhìn xuyên thấu\u0026rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh. Triển khai Zero-trust:\nHầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2. Lưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn. ISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có. Đây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng. Triển khai Zero-trust remote access:\nThay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop\u0026hellip;) Hãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập. Phát hiện và báo cáo sự cố: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.\n",
      "content_html": "\u003ch2 id=\"bài-viết-tuân-thủ-nis2-cho-các-mạng-công-nghiệphttpswhitehatvnthreadstuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua17872\"\u003e\u003ca href=\"https://whitehat.vn/threads/tuan-thu-nis2-cho-cac-mang-cong-nghiep-ban-da-san-sang-chua.17872/\"\u003eBài viết: Tuân thủ NIS2 cho các mạng công nghiệp\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"nis2-compliance-for-industries-white-paperhttpswwwciscocomcenusproductscollateralsecurityindustrial-securitynetwork-info-security-wppdf\"\u003e\u003ca href=\"https://www.cisco.com/c/en/us/products/collateral/security/industrial-security/network-info-security-wp.pdf\"\u003eNIS2 Compliance for Industries White Paper\u003c/a\u003e\u003c/h3\u003e\n\u003ch3 id=\"tổng-hợp-các-thông-tin-cần-biết-trong-bài-viết\"\u003eTổng hợp các thông tin cần biết trong bài viết:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCác phần tử kết nối mạng OT cần được chứng nhận an toàn\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCác tiêu chuẩn ISA/IEC 62443 Phần 4-1 và Phần 4-2 ghi rõ một tài sản OT an toàn là gì.\u003c/li\u003e\n\u003cli\u003eVì vậy khi bạn mua các thiết bị, hãy yêu cầu nhà cung cấp chứng minh sản phẩm của họ tuân thủ theo tiêu chuẩn trên.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eĐánh giá và xếp loại ưu tiên các rủi ro mạng OT\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNhiều tổ chức vẫn chưa có một danh sách chi tiết về những gì đang được kết nối với mạng công nghiệp của họ.\u003c/li\u003e\n\u003cli\u003eNIS2 yêu cầu bạn có khả năng \u0026ldquo;nhìn xuyên thấu\u0026rdquo; vào hệ thống OT, từ đó áp dụng các quy tắc thực tiễn tốt nhất để đảm bảo an ninh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTriển khai Zero-trust\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHầu hết các mạng công nghiệp đã phát triển thành các mạng lớn và phẳng ở layer 2.\u003c/li\u003e\n\u003cli\u003eLưu lượng độc hại có thể dễ dàng lan truyền và chiếm quyền kiểm soát toàn bộ hoạt động của bạn.\u003c/li\u003e\n\u003cli\u003eISA/IEC 62443 Phần 3-3 yêu cầu phân đoạn mạng thành các vùng có phạm vi nhỏ. Trong mỗi vùng, các tài sản chỉ có thể giao tiếp với những thiết bị cần thiết, để có thể chạy theo quy trình công nghiệp sẵn có.\u003c/li\u003e\n\u003cli\u003eĐây chính là cách tiếp cận tối thiểu (Least Privillige) của an ninh mạng.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTriển khai Zero-trust remote access\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThay vì sử dụng các kết nối từ xa truyền thống tới mạng IT (VPN, remote desktop\u0026hellip;)\u003c/li\u003e\n\u003cli\u003eHãy sử dụng ZTNA ( Zero-Trust Network Access) với cơ chế phân quyền truy cập theo người dùng, theo thời gian, theo thiết bị, xác thực đa yếu tố, và cơ chế theo dõi hoạt động của kết nối đó trong suốt phiên truy cập.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePhát hiện và báo cáo sự cố\u003c/strong\u003e: NIS2 cũng yêu cầu có các công cụ để nhanh chóng phát hiện các sự cố và có thể thực hiện hành động phản ứng tức thời với các vi phạm an ninh.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"/image/IoT/OT.jfif\"\n  alt=\"OT\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/cybersecurity/technical/nis2/",
      "date_published": "25056-25-09T543:2525:00+07:00",
      "date_modified": "25056-25-09T543:2525:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "4cce4220308fd2f1f01e3e19db45c5f96e482829",
      "title": "Raspberry OpenAuto",
      "summary": "",
      "content_text": "OpenAuto Link\nSource\nTheo như mình hiểu thì OpenAuto, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.\nHình như CrankShaft cũng từ open source của OpenAuto mà ra.\nTham khảo\nVideo tham khảo https://www.youtube.com/watch?v=RgbHXTHUnQw https://www.youtube.com/watch?v=ko-udLtaPk8 ",
      "content_html": "\u003ch3 id=\"openauto\"\u003eOpenAuto\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://bluewavestudio.io/#features\"\u003eLink\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"9https://bluewavestudio.io/community/showthread.php?tid=2774\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTheo như mình hiểu thì \u003cstrong\u003eOpenAuto\u003c/strong\u003e, nó như một tool cho việc giao tiếp giữa người dùng và xe hơi, thông qua sử dụng Raspberry.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHình như \u003cstrong\u003eCrankShaft\u003c/strong\u003e cũng từ open source của \u003cstrong\u003eOpenAuto\u003c/strong\u003e mà ra.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/f1xpl/openauto/wiki\"\u003eTham khảo\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"video-tham-khao\"\u003eVideo tham khảo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=RgbHXTHUnQw\"\u003ehttps://www.youtube.com/watch?v=RgbHXTHUnQw\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=ko-udLtaPk8\"\u003ehttps://www.youtube.com/watch?v=ko-udLtaPk8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/raspberry-openauto/",
      "date_published": "1046-01-09T457:11:00+07:00",
      "date_modified": "1046-01-09T457:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "0bf57abd5b47956c7b4a48e0064a549fbeba3877",
      "title": "Pi400 Keyboard",
      "summary": "",
      "content_text": "Sử dụng Raspberry Pi400 như một bàn phím thông thường. https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/ https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard https://github.com/Gadgetoid/pi400kb/tree/main ",
      "content_html": "\u003ch3 id=\"sử-dụng-raspberry-pi400-như-một-bàn-phím-thông-thường\"\u003eSử dụng Raspberry Pi400 như một bàn phím thông thường.\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/\"\u003ehttps://www.cnx-software.com/2021/10/14/using-raspberry-pi-400-keyboard-pc-as-a-usb-keyboard-for-your-pc/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard\"\u003ehttps://www.tomshardware.com/news/raspberry-pi-400-usb-hid-keyboard\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Gadgetoid/pi400kb/tree/main\"\u003ehttps://github.com/Gadgetoid/pi400kb/tree/main\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://www.cytron.io/image/landing/RPI%20400/photo_2020-10-31_11-28-37.jpg\"\n  alt=\"Pi400\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/pi400-keyboard/",
      "date_published": "1046-01-09T453:11:00+07:00",
      "date_modified": "1046-01-09T453:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "1467c592c4f59f946735e658ee5827f9a222c791",
      "title": "PiKVM",
      "summary": "",
      "content_text": "PiKVM Theo tài liệu thì KVM (Keyboard-Video-Mouse), tức là PiKVM là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP. Tức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần: Màn hình để xuất hình ảnh. Chuột và bàn phím để điều khiển. Với PiKVM nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua WebUI. PiKVM lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa. Thông thường nếu chỉ dùng Anydesk, TeamViewer,\u0026hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất. Vậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của PiKVM. Tham khảo video https://www.youtube.com/watch?v=2HqbQdZUEmY https://www.youtube.com/watch?v=PppcpSVYh0E https://www.youtube.com/watch?v=KrpHCsK7veA Documents https://docs.pikvm.org/ https://pikvm.org/ https://wiki.geekworm.com/PiKVM Note PiKVM có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image. Cần thêm module covert từ HDMI - CSI ",
      "content_html": "\u003ch3 id=\"pikvmhttpsgithubcompikvmpikvm\"\u003e\u003ca href=\"https://github.com/pikvm/pikvm\"\u003ePiKVM\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTheo tài liệu thì \u003cstrong\u003eKVM (Keyboard-Video-Mouse)\u003c/strong\u003e, tức là \u003cstrong\u003ePiKVM\u003c/strong\u003e là sử dụng raspberry để điều khiển máy tính từ xa thông qua IP.\u003c/li\u003e\n\u003cli\u003eTức là giả sử mình có 1 PC, nếu mình muốn sử dụng PC này thì cần:\n\u003cul\u003e\n\u003cli\u003eMàn hình để xuất hình ảnh.\u003c/li\u003e\n\u003cli\u003eChuột và bàn phím để điều khiển.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eVới \u003cstrong\u003ePiKVM\u003c/strong\u003e nó sẽ ảo hóa hết tất cả màn hình, chuột, và bàn phím thông qua \u003cstrong\u003eWebUI\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePiKVM\u003c/strong\u003e lợi điểm ở chỗ là không cần phải xuống trực tiếp Server (hoặc PC) để fix sự cố, mà có thể làm điều đó từ xa.\u003c/li\u003e\n\u003cli\u003eThông thường nếu chỉ dùng Anydesk, TeamViewer,\u0026hellip; thì đây chỉ là những ứng dụng sau khi PC đã khởi động hoàn tất.\u003c/li\u003e\n\u003cli\u003eVậy lúc cần vào bios của PC để fix lỗi thì sao? Thì đây chính là lợi điểm của \u003cstrong\u003ePiKVM\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tham-khảo-video\"\u003eTham khảo video\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=2HqbQdZUEmY\"\u003ehttps://www.youtube.com/watch?v=2HqbQdZUEmY\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=PppcpSVYh0E\"\u003ehttps://www.youtube.com/watch?v=PppcpSVYh0E\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=KrpHCsK7veA\"\u003ehttps://www.youtube.com/watch?v=KrpHCsK7veA\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"documents\"\u003eDocuments\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.pikvm.org/\"\u003ehttps://docs.pikvm.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pikvm.org/\"\u003ehttps://pikvm.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://wiki.geekworm.com/PiKVM\"\u003ehttps://wiki.geekworm.com/PiKVM\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"note\"\u003eNote\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePiKVM\u003c/strong\u003e có sẵn OS. Tùy thuộc vào loại Raspberry sử dụng mà có sẵn image.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.waveshare.com/wiki/HDMI_to_CSI_Adapter\"\u003eCần thêm module covert từ HDMI - CSI\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/software/pikvm/",
      "date_published": "1046-01-09T449:11:00+07:00",
      "date_modified": "1046-01-09T449:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    },
    
    {
      "id": "571f7a701d03049f4c4b93851c869e0c14023691",
      "title": "UNIHIKER",
      "summary": "",
      "content_text": "Documents Getting Started with UNIHIKER Dfrobot Sản phẩm ",
      "content_html": "\u003ch3 id=\"documents\"\u003eDocuments\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.unihiker.com/wiki/get-started\"\u003eGetting Started with UNIHIKER\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.dfrobot.com/product-2691.html\"\u003eDfrobot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sản-phẩmhttpswwwproevnunihiker-iot-python-programming-single-board-computer-with-touchscreen\"\u003e\u003ca href=\"https://www.proe.vn/unihiker-iot-python-programming-single-board-computer-with-touchscreen\"\u003eSản phẩm\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg\n  src=\"https://cdn.mos.cms.futurecdn.net/KRLwXFfy86ybfwUdzxmaFm-1200-80.jpg\"\n  alt=\"SP\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n",
      "url": "https://vinhlin.github.io/posts/iot/hardware/unihiker/",
      "date_published": "1046-01-09T434:11:00+07:00",
      "date_modified": "1046-01-09T434:11:00+07:00",
      "author": {
        "name": "VinhLD",
        "url": "https://vinhlin.github.io/"
      }
    }
    
  ]
}